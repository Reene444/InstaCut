import {
  ActivityType,
  ApiVersion,
  ClassButton,
  ClassCollapsed,
  ClassDisabled,
  ClassDropping,
  ClassDroppingAfter,
  ClassDroppingBefore,
  ClassSelected,
  ContainerTypes,
  ContentTypes,
  DataGroup,
  DataType,
  DefaultContentId,
  Defined,
  DefinitionBase,
  DefinitionType,
  DroppingPosition,
  EditType,
  EmptyMethod,
  Endpoints,
  Errors,
  EventType,
  LayerType,
  MasherAction,
  Orientation,
  OutputType,
  OutputTypes,
  PropertyTweenSuffix,
  RectZero,
  SelectType,
  SelectTypes,
  ServerType,
  ServerTypes,
  Sizings,
  Timings,
  UploadTypes,
  arrayReversed,
  arraySet,
  assertCast,
  assertClip,
  assertDataGroup,
  assertDefined,
  assertDefinition,
  assertDefinitionType,
  assertEffect,
  assertMash,
  assertObject,
  assertPopulatedArray,
  assertPopulatedObject,
  assertPopulatedString,
  assertPositive,
  assertPreloadableDefinition,
  assertSelectType,
  assertString,
  assertTime,
  assertTimeRange,
  assertTrue,
  colorFromRgb,
  colorRgbDifference,
  colorToRgb,
  editorInstance,
  eventStop,
  fetchCallback,
  idGenerate,
  idPrefixSet,
  isAboveZero,
  isActionEvent,
  isArray,
  isChangeAction,
  isClip,
  isContainerDefinition,
  isDefined,
  isDefinition,
  isDefinitionObject,
  isDefinitionType,
  isEffect,
  isEffectDefinition,
  isEventType,
  isLayer,
  isLayerFolder,
  isMash,
  isMashAndDefinitionsObject,
  isNumber,
  isObject,
  isOrientation,
  isPopulatedArray,
  isPopulatedObject,
  isPopulatedString,
  isPositive,
  isSelectType,
  isSelectedProperty,
  isString,
  isTrack,
  isUndefined,
  isUploadType,
  pixelFromFrame,
  pixelPerFrame,
  pixelToFrame,
  rectCopy,
  rectRound,
  selectedPropertiesScalarObject,
  selectedPropertyObject,
  sizeAboveZero,
  sizeCeil,
  sizeCopy,
  sizeScale,
  stringSeconds,
  svgDefsElement,
  svgElement,
  svgPatternElement,
  svgPolygonElement,
  svgUrl,
  throwError,
  timeEqualizeRates,
  timeFromArgs,
  tweenInputTime,
  urlEndpoint,
  urlForEndpoint
} from "./chunk-AEA3CF2J.js";
import {
  require_react
} from "./chunk-O3W2YV4L.js";
import {
  __toESM
} from "./chunk-OCBYBPSH.js";

// node_modules/@moviemasher/client-react/esm/client-react.js
var import_react2 = __toESM(require_react());

// node_modules/@moviemasher/theme-default/esm/theme-default.js
var import_react = __toESM(require_react());
var DefaultContext = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
};
var IconContext = import_react.default.createContext && import_react.default.createContext(DefaultContext);
var __assign = globalThis.window && globalThis.window.__assign || function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __rest = globalThis.window && globalThis.window.__rest || function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
function Tree2Element(tree) {
  return tree && tree.map(function(node, i) {
    return import_react.default.createElement(node.tag, __assign({
      key: i
    }, node.attr), Tree2Element(node.child));
  });
}
function GenIcon(data) {
  return function(props) {
    return import_react.default.createElement(IconBase, __assign({
      attr: __assign({}, data.attr)
    }, props), Tree2Element(data.child));
  };
}
function IconBase(props) {
  var elem = function(conf) {
    var attr = props.attr, size = props.size, title = props.title, svgProps = __rest(props, ["attr", "size", "title"]);
    var computedSize = size || conf.size || "1em";
    var className;
    if (conf.className) className = conf.className;
    if (props.className) className = (className ? className + " " : "") + props.className;
    return import_react.default.createElement("svg", __assign({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, conf.attr, attr, svgProps, {
      className,
      style: __assign(__assign({
        color: props.color || conf.color
      }, conf.style), props.style),
      height: computedSize,
      width: computedSize,
      xmlns: "http://www.w3.org/2000/svg"
    }), title && import_react.default.createElement("title", null, title), props.children);
  };
  return IconContext !== void 0 ? import_react.default.createElement(IconContext.Consumer, null, function(conf) {
    return elem(conf);
  }) : elem(DefaultContext);
}
function AiOutlineColumnWidth(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 1024 1024" }, "child": [{ "tag": "path", "attr": { "d": "M180 176h-60c-4.4 0-8 3.6-8 8v656c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V184c0-4.4-3.6-8-8-8zm724 0h-60c-4.4 0-8 3.6-8 8v656c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V184c0-4.4-3.6-8-8-8zM785.3 504.3L657.7 403.6a7.23 7.23 0 0 0-11.7 5.7V476H378v-62.8c0-6-7-9.4-11.7-5.7L238.7 508.3a7.14 7.14 0 0 0 0 11.3l127.5 100.8c4.7 3.7 11.7.4 11.7-5.7V548h268v62.8c0 6 7 9.4 11.7 5.7l127.5-100.8c3.8-2.9 3.8-8.5.2-11.4z" } }] })(props);
}
function CgArrowLongLeftL(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none" }, "child": [{ "tag": "path", "attr": { "d": "M5.20837 7.75725L0.969116 12.0033L5.21515 16.2428L6.62823 14.8274L4.80949 13.0116L21.0229 13.0298L21.0189 15.0297L23.0189 15.0338L23.0309 9.03377L21.0309 9.02976L21.0249 12.019L21.0261 11.0298L4.78543 11.0115L6.62371 9.17033L5.20837 7.75725Z", "fill": "currentColor" } }] })(props);
}
function CgArrowLongRightL(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none" }, "child": [{ "tag": "path", "attr": { "d": "M18.9164 7.75739L23.1662 11.9929L18.9305 16.2426L17.5139 14.8308L19.3325 13.0061L2.8338 13.0285V15.0299H0.833801V9.02988H2.8338V11.0285L19.3429 11.0061L17.5046 9.17398L18.9164 7.75739Z", "fill": "currentColor" } }] })(props);
}
function RiStackFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "g", "attr": {}, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M20.083 10.5l1.202.721a.5.5 0 0 1 0 .858L12 17.65l-9.285-5.571a.5.5 0 0 1 0-.858l1.202-.721L12 15.35l8.083-4.85zm0 4.7l1.202.721a.5.5 0 0 1 0 .858l-8.77 5.262a1 1 0 0 1-1.03 0l-8.77-5.262a.5.5 0 0 1 0-.858l1.202-.721L12 20.05l8.083-4.85zM12.514 1.309l8.771 5.262a.5.5 0 0 1 0 .858L12 13 2.715 7.429a.5.5 0 0 1 0-.858l8.77-5.262a1 1 0 0 1 1.03 0z" } }] }] })(props);
}
function RiStackLine(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "g", "attr": {}, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M20.083 15.2l1.202.721a.5.5 0 0 1 0 .858l-8.77 5.262a1 1 0 0 1-1.03 0l-8.77-5.262a.5.5 0 0 1 0-.858l1.202-.721L12 20.05l8.083-4.85zm0-4.7l1.202.721a.5.5 0 0 1 0 .858L12 17.65l-9.285-5.571a.5.5 0 0 1 0-.858l1.202-.721L12 15.35l8.083-4.85zm-7.569-9.191l8.771 5.262a.5.5 0 0 1 0 .858L12 13 2.715 7.429a.5.5 0 0 1 0-.858l8.77-5.262a1 1 0 0 1 1.03 0zM12 3.332L5.887 7 12 10.668 18.113 7 12 3.332z" } }] }] })(props);
}
function RiChatVoiceFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "g", "attr": {}, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M4.929 19.071A9.969 9.969 0 0 1 2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10H2l2.929-2.929zM11 6v12h2V6h-2zM7 9v6h2V9H7zm8 0v6h2V9h-2z" } }] }] })(props);
}
function RiVideoChatFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "g", "attr": {}, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M6.455 19L2 22.5V4a1 1 0 0 1 1-1h18a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1H6.455zM14 10.25V8H7v6h7v-2.25L17 14V8l-3 2.25z" } }] }] })(props);
}
function RiEdit2Fill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "g", "attr": {}, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M9.243 19H21v2H3v-4.243l9.9-9.9 4.242 4.244L9.242 19zm5.07-13.556l2.122-2.122a1 1 0 0 1 1.414 0l2.829 2.829a1 1 0 0 1 0 1.414l-2.122 2.121-4.242-4.242z" } }] }] })(props);
}
function RiFolderAddFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "g", "attr": {}, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M12.414 5H21a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h7.414l2 2zM11 12H8v2h3v3h2v-3h3v-2h-3V9h-2v3z" } }] }] })(props);
}
function RiFolderLine(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "g", "attr": {}, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M4 5v14h16V7h-8.414l-2-2H4zm8.414 0H21a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h7.414l2 2z" } }] }] })(props);
}
function RiFolderOpenLine(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "g", "attr": {}, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M3 21a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h7.414l2 2H20a1 1 0 0 1 1 1v3h-2V7h-7.414l-2-2H4v11.998L5.5 11h17l-2.31 9.243a1 1 0 0 1-.97.757H3zm16.938-8H7.062l-1.5 6h12.876l1.5-6z" } }] }] })(props);
}
function RiFilmFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "g", "attr": {}, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M2 3.993A1 1 0 0 1 2.992 3h18.016c.548 0 .992.445.992.993v16.014a1 1 0 0 1-.992.993H2.992A.993.993 0 0 1 2 20.007V3.993zM4 5v2h2V5H4zm14 0v2h2V5h-2zM4 9v2h2V9H4zm14 0v2h2V9h-2zM4 13v2h2v-2H4zm14 0v2h2v-2h-2zM4 17v2h2v-2H4zm14 0v2h2v-2h-2z" } }] }] })(props);
}
function RiImageFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "g", "attr": {}, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M20 5H4v14l9.292-9.294a1 1 0 0 1 1.414 0L20 15.01V5zM2 3.993A1 1 0 0 1 2.992 3h18.016c.548 0 .992.445.992.993v16.014a1 1 0 0 1-.992.993H2.992A.993.993 0 0 1 2 20.007V3.993zM8 11a2 2 0 1 1 0-4 2 2 0 0 1 0 4z" } }] }] })(props);
}
function RiMusic2Fill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "g", "attr": {}, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M20 3v14a4 4 0 1 1-2-3.465V6H9v11a4 4 0 1 1-2-3.465V3h13z" } }] }] })(props);
}
function RiPauseCircleFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "g", "attr": {}, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zM9 9v6h2V9H9zm4 0v6h2V9h-2z" } }] }] })(props);
}
function RiPlayCircleFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "g", "attr": {}, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zM10.622 8.415a.4.4 0 0 0-.622.332v6.506a.4.4 0 0 0 .622.332l4.879-3.252a.4.4 0 0 0 0-.666l-4.88-3.252z" } }] }] })(props);
}
function RiVolumeMuteLine(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "g", "attr": {}, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M10 7.22L6.603 10H3v4h3.603L10 16.78V7.22zM5.889 16H2a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h3.889l5.294-4.332a.5.5 0 0 1 .817.387v15.89a.5.5 0 0 1-.817.387L5.89 16zm14.525-4l3.536 3.536-1.414 1.414L19 13.414l-3.536 3.536-1.414-1.414L17.586 12 14.05 8.464l1.414-1.414L19 10.586l3.536-3.536 1.414 1.414L20.414 12z" } }] }] })(props);
}
function RiVolumeUpLine(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "g", "attr": {}, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M10 7.22L6.603 10H3v4h3.603L10 16.78V7.22zM5.889 16H2a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h3.889l5.294-4.332a.5.5 0 0 1 .817.387v15.89a.5.5 0 0 1-.817.387L5.89 16zm13.517 4.134l-1.416-1.416A8.978 8.978 0 0 0 21 12a8.982 8.982 0 0 0-3.304-6.968l1.42-1.42A10.976 10.976 0 0 1 23 12c0 3.223-1.386 6.122-3.594 8.134zm-3.543-3.543l-1.422-1.422A3.993 3.993 0 0 0 16 12c0-1.43-.75-2.685-1.88-3.392l1.439-1.439A5.991 5.991 0 0 1 18 12c0 1.842-.83 3.49-2.137 4.591z" } }] }] })(props);
}
function RiAddLine(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "g", "attr": {}, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z" } }] }] })(props);
}
function RiArrowGoBackLine(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "g", "attr": {}, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M5.828 7l2.536 2.536L6.95 10.95 2 6l4.95-4.95 1.414 1.414L5.828 5H13a8 8 0 1 1 0 16H4v-2h9a6 6 0 1 0 0-12H5.828z" } }] }] })(props);
}
function RiArrowGoForwardLine(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "g", "attr": {}, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M18.172 7H11a6 6 0 1 0 0 12h9v2h-9a8 8 0 1 1 0-16h7.172l-2.536-2.536L17.05 1.05 22 6l-4.95 4.95-1.414-1.414L18.172 7z" } }] }] })(props);
}
function RiDeleteBin7Line(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "g", "attr": {}, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M17 6h5v2h-2v13a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V8H2V6h5V3a1 1 0 0 1 1-1h8a1 1 0 0 1 1 1v3zm1 2H6v12h12V8zM9 4v2h6V4H9z" } }] }] })(props);
}
function RiEyeOffLine(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "g", "attr": {}, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M17.882 19.297A10.949 10.949 0 0 1 12 21c-5.392 0-9.878-3.88-10.819-9a10.982 10.982 0 0 1 3.34-6.066L1.392 2.808l1.415-1.415 19.799 19.8-1.415 1.414-3.31-3.31zM5.935 7.35A8.965 8.965 0 0 0 3.223 12a9.005 9.005 0 0 0 13.201 5.838l-2.028-2.028A4.5 4.5 0 0 1 8.19 9.604L5.935 7.35zm6.979 6.978l-3.242-3.242a2.5 2.5 0 0 0 3.241 3.241zm7.893 2.264l-1.431-1.43A8.935 8.935 0 0 0 20.777 12 9.005 9.005 0 0 0 9.552 5.338L7.974 3.76C9.221 3.27 10.58 3 12 3c5.392 0 9.878 3.88 10.819 9a10.947 10.947 0 0 1-2.012 4.592zm-9.084-9.084a4.5 4.5 0 0 1 4.769 4.769l-4.77-4.769z" } }] }] })(props);
}
function MdInvertColors(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0V0z" } }, { "tag": "path", "attr": { "d": "M12 4.81V19c-3.31 0-6-2.63-6-5.87 0-1.56.62-3.03 1.75-4.14L12 4.81M6.35 7.56C4.9 8.99 4 10.96 4 13.13 4 17.48 7.58 21 12 21s8-3.52 8-7.87c0-2.17-.9-4.14-2.35-5.57L12 2 6.35 7.56z" } }] })(props);
}
function MdLabel(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z" } }] })(props);
}
function MdOpacity(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M24 0H0v24h24V0zm0 0H0v24h24V0zM0 24h24V0H0v24z" } }, { "tag": "path", "attr": { "d": "M17.66 8L12 2.35 6.34 8A8.02 8.02 0 004 13.64c0 2 .78 4.11 2.34 5.67a7.99 7.99 0 0011.32 0c1.56-1.56 2.34-3.67 2.34-5.67S19.22 9.56 17.66 8zM6 14c.01-2 .62-3.27 1.76-4.4L12 5.27l4.24 4.38C17.38 10.77 17.99 12 18 14H6z" } }] })(props);
}
function MdPermMedia(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M2 6H0v5h.01L0 20c0 1.1.9 2 2 2h18v-2H2V6zm20-2h-8l-2-2H6c-1.1 0-1.99.9-1.99 2L4 16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zM7 15l4.5-6 3.5 4.51 2.5-3.01L21 15H7z" } }] })(props);
}
function MdIncompleteCircle(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M22 12c0 5.52-4.48 10-10 10S2 17.52 2 12c0-2.76 1.12-5.26 2.93-7.07L12 12V2c5.52 0 10 4.48 10 10z" } }] })(props);
}
function MdOutlineSpeed(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M20.38 8.57l-1.23 1.85a8 8 0 01-.22 7.58H5.07A8 8 0 0115.58 6.85l1.85-1.23A10 10 0 003.35 19a2 2 0 001.72 1h13.85a2 2 0 001.74-1 10 10 0 00-.27-10.44z" } }, { "tag": "path", "attr": { "d": "M10.59 15.41a2 2 0 002.83 0l5.66-8.49-8.49 5.66a2 2 0 000 2.83z" } }] })(props);
}
function MdOutlineTextFields(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M2.5 4v3h5v12h3V7h5V4h-13zm19 5h-9v3h3v7h3v-7h3V9z" } }] })(props);
}
function MdOutlineTimelapse(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0V0z" } }, { "tag": "path", "attr": { "d": "M16.24 7.75A5.974 5.974 0 0012 5.99v6l-4.24 4.24c2.34 2.34 6.14 2.34 8.49 0a5.99 5.99 0 00-.01-8.48zM12 1.99c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z" } }] })(props);
}
function IoMdColorFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 512 512" }, "child": [{ "tag": "path", "attr": { "d": "M136.5 77.7l37 67L32 285.7 216.4 464l152.4-148.6 54.4-11.4L166.4 48l-29.9 29.7zm184 208H114.9l102.8-102.3 102.8 102.3zM423.3 304s-56.7 61.5-56.7 92.1c0 30.7 25.4 55.5 56.7 55.5 31.3 0 56.7-24.9 56.7-55.5S423.3 304 423.3 304z" } }] })(props);
}
function IoDocument(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 512 512" }, "child": [{ "tag": "path", "attr": { "d": "M428 224H288a48 48 0 01-48-48V36a4 4 0 00-4-4h-92a64 64 0 00-64 64v320a64 64 0 0064 64h224a64 64 0 0064-64V228a4 4 0 00-4-4z" } }, { "tag": "path", "attr": { "d": "M419.22 188.59L275.41 44.78a2 2 0 00-3.41 1.41V176a16 16 0 0016 16h129.81a2 2 0 001.41-3.41z" } }] })(props);
}
function BsAspectRatioFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "currentColor", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "d": "M0 12.5v-9A1.5 1.5 0 0 1 1.5 2h13A1.5 1.5 0 0 1 16 3.5v9a1.5 1.5 0 0 1-1.5 1.5h-13A1.5 1.5 0 0 1 0 12.5zM2.5 4a.5.5 0 0 0-.5.5v3a.5.5 0 0 0 1 0V5h2.5a.5.5 0 0 0 0-1h-3zm11 8a.5.5 0 0 0 .5-.5v-3a.5.5 0 0 0-1 0V11h-2.5a.5.5 0 0 0 0 1h3z" } }] })(props);
}
function BsSkipEndFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "currentColor", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "d": "M12.5 4a.5.5 0 0 0-1 0v3.248L5.233 3.612C4.693 3.3 4 3.678 4 4.308v7.384c0 .63.692 1.01 1.233.697L11.5 8.753V12a.5.5 0 0 0 1 0V4z" } }] })(props);
}
function BsSkipEnd(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "currentColor", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "d": "M12.5 4a.5.5 0 0 0-1 0v3.248L5.233 3.612C4.713 3.31 4 3.655 4 4.308v7.384c0 .653.713.998 1.233.696L11.5 8.752V12a.5.5 0 0 0 1 0V4zM5 4.633 10.804 8 5 11.367V4.633z" } }] })(props);
}
function BsSkipStartFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "currentColor", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "d": "M4 4a.5.5 0 0 1 1 0v3.248l6.267-3.636c.54-.313 1.232.066 1.232.696v7.384c0 .63-.692 1.01-1.232.697L5 8.753V12a.5.5 0 0 1-1 0V4z" } }] })(props);
}
function FaExclamationCircle(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 512 512" }, "child": [{ "tag": "path", "attr": { "d": "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z" } }] })(props);
}
function FaRegCheckCircle(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 512 512" }, "child": [{ "tag": "path", "attr": { "d": "M256 8C119.033 8 8 119.033 8 256s111.033 248 248 248 248-111.033 248-248S392.967 8 256 8zm0 48c110.532 0 200 89.451 200 200 0 110.532-89.451 200-200 200-110.532 0-200-89.451-200-200 0-110.532 89.451-200 200-200m140.204 130.267l-22.536-22.718c-4.667-4.705-12.265-4.736-16.97-.068L215.346 303.697l-59.792-60.277c-4.667-4.705-12.265-4.736-16.97-.069l-22.719 22.536c-4.705 4.667-4.736 12.265-.068 16.971l90.781 91.516c4.667 4.705 12.265 4.736 16.97.068l172.589-171.204c4.704-4.668 4.734-12.266.067-16.971z" } }] })(props);
}
function BiBorderInner(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M19 19h2v2h-2zM7 19h2v2H7zm8 0h2v2h-2zM3 19h2v2H3zm0-4h2v2H3zm0-8h2v2H3zm0-4h2v2H3zm12 0h2v2h-2zM7 3h2v2H7zm12 0h2v2h-2zm0 12h2v2h-2zm0-8h2v2h-2z" } }, { "tag": "path", "attr": { "d": "M5 13h6v8h2v-8h8v-2h-8V3h-2v8H3v2h1.93z" } }] })(props);
}
function BiBorderOuter(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M11 7h2v2h-2zm0 8h2v2h-2zm-4-4h2v2H7zm8 0h2v2h-2zm-4 0h2v2h-2z" } }, { "tag": "path", "attr": { "d": "M19 3H3v18h18V3h-2zm0 4v12H5V5h14v2z" } }] })(props);
}
function BiShapeTriangle(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M18 15c-.183 0-.358.022-.532.054L8.946 6.532C8.978 6.359 9 6.182 9 6c0-1.654-1.346-3-3-3S3 4.346 3 6c0 1.302.839 2.401 2 2.815v6.369A2.997 2.997 0 0 0 3 18c0 1.654 1.346 3 3 3a2.993 2.993 0 0 0 2.815-2h6.369a2.994 2.994 0 0 0 2.815 2c1.654 0 3-1.346 3-3S19.654 15 18 15zm-11 .184V8.816c.329-.118.629-.291.894-.508l7.799 7.799a2.961 2.961 0 0 0-.508.894h-6.37A2.99 2.99 0 0 0 7 15.184zM6 5a1.001 1.001 0 1 1-1 1c0-.551.448-1 1-1zm0 14a1.001 1.001 0 0 1 0-2 1.001 1.001 0 0 1 0 2zm12 0a1.001 1.001 0 0 1 0-2 1.001 1.001 0 0 1 0 2z" } }] })(props);
}
function GiDirectorChair(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 512 512" }, "child": [{ "tag": "path", "attr": { "d": "M157 21.234v16h18v-16zm180 0v16h18v-16zM153 55.232v62.002h206V55.232zm-3.89 80c-26.567 5.315-53.134 10.626-79.7 15.942l3.531 17.648L87 166.01v80.222h18V162.41l52-10.4v45.224h18v-62.002zm187.89 0v62.002h18V152.01l52 10.4v83.822h18V166.01l14.059 2.812 3.53-17.648c-26.565-5.315-53.132-10.628-79.698-15.942zm-174 80l-40.004 30.002h266.008L349 215.232zm-69.836 48l118.363 82.854c-37.367 27.406-74.74 54.805-112.105 82.213l10.642 14.514 18.743-13.745-8.008 20.823-37.332 26.13 10.322 14.745L256 377.216c54.07 37.851 108.142 75.698 162.21 113.55l10.323-14.745-37.332-26.13-8.008-20.823 18.743 13.745 10.642-14.514c-37.367-27.406-74.737-54.809-112.105-82.213l118.363-82.854h-31.383l-102.307 71.616-13.927-10.215 83.728-61.4H324.51L256 313.472l-68.51-50.24h-30.437l83.728 61.4-13.927 10.215-102.307-71.616zM256 335.793l13.574 9.955L256 355.25l-13.574-9.502zm-28.9 21.193l13.209 9.246-93.125 65.188 8.48-22.047zm57.8 0l71.436 52.387 8.48 22.047-93.125-65.186z" } }] })(props);
}
function GiHorizontalFlip(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 512 512" }, "child": [{ "tag": "path", "attr": { "d": "M387.02 278.627v67.883L477.53 256l-90.51-90.51v67.883H124.98V165.49L34.47 256l90.51 90.51v-67.883h262.04z" } }] })(props);
}
function GiMove(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 512 512" }, "child": [{ "tag": "path", "attr": { "d": "M256 34.47l-90.51 90.51h67.883v108.393H124.98V165.49L34.47 256l90.51 90.51v-67.883h108.393V387.02H165.49L256 477.53l90.51-90.51h-67.883V278.627H387.02v67.883L477.53 256l-90.51-90.51v67.883H278.627V124.98h67.883L256 34.47z" } }] })(props);
}
function GiResize(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 512 512" }, "child": [{ "tag": "path", "attr": { "d": "M29 30l1 90h36V66h26V30H29zm99 0v36h72V30h-72zm108 0v36h72V30h-72zm108 0v36h72V30h-72zm102 0v78h36V30h-36zm-206 80v36h100.543l-118 118H30v218h218V289.457l118-118V272h36V110H240zm206 34v72h36v-72h-36zM30 156v72h36v-72H30zm416 96v72h36v-72h-36zm0 108v72h36v-72h-36zm-166 86v36h72v-36h-72zm108 0v36h72v-36h-72z" } }] })(props);
}
function GiVerticalFlip(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 512 512" }, "child": [{ "tag": "path", "attr": { "d": "M233.373 387.02H165.49L256 477.53l90.51-90.51h-67.883V124.98h67.883L256 34.47l-90.51 90.51h67.883v262.04z" } }] })(props);
}
function TbActivityHeartbeat(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "strokeWidth": "2", "stroke": "currentColor", "fill": "none", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "desc", "attr": {}, "child": [] }, { "tag": "path", "attr": { "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" } }, { "tag": "path", "attr": { "d": "M3 12h4.5l1.5 -6l4 12l2 -9l1.5 3h4.5" } }] })(props);
}
function TbArrowAutofitHeight(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "strokeWidth": "2", "stroke": "currentColor", "fill": "none", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "desc", "attr": {}, "child": [] }, { "tag": "path", "attr": { "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" } }, { "tag": "path", "attr": { "d": "M12 20h-6a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h6" } }, { "tag": "path", "attr": { "d": "M18 14v7" } }, { "tag": "path", "attr": { "d": "M18 3v7" } }, { "tag": "path", "attr": { "d": "M15 18l3 3l3 -3" } }, { "tag": "path", "attr": { "d": "M15 6l3 -3l3 3" } }] })(props);
}
function TbArrowAutofitWidth(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "strokeWidth": "2", "stroke": "currentColor", "fill": "none", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "desc", "attr": {}, "child": [] }, { "tag": "path", "attr": { "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" } }, { "tag": "path", "attr": { "d": "M4 12v-6a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v6" } }, { "tag": "path", "attr": { "d": "M10 18h-7" } }, { "tag": "path", "attr": { "d": "M21 18h-7" } }, { "tag": "path", "attr": { "d": "M6 15l-3 3l3 3" } }, { "tag": "path", "attr": { "d": "M18 15l3 3l-3 3" } }] })(props);
}
function TbArrowBarRight(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "strokeWidth": "2", "stroke": "currentColor", "fill": "none", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "desc", "attr": {}, "child": [] }, { "tag": "path", "attr": { "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" } }, { "tag": "line", "attr": { "x1": "20", "y1": "12", "x2": "10", "y2": "12" } }, { "tag": "line", "attr": { "x1": "20", "y1": "12", "x2": "16", "y2": "16" } }, { "tag": "line", "attr": { "x1": "20", "y1": "12", "x2": "16", "y2": "8" } }, { "tag": "line", "attr": { "x1": "4", "y1": "4", "x2": "4", "y2": "20" } }] })(props);
}
function TbArrowBarToRight(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "strokeWidth": "2", "stroke": "currentColor", "fill": "none", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "desc", "attr": {}, "child": [] }, { "tag": "path", "attr": { "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" } }, { "tag": "line", "attr": { "x1": "14", "y1": "12", "x2": "4", "y2": "12" } }, { "tag": "line", "attr": { "x1": "14", "y1": "12", "x2": "10", "y2": "16" } }, { "tag": "line", "attr": { "x1": "14", "y1": "12", "x2": "10", "y2": "8" } }, { "tag": "line", "attr": { "x1": "20", "y1": "4", "x2": "20", "y2": "20" } }] })(props);
}
function TbFileImport(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "strokeWidth": "2", "stroke": "currentColor", "fill": "none", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "desc", "attr": {}, "child": [] }, { "tag": "path", "attr": { "stroke": "none", "d": "M0 0h24v24H0z", "fill": "none" } }, { "tag": "path", "attr": { "d": "M14 3v4a1 1 0 0 0 1 1h4" } }, { "tag": "path", "attr": { "d": "M5 13v-8a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2h-5.5m-9.5 -2h7m-3 -3l3 3l-3 3" } }] })(props);
}
function TiZoomInOutline(props) {
  return GenIcon({ "tag": "svg", "attr": { "version": "1.2", "baseProfile": "tiny", "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M13 11h-2v-2c0-.275-.225-.5-.5-.5s-.5.225-.5.5v2h-2c-.275 0-.5.225-.5.5s.225.5.5.5h2v2c0 .275.225.5.5.5s.5-.225.5-.5v-2h2c.275 0 .5-.225.5-.5s-.225-.5-.5-.5zM19.381 15.956l-2.244-2.283c.227-.687.363-1.412.363-2.173 0-3.859-3.141-7-7-7s-7 3.141-7 7 3.141 7 7 7c.762 0 1.488-.137 2.173-.364l2.397 2.386c.601.506 1.348.783 2.104.783 1.727 0 3.131-1.404 3.131-3.131 0-.84-.328-1.628-.924-2.218zm-3.901-1.11l2.492 2.531c.205.203.332.486.332.797 0 .625-.507 1.131-1.131 1.131-.312 0-.594-.127-.816-.313l-2.512-2.511c.646-.436 1.201-.991 1.635-1.635zm-9.98-3.346c0-2.757 2.243-5 5-5s5 2.243 5 5-2.243 5-5 5-5-2.243-5-5z" } }] })(props);
}
function TiZoomOutOutline(props) {
  return GenIcon({ "tag": "svg", "attr": { "version": "1.2", "baseProfile": "tiny", "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M13 12h-5c-.275 0-.5-.225-.5-.5s.225-.5.5-.5h5c.275 0 .5.225.5.5s-.225.5-.5.5zM19.381 15.956l-2.245-2.283c.228-.687.364-1.412.364-2.173 0-3.859-3.141-7-7-7s-7 3.141-7 7 3.141 7 7 7c.761 0 1.488-.137 2.173-.364l2.397 2.386c.601.506 1.348.783 2.104.783 1.727 0 3.131-1.404 3.131-3.131 0-.84-.328-1.628-.924-2.218zm-3.901-1.11l2.492 2.531c.205.203.332.486.332.797 0 .625-.507 1.131-1.131 1.131-.312 0-.594-.127-.816-.313l-2.512-2.511c.646-.436 1.201-.991 1.635-1.635zm-9.98-3.346c0-2.757 2.243-5 5-5s5 2.243 5 5-2.243 5-5 5-5-2.243-5-5z" } }] })(props);
}
function HiEye(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 20 20", "fill": "currentColor" }, "child": [{ "tag": "path", "attr": { "d": "M10 12a2 2 0 100-4 2 2 0 000 4z" } }, { "tag": "path", "attr": { "fillRule": "evenodd", "d": "M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z", "clipRule": "evenodd" } }] })(props);
}
function HiLockClosed(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 20 20", "fill": "currentColor" }, "child": [{ "tag": "path", "attr": { "fillRule": "evenodd", "d": "M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z", "clipRule": "evenodd" } }] })(props);
}
function HiLockOpen(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 20 20", "fill": "currentColor" }, "child": [{ "tag": "path", "attr": { "d": "M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z" } }] })(props);
}
function VscTriangleDown(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 16 16", "fill": "currentColor" }, "child": [{ "tag": "path", "attr": { "d": "M2 5.56L2.413 5h11.194l.393.54L8.373 11h-.827L2 5.56z" } }] })(props);
}
function VscTriangleRight(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 16 16", "fill": "currentColor" }, "child": [{ "tag": "path", "attr": { "d": "M5.56 14L5 13.587V2.393L5.54 2 11 7.627v.827L5.56 14z" } }] })(props);
}
function ImFileVideo(props) {
  return GenIcon({ "tag": "svg", "attr": { "version": "1.1", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "d": "M14.341 3.579c-0.347-0.473-0.831-1.027-1.362-1.558s-1.085-1.015-1.558-1.362c-0.806-0.591-1.197-0.659-1.421-0.659h-7.75c-0.689 0-1.25 0.561-1.25 1.25v13.5c0 0.689 0.561 1.25 1.25 1.25h11.5c0.689 0 1.25-0.561 1.25-1.25v-9.75c0-0.224-0.068-0.615-0.659-1.421v0 0zM12.271 2.729c0.48 0.48 0.856 0.912 1.134 1.271h-2.406v-2.405c0.359 0.278 0.792 0.654 1.271 1.134v0 0zM14 14.75c0 0.136-0.114 0.25-0.25 0.25h-11.5c-0.135 0-0.25-0.114-0.25-0.25v-13.5c0-0.135 0.115-0.25 0.25-0.25 0 0 7.749-0 7.75 0v3.5c0 0.276 0.224 0.5 0.5 0.5h3.5v9.75z" } }, { "tag": "path", "attr": { "d": "M4 8h5v5h-5v-5z" } }, { "tag": "path", "attr": { "d": "M9 10l3-2v5l-3-2z" } }] })(props);
}
var MMWideIcon = () => {
  return import_react.default.createElement(
    "svg",
    { width: "2em", height: "1em", viewBox: "0 0 48 24" },
    import_react.default.createElement("path", { d: "M 0.00 0.00 L 48.00 0.00 L 48.00 24.00 L 0.00 24.00 Z M 0.00 0.00", stroke: "none", fill: "none" }),
    import_react.default.createElement("path", { d: "M 9.16 2.00 C 8.62 2.00 8.13 2.18 7.73 2.57 L 7.73 2.57 L 1.19 8.91 C 0.77 9.34 0.55 9.82 0.53 10.39 L 0.53 10.39 C 0.53 10.91 0.72 11.37 1.13 11.76 L 1.13 11.76 C 1.56 12.15 2.05 12.31 2.60 12.28 L 2.60 12.28 C 3.17 12.31 3.64 12.13 4.03 11.70 L 4.03 11.70 L 9.16 6.90 L 13.67 11.28 C 14.33 11.87 14.67 12.20 14.73 12.24 L 14.73 12.24 C 15.12 12.63 15.60 12.81 16.14 12.81 L 16.14 12.81 C 16.69 12.85 17.20 12.66 17.63 12.28 L 17.63 12.28 C 17.67 12.26 18.01 11.93 18.63 11.28 L 18.63 11.28 C 19.29 10.65 20.07 9.93 20.93 9.12 L 20.93 9.12 C 21.82 8.23 22.57 7.51 23.20 6.90 L 23.20 6.90 L 31.34 14.86 C 31.74 15.25 32.21 15.47 32.72 15.51 L 32.72 15.51 L 38.29 15.51 L 38.23 19.10 L 44.00 13.55 L 38.29 7.90 L 38.29 11.54 L 33.65 11.48 L 24.63 2.63 C 24.22 2.28 23.74 2.09 23.20 2.09 L 23.20 2.09 C 22.65 2.07 22.16 2.24 21.71 2.63 L 21.71 2.63 L 16.20 8.01 L 11.64 3.63 C 10.98 2.96 10.64 2.61 10.60 2.57 L 10.60 2.57 C 10.18 2.18 9.75 2.00 9.28 2.00 L 9.28 2.00 C 9.24 2.00 9.20 2.00 9.16 2.00", stroke: "none", fill: "currentColor" }),
    import_react.default.createElement("path", { d: "M 7.70 11.61 L 2.58 16.53 L 0.00 14.05 L 0.00 21.91 L 8.15 21.91 L 5.49 19.38 C 5.53 19.38 5.56 19.36 5.60 19.32 L 5.60 19.32 L 9.19 15.88 L 14.75 21.28 C 15.14 21.67 15.62 21.85 16.16 21.85 L 16.16 21.85 C 16.73 21.89 17.22 21.72 17.65 21.33 L 17.65 21.33 L 23.16 15.88 L 28.78 21.43 C 29.18 21.78 29.67 21.96 30.21 21.96 L 30.21 21.96 L 34.34 22.00 C 34.93 21.98 35.42 21.78 35.83 21.43 L 35.83 21.43 C 36.23 21.04 36.44 20.56 36.44 19.95 L 36.44 19.95 C 36.44 19.39 36.23 18.91 35.83 18.53 L 35.83 18.53 C 35.46 18.17 34.99 18.01 34.40 18.01 L 34.40 18.01 L 31.10 17.95 L 24.65 11.67 C 24.25 11.32 23.76 11.13 23.22 11.13 L 23.22 11.13 C 22.67 11.11 22.18 11.28 21.75 11.67 L 21.75 11.67 L 16.16 16.99 L 10.56 11.61 C 10.15 11.22 9.69 11.04 9.19 11.04 L 9.19 11.04 C 8.64 11.04 8.15 11.22 7.70 11.61", stroke: "none", fill: "currentColor" })
  );
};
var MMLogo = () => {
  return import_react.default.createElement(
    "svg",
    { width: "52", height: "24" },
    import_react.default.createElement(
      "defs",
      null,
      import_react.default.createElement(
        "linearGradient",
        { id: "gradient_0", gradientUnits: "userSpaceOnUse", x1: "27.12", y1: "20.06", x2: "26.83", y2: "0.10" },
        import_react.default.createElement("stop", { offset: "0%", stopColor: "#62789b" }),
        import_react.default.createElement("stop", { offset: "100%", stopColor: "#8c9bdd" })
      )
    ),
    import_react.default.createElement("path", { d: "M 10.83 0.00 C 10.18 0.00 9.61 0.22 9.14 0.69 L 9.14 0.69 L 1.40 8.29 C 0.91 8.81 0.64 9.38 0.62 10.07 L 0.62 10.07 C 0.62 10.69 0.85 11.24 1.34 11.71 L 1.34 11.71 C 1.85 12.18 2.43 12.38 3.07 12.33 L 3.07 12.33 C 3.74 12.38 4.30 12.15 4.77 11.64 L 4.77 11.64 L 10.83 5.88 L 16.16 11.13 C 16.94 11.84 17.34 12.24 17.41 12.29 L 17.41 12.29 C 17.87 12.75 18.43 12.97 19.08 12.97 L 19.08 12.97 C 19.72 13.02 20.33 12.80 20.84 12.33 L 20.84 12.33 C 20.88 12.31 21.28 11.91 22.02 11.13 L 22.02 11.13 C 22.80 10.38 23.71 9.51 24.74 8.54 L 24.74 8.54 C 25.79 7.47 26.68 6.61 27.41 5.88 L 27.41 5.88 L 37.04 15.44 C 37.51 15.90 38.07 16.17 38.67 16.21 L 38.67 16.21 L 45.25 16.21 L 45.18 20.52 L 52.00 13.86 L 45.25 7.08 L 45.25 11.44 L 39.76 11.38 L 29.11 0.75 C 28.62 0.33 28.06 0.11 27.41 0.11 L 27.41 0.11 C 26.77 0.09 26.19 0.29 25.65 0.75 L 25.65 0.75 L 19.15 7.21 L 13.75 1.95 C 12.97 1.15 12.57 0.73 12.52 0.69 L 12.52 0.69 C 12.03 0.22 11.52 0.00 10.96 0.00 L 10.96 0.00 C 10.92 0.00 10.88 0.00 10.83 0.00", stroke: "none", fill: "url(#gradient_0)" }),
    import_react.default.createElement(
      "defs",
      null,
      import_react.default.createElement(
        "linearGradient",
        { id: "gradient_1", gradientUnits: "userSpaceOnUse", x1: "22.21", y1: "23.71", x2: "21.97", y2: "10.91" },
        import_react.default.createElement("stop", { offset: "0%", stopColor: "#62789b" }),
        import_react.default.createElement("stop", { offset: "100%", stopColor: "#8c9bdd" })
      )
    ),
    import_react.default.createElement("path", { d: "M 9.09 11.54 L 3.05 17.44 L -0.00 14.46 L -0.00 23.89 L 9.63 23.89 L 6.49 20.85 C 6.53 20.85 6.58 20.83 6.62 20.78 L 6.62 20.78 L 10.86 16.66 L 17.43 23.14 C 17.90 23.60 18.46 23.82 19.10 23.82 L 19.10 23.82 C 19.77 23.87 20.35 23.67 20.86 23.20 L 20.86 23.20 L 27.37 16.66 L 34.01 23.31 C 34.48 23.73 35.06 23.96 35.71 23.96 L 35.71 23.96 L 40.59 24.00 C 41.28 23.98 41.86 23.73 42.35 23.31 L 42.35 23.31 C 42.82 22.85 43.06 22.27 43.06 21.54 L 43.06 21.54 C 43.06 20.87 42.82 20.30 42.35 19.83 L 42.35 19.83 C 41.90 19.41 41.35 19.21 40.66 19.21 L 40.66 19.21 L 36.76 19.14 L 29.13 11.60 C 28.66 11.18 28.08 10.96 27.44 10.96 L 27.44 10.96 C 26.79 10.94 26.21 11.14 25.70 11.60 L 25.70 11.60 L 19.10 17.99 L 12.48 11.54 C 11.99 11.07 11.46 10.85 10.86 10.85 L 10.86 10.85 C 10.21 10.85 9.63 11.07 9.09 11.54", stroke: "none", fill: "url(#gradient_1)" })
  );
};
var MMTubeIcon = () => {
  return import_react.default.createElement(
    "svg",
    { width: "1em", height: "1em", viewBox: "0 0 24 24" },
    import_react.default.createElement(
      "defs",
      null,
      import_react.default.createElement(
        "clipPath",
        { id: "tube-m-m" },
        import_react.default.createElement("path", { d: "\n          M 3.60 21.00 C 1.61 21.00 0.00 19.39 0.00 17.40 L 0.00 6.60 C 0.00 4.61 1.61 3.00 3.60 3.00 L 20.40 3.00 C 22.39 3.00 24.00 4.61 24.00 6.60 L 24.00 17.40 C 24.00 19.39 22.39 21.00 20.40 21.00 Z M 3.60 21.00\n          M 5.57 11.81 L 3.03 14.30 L 1.75 13.04 L 1.75 17.03 L 5.79 17.03 L 4.47 15.75 C 4.49 15.75 4.51 15.74 4.53 15.72 L 4.53 15.72 L 6.30 13.97 L 9.06 16.71 C 9.26 16.91 9.49 17.00 9.76 17.00 L 9.76 17.00 C 10.04 17.02 10.28 16.94 10.50 16.74 L 10.50 16.74 L 13.23 13.97 L 16.01 16.79 C 16.21 16.96 16.45 17.06 16.72 17.06 L 16.72 17.06 L 18.77 17.08 C 19.06 17.07 19.30 16.96 19.51 16.79 L 19.51 16.79 C 19.70 16.59 19.81 16.35 19.81 16.04 L 19.81 16.04 C 19.81 15.75 19.70 15.51 19.51 15.31 L 19.51 15.31 C 19.32 15.14 19.09 15.05 18.80 15.05 L 18.80 15.05 L 17.16 15.02 L 13.97 11.83 C 13.77 11.65 13.53 11.56 13.26 11.56 L 13.26 11.56 C 12.99 11.55 12.74 11.64 12.53 11.83 L 12.53 11.83 L 9.76 14.54 L 6.99 11.81 C 6.78 11.61 6.56 11.51 6.30 11.51 L 6.30 11.51 C 6.03 11.51 5.79 11.61 5.57 11.81\n          M 6.29 6.93 C 6.02 6.93 5.78 7.02 5.58 7.22 L 5.58 7.22 L 2.34 10.43 C 2.14 10.65 2.02 10.89 2.01 11.18 L 2.01 11.18 C 2.01 11.45 2.11 11.68 2.31 11.88 L 2.31 11.88 C 2.53 12.08 2.77 12.16 3.04 12.14 L 3.04 12.14 C 3.32 12.16 3.56 12.07 3.75 11.85 L 3.75 11.85 L 6.29 9.41 L 8.53 11.64 C 8.85 11.94 9.02 12.10 9.05 12.12 L 9.05 12.12 C 9.25 12.32 9.48 12.41 9.75 12.41 L 9.75 12.41 C 10.02 12.43 10.27 12.34 10.49 12.14 L 10.49 12.14 C 10.51 12.13 10.68 11.96 10.98 11.64 L 10.98 11.64 C 11.31 11.32 11.70 10.95 12.12 10.54 L 12.12 10.54 C 12.56 10.09 12.94 9.72 13.25 9.41 L 13.25 9.41 L 17.28 13.46 C 17.48 13.65 17.71 13.76 17.97 13.78 L 17.97 13.78 L 20.72 13.78 L 20.69 15.60 L 23.55 12.79 L 20.72 9.92 L 20.72 11.77 L 18.42 11.74 L 13.96 7.24 C 13.75 7.07 13.52 6.97 13.25 6.97 L 13.25 6.97 C 12.98 6.96 12.73 7.05 12.51 7.24 L 12.51 7.24 L 9.78 9.97 L 7.52 7.75 C 7.19 7.41 7.02 7.24 7.00 7.22 L 7.00 7.22 C 6.80 7.02 6.58 6.93 6.35 6.93 L 6.35 6.93 C 6.33 6.93 6.31 6.93 6.29 6.93\n        " })
      )
    ),
    import_react.default.createElement("path", { clipPath: "url(#tube-m-m)", d: "M 0.00 0.00 L 24.00 0.00 L 24.00 24.00 L 0.00 24.00 Z M 0.00 0.00", stroke: "none", fill: "currentColor" })
  );
};
var Icons = {
  active: import_react.default.createElement(MdIncompleteCircle, { key: "active" }),
  activity: import_react.default.createElement(TbActivityHeartbeat, { key: "activity" }),
  add: import_react.default.createElement(RiAddLine, { key: "add" }),
  app: import_react.default.createElement(MMLogo, { key: "app" }),
  // audible: <RiVolumeUpLine key='audible' />,
  // audio: <RiMusicLine key="audio" />,
  // broadcast: <RiBroadcastFill key='broadcast' />,
  browser: import_react.default.createElement(MdPermMedia, { key: "browser" }),
  browserAudio: import_react.default.createElement(RiMusic2Fill, { key: "browserAudio" }),
  browserAudioStream: import_react.default.createElement(RiChatVoiceFill, { key: "browserAudioStream" }),
  browserEffect: import_react.default.createElement(MdInvertColors, { key: "browserEffect" }),
  browserImage: import_react.default.createElement(RiImageFill, { key: "browserImage" }),
  browserShape: import_react.default.createElement(BiShapeTriangle, { key: "browserShape" }),
  browserText: import_react.default.createElement(MdOutlineTextFields, { key: "browserText" }),
  browserVideo: import_react.default.createElement(RiFilmFill, { key: "browserVideo" }),
  browserVideoStream: import_react.default.createElement(RiVideoChatFill, { key: "browserVideoStream" }),
  // chat: <RiChat3Fill key='chat' />,
  clip: import_react.default.createElement(MdOutlineTimelapse, { key: "clip" }),
  collapse: import_react.default.createElement(VscTriangleDown, { key: "collapse" }),
  collapsed: import_react.default.createElement(VscTriangleRight, { key: "collapsed" }),
  color: import_react.default.createElement(IoMdColorFill, { key: "color" }),
  complete: import_react.default.createElement(FaRegCheckCircle, { key: "complete" }),
  composer: import_react.default.createElement(GiDirectorChair, { key: "composer" }),
  container: import_react.default.createElement(BiBorderOuter, { key: "container" }),
  content: import_react.default.createElement(BiBorderInner, { key: "content" }),
  document: import_react.default.createElement(IoDocument, { key: "document" }),
  end: import_react.default.createElement(BsSkipEndFill, { key: "end" }),
  endUndefined: import_react.default.createElement(BsSkipEnd, { key: "endUndefined" }),
  gain: import_react.default.createElement(RiVolumeUpLine, { key: "gain" }),
  error: import_react.default.createElement(FaExclamationCircle, { key: "error" }),
  folder: import_react.default.createElement(RiFolderLine, { key: "folder" }),
  folderAdd: import_react.default.createElement(RiFolderAddFill, { key: "folderAdd" }),
  folderOpen: import_react.default.createElement(RiFolderOpenLine, { key: "folderOpen" }),
  frame: import_react.default.createElement(TbArrowBarRight, { key: "frame" }),
  frames: import_react.default.createElement(TbArrowBarToRight, { key: "frames" }),
  height: import_react.default.createElement(TbArrowAutofitHeight, { key: "height" }),
  horz: import_react.default.createElement(GiHorizontalFlip, { key: "horz-flip" }),
  inaudible: import_react.default.createElement(RiVolumeMuteLine, { key: "inaudible" }),
  inspector: import_react.default.createElement(RiEdit2Fill, { key: "inspector" }),
  invisible: import_react.default.createElement(RiEyeOffLine, { key: "invisible" }),
  label: import_react.default.createElement(MdLabel, { key: "label" }),
  lock: import_react.default.createElement(HiLockClosed, { key: "lock" }),
  // matte: <BsReverseLayoutSidebarInsetReverse key="matte" />,
  // message: <RiMessage3Fill key='message' />,
  // mm: <MMIcon key="mm" />,
  mmTube: import_react.default.createElement(MMTubeIcon, { key: "mmTube" }),
  mmWide: import_react.default.createElement(MMWideIcon, { key: "mmWide" }),
  opacity: import_react.default.createElement(MdOpacity, { key: "opacity" }),
  playerPause: import_react.default.createElement(RiPauseCircleFill, { key: "player-pause" }),
  playerPlay: import_react.default.createElement(RiPlayCircleFill, { key: "player-play" }),
  point: import_react.default.createElement(GiMove, { key: "point" }),
  redo: import_react.default.createElement(RiArrowGoForwardLine, { key: "redo" }),
  muted: import_react.default.createElement(RiVolumeMuteLine, { key: "muted" }),
  remove: import_react.default.createElement(RiDeleteBin7Line, { key: "remove" }),
  render: import_react.default.createElement(ImFileVideo, { key: "render" }),
  size: import_react.default.createElement(GiResize, { key: "size" }),
  sizing: import_react.default.createElement(BsAspectRatioFill, { key: "sizing" }),
  start: import_react.default.createElement(BsSkipStartFill, { key: "start" }),
  // streamers: <FaUserCircle key='streamers' />,
  timeline: import_react.default.createElement(MdOutlineTimelapse, { key: "timeline" }),
  timing: import_react.default.createElement(AiOutlineColumnWidth, { key: "timing" }),
  startTrim: import_react.default.createElement(CgArrowLongRightL, { key: "start-trim" }),
  speed: import_react.default.createElement(MdOutlineSpeed, { key: "speed" }),
  endTrim: import_react.default.createElement(CgArrowLongLeftL, { key: "end-trim" }),
  track: import_react.default.createElement(RiStackLine, { key: "track" }),
  trackDense: import_react.default.createElement(RiStackFill, { key: "track-dense" }),
  undo: import_react.default.createElement(RiArrowGoBackLine, { key: "undo" }),
  unlock: import_react.default.createElement(HiLockOpen, { key: "unlock" }),
  import: import_react.default.createElement(TbFileImport, { key: "upload" }),
  vert: import_react.default.createElement(GiVerticalFlip, { key: "vert" }),
  // video: <RiArrowRightSLine key="video" />,
  view: import_react.default.createElement(HiEye, { key: "view" }),
  // visible: <RiEyeLine key='visible' />,
  width: import_react.default.createElement(TbArrowAutofitWidth, { key: "width" }),
  zoomLess: import_react.default.createElement(TiZoomOutOutline, { key: "zoom-less" }),
  zoomMore: import_react.default.createElement(TiZoomInOutline, { key: "zoom-more" })
};

// node_modules/@moviemasher/client-react/esm/client-react.js
function __rest2(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var View = import_react2.default.forwardRef((props, ref) => import_react2.default.createElement("div", Object.assign({ ref }, props)));
var LabelRegex = /{{([a-z0-9_]*)}}/;
var labelObjects = {
  import: {
    bytes: "Size above {{value}}",
    extension: "Extension {{value}}",
    type: "Type {{value}}",
    size: "Dimensions {{value}}",
    duration: "Duration {{value}}",
    render: "{{value}}",
    displaySize: "{{width}}x{{height}}"
  }
};
var labels = {
  audible: "Audible",
  clip: "Clip",
  update: "Save",
  delete: "Remove {{type}}",
  unlabeled: "Unlabeled {{type}}",
  analyze: "Analyzing...",
  load: "Loading...",
  complete: "Completed",
  layer: "Layer",
  create: "New",
  render: "Render",
  view: "View",
  open: "Open...",
  undo: "Undo",
  redo: "Redo",
  cast: "Cast",
  mash: "Mash"
};
var labelLookup = (id) => {
  const [first, second] = id.split(".");
  return labelObjects[first][second];
};
var labelTranslate = (id) => {
  if (id.includes("."))
    return labelLookup(id);
  return labels[id] || id;
};
var labelInterpolate = (id, context) => {
  let translated = labelTranslate(id);
  const matches = translated.match(LabelRegex);
  if (!matches)
    return translated;
  matches.forEach((match, index) => {
    if (!index)
      return;
    const search = `{{${match}}}`;
    const replace = labelTranslate(context[match]);
    translated = translated.replace(search, replace);
  });
  return translated;
};
var activityLabel = (info) => {
  if (!isObject(info))
    return "";
  const { label, error, type, value } = info;
  if (error) {
    if (value)
      return labelInterpolate(error, { value });
    return labelTranslate(error);
  }
  return labelTranslate(type);
};
var ActivityGroup;
(function(ActivityGroup2) {
  ActivityGroup2["Active"] = "active";
  ActivityGroup2["Error"] = "error";
  ActivityGroup2["Complete"] = "complete";
})(ActivityGroup || (ActivityGroup = {}));
var ActivityGroups = Object.values(ActivityGroup);
var isActivityGroup = (type) => {
  return isPopulatedString(type) && ActivityGroups.includes(type);
};
function assertActivityGroup(value, name) {
  if (!isActivityGroup(value))
    throwError(value, "ActivityGroup", name);
}
var ActivityContextDefault = {
  label: "",
  activities: [],
  allActivities: [],
  picked: ActivityGroup.Active,
  pick: EmptyMethod
};
var ActivityContext = import_react2.default.createContext(ActivityContextDefault);
var CollapseContextDefault = {
  collapsed: false,
  changeCollapsed: () => {
  }
};
var CollapseContext = import_react2.default.createContext(CollapseContextDefault);
var MasherContextDefault = {
  changeDefinition: EmptyMethod,
  drop: () => Promise.resolve([]),
  editorIndex: {},
  icons: {},
  save: EmptyMethod,
  setDraggable: EmptyMethod
};
var MasherContext = import_react2.default.createContext(MasherContextDefault);
var useEditorActivity = () => {
  const masherContext = import_react2.default.useContext(MasherContext);
  const { editor } = masherContext;
  assertDefined(editor);
  const allActivitiesRef = import_react2.default.useRef([]);
  const { eventTarget } = editor;
  const getSnapshot = () => {
    return allActivitiesRef.current;
  };
  const handleEvent = (event) => {
    const { type } = event;
    if (isEventType(type) && event instanceof CustomEvent) {
      const info = event.detail;
      const { id, type: type2 } = info;
      const { current: allActivities } = allActivitiesRef;
      const existing = allActivities.find((activity2) => activity2.id === id);
      const activity = existing || { id, activityGroup: ActivityGroup.Active, infos: [] };
      activity.infos.unshift(info);
      if (type2 === ActivityType.Complete)
        activity.activityGroup = ActivityGroup.Complete;
      else if (type2 === ActivityType.Error) {
        activity.activityGroup = ActivityGroup.Error;
      }
      if (!existing)
        allActivities.unshift(activity);
    }
  };
  const externalStore = import_react2.default.useSyncExternalStore((callback) => {
    eventTarget.addEventListener(EventType.Active, callback);
    return () => {
      eventTarget.removeEventListener(EventType.Active, callback);
    };
  }, getSnapshot);
  const removeListener = () => {
    eventTarget.removeEventListener(EventType.Active, handleEvent);
  };
  const addListener = () => {
    eventTarget.addEventListener(EventType.Active, handleEvent);
    return () => {
      removeListener();
    };
  };
  import_react2.default.useEffect(() => addListener(), []);
  return [editor, externalStore];
};
function Activity(props) {
  const { initialPicked = ActivityGroup.Active, initialCollapsed = false, className } = props, rest = __rest2(props, ["initialPicked", "initialCollapsed", "className"]);
  assertActivityGroup(initialPicked);
  const [collapsed, setCollapsed] = import_react2.default.useState(initialCollapsed);
  const [label, setLabel] = import_react2.default.useState("");
  const [editor, activity] = useEditorActivity();
  const [picked, setPicked] = import_react2.default.useState(initialPicked);
  const filteredActivities = import_react2.default.useMemo(() => {
    return activity.filter((activity2) => activity2.activityGroup === picked);
  }, [picked, activity.length]);
  const activityContext = {
    activities: filteredActivities,
    allActivities: activity,
    picked,
    pick: setPicked,
    label
  };
  const collapseContext = { collapsed, changeCollapsed: setCollapsed };
  const classes = [];
  if (className)
    classes.push(className);
  if (collapsed)
    classes.push(ClassCollapsed);
  const viewProps = Object.assign(Object.assign({}, rest), { className: classes.join(" ") });
  return import_react2.default.createElement(
    ActivityContext.Provider,
    { value: activityContext },
    import_react2.default.createElement(
      CollapseContext.Provider,
      { value: collapseContext },
      import_react2.default.createElement(View, Object.assign({}, viewProps))
    )
  );
}
var ActivityContentContextDefault = {
  infos: [],
  activityGroup: ActivityGroup.Active,
  id: ""
};
var ActivityContentContext = import_react2.default.createContext(ActivityContentContextDefault);
function ActivityContent(props) {
  const activityContext = import_react2.default.useContext(ActivityContext);
  const panelContext = import_react2.default.useContext(CollapseContext);
  const { collapsed } = panelContext;
  const { activities } = activityContext;
  if (collapsed)
    return null;
  const { children } = props, rest = __rest2(props, ["children"]);
  const child = import_react2.default.Children.only(children);
  assertTrue(import_react2.default.isValidElement(child));
  const viewChildren = activities.map((activity) => {
    const children2 = import_react2.default.cloneElement(child);
    const contextProps = { children: children2, value: activity, key: activity.id };
    const context = import_react2.default.createElement(ActivityContentContext.Provider, Object.assign({}, contextProps));
    return context;
  });
  const viewProps = Object.assign(Object.assign({}, rest), { children: viewChildren });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
function ActivityItem(props) {
  const { collapsed: collapsedProp } = props, rest = __rest2(props, ["collapsed"]);
  const [collapsed, changeCollapsed] = import_react2.default.useState(!!collapsedProp);
  const collapseContext = { collapsed, changeCollapsed };
  return import_react2.default.createElement(
    CollapseContext.Provider,
    { value: collapseContext },
    import_react2.default.createElement(View, Object.assign({}, rest))
  );
}
function ActivityLabel(props) {
  const collapseContext = import_react2.default.useContext(CollapseContext);
  const { collapsed } = collapseContext;
  const activityContentContext = import_react2.default.useContext(ActivityContentContext);
  const { infos } = activityContentContext;
  const [firstInfo] = infos;
  const labeledInfo = infos.find((info) => info.label) || { label: "" };
  const label = labeledInfo.label || firstInfo.type;
  const viewProps = Object.assign({}, props);
  if (collapsed)
    viewProps.children = label;
  else {
    const labels2 = [label, ...infos.map((info) => activityLabel(info))];
    viewProps.children = labels2.map((label2, i) => import_react2.default.createElement(View, { key: i, children: label2 }));
  }
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
var Problems = {
  child: "single child element expected"
};
function ActivityPicked(props) {
  const activityContext = import_react2.default.useContext(ActivityContext);
  const { id, children } = props;
  assertActivityGroup(id);
  const { picked } = activityContext;
  if (id !== picked)
    return null;
  const child = import_react2.default.Children.only(children);
  assertTrue(import_react2.default.isValidElement(child), Problems.child);
  return child;
}
function ActivityPicker(props) {
  const { id, className, children } = props, rest = __rest2(props, ["id", "className", "children"]);
  assertActivityGroup(id);
  const child = import_react2.default.Children.only(children);
  assertTrue(import_react2.default.isValidElement(child), Problems.child);
  const activityContext = import_react2.default.useContext(ActivityContext);
  const { picked, pick } = activityContext;
  const classes = [];
  if (className)
    classes.push(className);
  if (id === picked)
    classes.push(ClassSelected);
  const viewProps = Object.assign(Object.assign({}, rest), { className: classes.join(" "), key: `activity-picker-${id}`, onClick: () => pick(id) });
  return import_react2.default.cloneElement(child, viewProps);
}
function ActivityProgress(props) {
  const activityContext = import_react2.default.useContext(ActivityContext);
  const activityContentContext = import_react2.default.useContext(ActivityContentContext);
  const { infos, id } = activityContentContext;
  const elements = [];
  let totalSteps = 0;
  let totalStep = 0;
  if (isPopulatedArray(infos)) {
    const [info] = infos;
    const { step, steps } = info;
    if (isPositive(step) && isAboveZero(steps)) {
      totalStep = step;
      totalSteps = steps;
    }
  } else {
    const { allActivities, label } = activityContext;
    if (isPopulatedString(label)) {
      elements.push(import_react2.default.createElement("label", { key: "label" }, label));
    }
    const active = allActivities.filter((activityObject) => activityObject.activityGroup === ActivityGroup.Active);
    if (active.length) {
      active.forEach((activityObject) => {
        const { infos: infos2 } = activityObject;
        const [info] = infos2;
        assertObject(info);
        const { step, steps } = info;
        if (isPositive(steps))
          totalSteps += steps;
        if (isPositive(step))
          totalStep += step;
      });
    }
  }
  if (totalSteps) {
    const progress = totalStep / totalSteps;
    const progressProps = {
      value: progress,
      max: 1,
      children: `${Math.round(100 * progress)}%`,
      key: "progress"
    };
    elements.push(import_react2.default.createElement("progress", Object.assign({}, progressProps)));
  }
  const viewProps = Object.assign(Object.assign({}, props), { key: "activity-progress", children: elements });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
function Bar(props) {
  const { before, content, after, props: viewProps = {} } = props;
  if (!(before || content || after))
    return null;
  const children = [before, content, after].filter(Boolean);
  viewProps.children = children;
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
var panelOptionsStrict = (options) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j;
  options.header || (options.header = {});
  (_a = options.header).props || (_a.props = {});
  (_b = options.header.props).key || (_b.key = "header");
  (_c = options.header.props).className || (_c.className = "head");
  options.content || (options.content = {});
  (_d = options.content).props || (_d.props = {});
  (_e = options.content.props).key || (_e.key = "content");
  (_f = options.content.props).className || (_f.className = "content");
  options.footer || (options.footer = {});
  (_g = options.footer).props || (_g.props = {});
  (_h = options.footer.props).key || (_h.key = "footer");
  (_j = options.footer.props).className || (_j.className = "foot");
  options.props || (options.props = {});
  assertPopulatedObject(options.icons);
  return options;
};
function Panel(props) {
  const { children, className, collapsed: collapsedProp } = props;
  const [collapsed, changeCollapsed] = import_react2.default.useState(!!collapsedProp);
  const classes = [];
  if (className)
    classes.push(className);
  if (collapsed)
    classes.push("collapsed");
  const viewProps = { children, className: classes.join(" ") };
  const collapseContext = { collapsed, changeCollapsed };
  return import_react2.default.createElement(
    CollapseContext.Provider,
    { value: collapseContext },
    import_react2.default.createElement(View, Object.assign({}, viewProps))
  );
}
function PanelFoot(props) {
  const panelContext = import_react2.default.useContext(CollapseContext);
  const { collapsed } = panelContext;
  if (collapsed)
    return null;
  const { before, content, after, props: viewProps = {} } = props;
  if (!(before || content || after))
    return null;
  const children = [before, content, after].filter(Boolean);
  viewProps.children = children;
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
function CollapseControl(props) {
  const panelContext = import_react2.default.useContext(CollapseContext);
  const { collapsed, changeCollapsed: setCollapsed } = panelContext;
  const viewProps = Object.assign(Object.assign({}, props), { onClick: () => {
    setCollapsed(!collapsed);
  } });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
function NotCollapsed(props) {
  const panelContext = import_react2.default.useContext(CollapseContext);
  if (panelContext.collapsed)
    return null;
  return import_react2.default.createElement(import_react2.default.Fragment, null, props.children);
}
function Collapsed(props) {
  const panelContext = import_react2.default.useContext(CollapseContext);
  if (!panelContext.collapsed)
    return null;
  return import_react2.default.createElement(import_react2.default.Fragment, null, props.children);
}
var ActivityPropsDefault = function(props = {}) {
  var _a, _b, _c, _d, _e, _f;
  const optionsStrict = panelOptionsStrict(props);
  const { icons } = optionsStrict;
  (_a = optionsStrict.props).key || (_a.key = "activity");
  (_b = optionsStrict.props).className || (_b.className = "panel activity");
  (_c = optionsStrict.props).initialPicked || (_c.initialPicked = ActivityGroup.Active);
  if (isUndefined(optionsStrict.props.initialCollapsed))
    optionsStrict.props.initialCollapsed = true;
  (_d = optionsStrict.header).content || (_d.content = [
    icons.activity,
    import_react2.default.createElement(
      NotCollapsed,
      { key: "not-collapsed" },
      import_react2.default.createElement(View, { key: "view" })
    ),
    import_react2.default.createElement(
      Collapsed,
      { key: "collapsed" },
      import_react2.default.createElement(ActivityProgress, { key: "progress", className: "progress" })
    ),
    import_react2.default.createElement(
      CollapseControl,
      { key: "collapse-control" },
      import_react2.default.createElement(NotCollapsed, { key: "not-collapsed", children: icons.collapse }),
      import_react2.default.createElement(Collapsed, { key: "collapsed", children: icons.collapsed })
    )
  ]);
  (_e = optionsStrict.content).children || (_e.children = import_react2.default.createElement(
    ActivityItem,
    { className: "item", collapsed: true },
    import_react2.default.createElement(
      CollapseControl,
      { key: "collapse-control" },
      import_react2.default.createElement(NotCollapsed, { key: "not-collapsed", children: icons.collapse }),
      import_react2.default.createElement(Collapsed, { key: "collapsed", children: icons.collapsed })
    ),
    import_react2.default.createElement(ActivityLabel, { key: "label", className: "label" }),
    import_react2.default.createElement(
      ActivityPicked,
      { key: "active", id: "active" },
      import_react2.default.createElement(ActivityProgress, { key: "progress" })
    ),
    import_react2.default.createElement(ActivityPicked, { key: "error", id: "error", children: icons.error }),
    import_react2.default.createElement(ActivityPicked, { key: "complete", id: "complete", children: icons.complete })
  ));
  (_f = optionsStrict.footer).content || (_f.content = [
    import_react2.default.createElement(ActivityPicker, { key: "active", id: "active", className: ClassButton, children: icons.active }),
    import_react2.default.createElement(ActivityPicker, { key: "error", id: "error", className: ClassButton, children: icons.error }),
    import_react2.default.createElement(ActivityPicker, { key: "complete", id: "complete", className: ClassButton, children: icons.complete })
  ]);
  const children = import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement(Bar, Object.assign({}, optionsStrict.header)),
    import_react2.default.createElement(ActivityContent, Object.assign({}, optionsStrict.content.props), optionsStrict.content.children),
    import_react2.default.createElement(PanelFoot, Object.assign({}, optionsStrict.footer))
  );
  return Object.assign(Object.assign({}, optionsStrict.props), { children });
};
var ApiContextDefault = {
  enabled: false,
  servers: {},
  endpointPromise: () => Promise.resolve({})
};
var ApiContext = import_react2.default.createContext(ApiContextDefault);
function ApiClient(props) {
  const { endpoint: end, children, path } = props;
  const endpoint = end || urlEndpoint({ prefix: path || Endpoints.api.callbacks });
  const [callbacks, setCallbacks] = import_react2.default.useState(() => ({ [Endpoints.api.callbacks]: { endpoint } }));
  const [servers, setServers] = import_react2.default.useState(() => ({}));
  const endpointPromise = (id, body) => {
    return serverPromise(id).then((endpointResponse) => {
      if (isPopulatedObject(body)) {
        endpointResponse.request || (endpointResponse.request = {});
        endpointResponse.request.body = Object.assign({ version: ApiVersion }, body);
      }
      return fetchCallback(endpointResponse);
    });
  };
  const serverPromise = (id) => {
    const previousResponse = callbacks[id];
    if (previousResponse) {
      return Promise.resolve(previousResponse);
    }
    const request = { id, version: ApiVersion };
    const promiseCallback = {
      endpoint,
      request: { body: request }
    };
    return fetchCallback(promiseCallback).then((response) => {
      const { apiCallbacks } = response;
      setCallbacks((servers2) => Object.assign(Object.assign({}, servers2), apiCallbacks));
      return apiCallbacks[id];
    });
  };
  import_react2.default.useEffect(() => {
    const request = {};
    endpointPromise(Endpoints.api.servers, request).then((response) => {
      var _a;
      if ((_a = response.data) === null || _a === void 0 ? void 0 : _a.temporaryIdPrefix)
        idPrefixSet(response.data.temporaryIdPrefix);
      setServers(response);
    });
  }, []);
  const apiContext = {
    enabled: true,
    endpointPromise,
    servers
  };
  return import_react2.default.createElement(ApiContext.Provider, { value: apiContext }, children);
}
function ApiEnabled(props) {
  const apiContext = import_react2.default.useContext(ApiContext);
  const { enabled } = apiContext;
  if (!enabled)
    return null;
  return import_react2.default.createElement(import_react2.default.Fragment, null, props.children);
}
var ViewerContextDefault = {
  width: 0,
  height: 0,
  videoRate: 0,
  streaming: false,
  updating: false,
  preloading: false,
  setPreloading: () => {
  },
  setStreaming: () => {
  },
  setWidth: () => {
  },
  setHeight: () => {
  },
  setVideoRate: () => {
  },
  setUpdating: () => {
  },
  setId: () => {
  },
  id: "",
  setUrl: () => {
  },
  url: ""
};
var ViewerContext = import_react2.default.createContext(ViewerContextDefault);
function Broadcaster(props) {
  const [streaming, setStreaming] = import_react2.default.useState(false);
  const [preloading, setPreloading] = import_react2.default.useState(false);
  const [updating, setUpdating] = import_react2.default.useState(false);
  const [id, setId] = import_react2.default.useState("");
  const [url, setUrl] = import_react2.default.useState("");
  const [width, setWidth] = import_react2.default.useState(0);
  const [height, setHeight] = import_react2.default.useState(0);
  const [videoRate, setVideoRate] = import_react2.default.useState(0);
  const context = {
    updating,
    setUpdating,
    videoRate,
    setVideoRate,
    height,
    setHeight,
    width,
    setWidth,
    url,
    setUrl,
    streaming,
    setStreaming,
    preloading,
    setPreloading,
    id,
    setId
  };
  return import_react2.default.createElement(
    ViewerContext.Provider,
    { value: context },
    import_react2.default.createElement(View, Object.assign({}, props))
  );
}
var ProcessContextDefault = {
  error: "",
  processing: false,
  progress: 0,
  setError: () => {
  },
  setProcessing: () => {
  },
  setProgress: () => {
  },
  setStatus: () => {
  },
  status: ""
};
var ProcessContext = import_react2.default.createContext(ProcessContextDefault);
function BroadcasterControl(props) {
  const processContext = import_react2.default.useContext(ProcessContext);
  const apiContext = import_react2.default.useContext(ApiContext);
  const viewerContext = import_react2.default.useContext(ViewerContext);
  const { setProcessing, processing, setStatus } = processContext;
  const [disabled, setDisabled] = import_react2.default.useState(processing);
  const { endpointPromise } = apiContext;
  const { setStreaming, setId, setUrl, setWidth, setHeight, setVideoRate } = viewerContext;
  const startStreaming = () => {
    const request = {};
    console.debug("StreamingStartRequest", Endpoints.streaming.start, request);
    endpointPromise(Endpoints.streaming.start, request).then((response) => {
      console.debug("StreamingStartResponse", Endpoints.streaming.start, response);
      setStatus(`Started stream`);
      const { id, readySeconds, width, height, videoRate } = response;
      setId(id);
      setWidth(width);
      setHeight(height);
      setVideoRate(videoRate);
      const monitorStream = () => {
        setTimeout(() => {
          const request2 = { id };
          console.debug("StreamingStatusRequest", Endpoints.streaming.status, request2);
          endpointPromise(Endpoints.streaming.status, request2).then((response2) => {
            console.debug("StreamingStatusResponse", Endpoints.streaming.status, response2);
            const { streamUrl } = response2;
            if (streamUrl) {
              setUrl(streamUrl);
              setStreaming(true);
              setProcessing(true);
              setStatus(`Streaming`);
            } else
              monitorStream();
          });
        }, 1e3 * readySeconds);
      };
      monitorStream();
    });
  };
  const onClick = () => {
    if (disabled)
      return;
    setDisabled(true);
    startStreaming();
  };
  const viewProps = Object.assign(Object.assign({}, props), { onClick, disabled });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
var useEditor = () => import_react2.default.useContext(MasherContext).editor;
function BroadcasterContent(props) {
  const viewerContext = import_react2.default.useContext(ViewerContext);
  const editor = useEditor();
  const { rect } = editor;
  const { url, streaming } = viewerContext;
  if (!(streaming && url))
    return import_react2.default.createElement(View, Object.assign({}, props));
  const videoProps = Object.assign(Object.assign(Object.assign({}, sizeCopy(rect)), props), { autoPlay: true });
  return import_react2.default.createElement("video", Object.assign({ src: url }, videoProps));
}
function BroadcasterPreloadControl(props) {
  const processContext = import_react2.default.useContext(ProcessContext);
  const apiContext = import_react2.default.useContext(ApiContext);
  const viewerContext = import_react2.default.useContext(ViewerContext);
  const { id, setPreloading, preloading, updating, streaming } = viewerContext;
  const { setStatus } = processContext;
  const { endpointPromise } = apiContext;
  const preload = () => {
    const files = [];
    const request = { files, id };
    setStatus(`Preloading...`);
    console.debug("StreamingPreloadRequest", Endpoints.streaming.preload, request);
    endpointPromise(Endpoints.streaming.preload, request).then((response) => {
      console.debug("StreamingPreloadResponse", Endpoints.streaming.preload, response);
      setStatus(`Preloaded`);
      setPreloading(false);
    });
  };
  const disabled = preloading || updating || !streaming;
  const onClick = () => {
    if (disabled)
      return;
    setPreloading(true);
    preload();
  };
  const viewProps = Object.assign(Object.assign({}, props), { onClick, disabled });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
function BroadcasterUpdateControl(props) {
  const editor = useEditor();
  const processContext = import_react2.default.useContext(ProcessContext);
  const apiContext = import_react2.default.useContext(ApiContext);
  const viewerContext = import_react2.default.useContext(ViewerContext);
  const { updating, setUpdating, streaming, preloading, id } = viewerContext;
  const { setStatus } = processContext;
  const { endpointPromise } = apiContext;
  const update = () => {
    const { edited, definitions } = editor;
    assertCast(edited);
    const { mashes } = edited;
    const definitionObjects = definitions.map((definition) => definition.toJSON());
    const mashObjects = mashes.map((mash) => mash.toJSON());
    const request = { definitionObjects, mashObjects, id };
    console.debug("StreamingCutRequest", Endpoints.streaming.cut, request);
    setStatus(`Updating stream`);
    endpointPromise(Endpoints.streaming.cut, request).then((response) => {
      console.debug("StreamingCutResponse", Endpoints.streaming.cut, response);
      setStatus(`Updated stream`);
      setUpdating(false);
    });
  };
  const disabled = updating || preloading || !streaming;
  const onClick = () => {
    if (disabled)
      return;
    setUpdating(true);
    update();
  };
  const viewProps = Object.assign(Object.assign({}, props), { onClick, disabled });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
var BrowserContextDefault = {
  addPicker: EmptyMethod,
  definitions: [],
  pick: EmptyMethod,
  picked: "",
  removePicker: EmptyMethod
};
var BrowserContext = import_react2.default.createContext(BrowserContextDefault);
var EditorDefinitionsEventAdded = EventType.Added;
var EditorDefinitionsEventResize = EventType.Resize;
var useEditorDefinitions = (types = []) => {
  const masherContext = import_react2.default.useContext(MasherContext);
  const { editor } = masherContext;
  assertDefined(editor);
  const storeRef = import_react2.default.useRef({});
  const { eventTarget } = editor;
  const snapshotInitialize = () => {
    const lists = types.map((type) => Defined.byType(type));
    return lists.length === 1 ? lists[0] : lists.flat();
  };
  const snapshotGet = () => {
    var _a;
    const key = types.join("-") || "empty";
    return (_a = storeRef.current)[key] || (_a[key] = snapshotInitialize());
  };
  const handleEvent = (event) => {
    const { type } = event;
    if (isEventType(type) && event instanceof CustomEvent) {
      const { detail } = event;
      const { definitionTypes } = detail;
      if (isPopulatedArray(definitionTypes)) {
        const types2 = definitionTypes;
        const { current } = storeRef;
        const allIds = Object.keys(current);
        const ids = allIds.filter((id) => types2.some((type2) => id.includes(type2)));
        ids.forEach((id) => delete current[id]);
      }
    }
  };
  const externalStore = import_react2.default.useSyncExternalStore((callback) => {
    eventTarget.addEventListener(EditorDefinitionsEventAdded, callback);
    eventTarget.addEventListener(EditorDefinitionsEventResize, callback);
    return () => {
      eventTarget.removeEventListener(EditorDefinitionsEventAdded, callback);
      eventTarget.removeEventListener(EditorDefinitionsEventResize, callback);
    };
  }, snapshotGet);
  const removeListener = () => {
    eventTarget.removeEventListener(EditorDefinitionsEventAdded, handleEvent);
  };
  const addListener = () => {
    eventTarget.addEventListener(EditorDefinitionsEventAdded, handleEvent);
    return () => {
      removeListener();
    };
  };
  import_react2.default.useEffect(() => addListener(), []);
  return [editor, externalStore];
};
var ApiDefinitionsEvent = "api-definitions";
var ApiDefinitionsDisabled = "disabled";
var ApiDefinitionsEmpty = "empty";
var useApiDefinitions = (types = []) => {
  const apiContext = import_react2.default.useContext(ApiContext);
  const masherContext = import_react2.default.useContext(MasherContext);
  const { enabled, servers, endpointPromise } = apiContext;
  const { editor } = masherContext;
  assertDefined(editor);
  const storeRef = import_react2.default.useRef({});
  const { eventTarget } = editor;
  const definitionsPromise = (key) => {
    const request = { types };
    console.debug("DataDefinitionRetrieveRequest", Endpoints.data.definition.retrieve, request);
    return endpointPromise(Endpoints.data.definition.retrieve, request).then((response) => {
      console.debug("DataDefinitionRetrieveResponse", Endpoints.data.definition.retrieve, response);
      const { definitions } = response;
      const array = storeRef.current[key];
      array.push(...definitions.map((def) => DefinitionBase.fromObject(def)));
      eventTarget.dispatchEvent(new CustomEvent(ApiDefinitionsEvent));
    });
  };
  const snapshotInitialize = (key) => {
    switch (key) {
      case ApiDefinitionsEmpty:
      case ApiDefinitionsDisabled:
        break;
      default:
        definitionsPromise(key);
    }
    return [];
  };
  const currentKey = () => {
    if (!(enabled && servers[ServerType.Data]))
      return ApiDefinitionsDisabled;
    if (!types.length)
      return ApiDefinitionsEmpty;
    return types.join("-");
  };
  const snapshotGet = () => {
    const key = currentKey();
    const array = storeRef.current[key];
    if (array)
      return array;
    return storeRef.current[key] = snapshotInitialize(key);
  };
  const externalStore = import_react2.default.useSyncExternalStore((callback) => {
    eventTarget.addEventListener(ApiDefinitionsEvent, callback);
    return () => {
      eventTarget.removeEventListener(ApiDefinitionsEvent, callback);
    };
  }, snapshotGet);
  return [editor, externalStore];
};
var useDefinitions = (types = []) => {
  const [editor, editorDefinitions] = useEditorDefinitions(types);
  const [_, apiDefinitions] = useApiDefinitions(types);
  const definitions = apiDefinitions.filter((apiDefinition) => !editorDefinitions.some((editorDefinition) => editorDefinition.id === apiDefinition.id));
  const combined = [...editorDefinitions, ...definitions];
  return [editor, combined];
};
function Browser(props) {
  const { initialPicked = "container" } = props, rest = __rest2(props, ["initialPicked"]);
  const [typesObject, setTypesObject] = import_react2.default.useState({});
  const editorContext = import_react2.default.useContext(MasherContext);
  const { changeDefinition } = editorContext;
  const [picked, setPicked] = import_react2.default.useState(initialPicked);
  const pick = (id) => {
    assertPopulatedString(id);
    changeDefinition();
    setPicked(id);
  };
  const [_, definitions] = useDefinitions(typesObject[picked]);
  const addPicker = (id, types) => {
    setTypesObject((original) => Object.assign(Object.assign({}, original), { [id]: types }));
  };
  const removePicker = (id) => {
    setTypesObject((original) => Object.assign(Object.assign({}, original), { [id]: [] }));
  };
  const browserContext = {
    definitions,
    picked,
    pick,
    addPicker,
    removePicker
  };
  const contextProps = {
    value: browserContext,
    children: import_react2.default.createElement(View, Object.assign({}, rest))
  };
  return import_react2.default.createElement(BrowserContext.Provider, Object.assign({}, contextProps));
}
var DefinitionContextDefault = {};
var DefinitionContext = import_react2.default.createContext(DefinitionContextDefault);
var DragSuffix = "/x-moviemasher";
var isDragOffsetObject = (value) => {
  return isObject(value) && "offset" in value;
};
function assertDragOffsetObject(value) {
  if (!isDragOffsetObject(value))
    throwError(value, "DragOffsetObject");
}
var isDragDefinitionObject = (value) => {
  return isDragOffsetObject(value) && "definitionObject" in value;
};
function assertDragDefinitionObject(value) {
  if (!isDragDefinitionObject(value))
    throwError(value, "DragDefinitionObject");
}
var DragType;
(function(DragType2) {
  DragType2["Mash"] = "mash";
  DragType2["Layer"] = "layer";
  DragType2["Track"] = "track";
})(DragType || (DragType = {}));
var DragTypes = Object.values(DragType);
var isDragType = (value) => isString(value) && DragTypes.includes(value);
var TransferTypeFiles = "Files";
var isTransferType = (value) => {
  return isString(value) && value.endsWith(DragSuffix);
};
var dropType = (dataTransfer) => {
  if (!dataTransfer)
    return;
  return dataTransfer.types.find(isTransferType);
};
var dragDefinitionType = (transferType) => {
  const [type] = transferType.split("/");
  assertDefinitionType(type);
  return type;
};
var dragType = (dataTransfer) => {
  const prefix = dropType(dataTransfer);
  if (!prefix)
    return;
  const [type] = prefix.split("/");
  if (isDragType(type) || isDefinitionType(type))
    return type;
};
var dragTypes = (dataTransfer) => {
  const { types } = dataTransfer;
  return types.filter((type) => type === TransferTypeFiles || isTransferType(type));
};
var dragData = (dataTransfer, type) => {
  const transferType = type ? `${type}${DragSuffix}` : dragTypes(dataTransfer).find(isTransferType);
  if (!transferType)
    return {};
  const json = dataTransfer.getData(transferType);
  const data = json ? JSON.parse(json) : {};
  return data;
};
var DragElementRect = (current) => current.getBoundingClientRect();
var DragElementPoint = (event, current) => {
  const rect = current instanceof Element ? DragElementRect(current) : current;
  const { x, y } = rect;
  const { clientY, clientX } = event;
  return { x: clientX - x, y: clientY - y };
};
var dropFilesFromList = (files, serverOptions = {}) => {
  const infos = [];
  const { length } = files;
  if (!length)
    return infos;
  const exists = isPopulatedObject(serverOptions);
  const { extensions = {}, uploadLimits = {} } = serverOptions;
  const extensionsByType = extensions;
  const limitsByType = uploadLimits;
  for (let i = 0; i < length; i++) {
    const file = files.item(i);
    if (!file)
      continue;
    const { name, size, type } = file;
    const coreType = type.split("/").shift();
    if (!isUploadType(coreType)) {
      infos.push({ label: name, value: coreType, error: "import.type" });
      continue;
    }
    const max = limitsByType[coreType];
    if (exists && !(isAboveZero(max) && max * 1024 * 1024 > size)) {
      infos.push({ label: name, value: `${max}MB`, error: "import.bytes" });
      continue;
    }
    const ext = name.toLowerCase().split(".").pop();
    const extDefined = isPopulatedString(ext);
    const exts = extensionsByType[coreType];
    if (exists || !extDefined) {
      if (!(extDefined && isArray(exts) && exts.includes(ext))) {
        infos.push({ label: name, value: ext, error: "import.extension" });
        continue;
      }
    }
    infos.push(file);
  }
  return infos;
};
var droppingPositionClass = (droppingPosition) => {
  if (isUndefined(droppingPosition))
    return "";
  switch (droppingPosition) {
    case DroppingPosition.After:
      return ClassDroppingAfter;
    case DroppingPosition.Before:
      return ClassDroppingBefore;
    case DroppingPosition.None:
      return "";
  }
  return ClassDropping;
};
function BrowserContent(props) {
  const [over, setOver] = import_react2.default.useState(false);
  const { className, children } = props, rest = __rest2(props, ["className", "children"]);
  const editorContext = import_react2.default.useContext(MasherContext);
  const browserContext = import_react2.default.useContext(BrowserContext);
  const definitions = browserContext.definitions || [];
  const { drop } = editorContext;
  const dragValid = (dataTransfer) => {
    if (!dataTransfer)
      return false;
    return dragTypes(dataTransfer).includes(TransferTypeFiles);
  };
  const onDrop = (event) => {
    onDragLeave(event);
    const { dataTransfer } = event;
    if (dragValid(dataTransfer))
      drop(dataTransfer.files);
  };
  const onDragOver = (event) => {
    eventStop(event);
    setOver(dragValid(event.dataTransfer));
  };
  const onDragLeave = (event) => {
    eventStop(event);
    setOver(false);
  };
  const classes = [];
  if (className)
    classes.push(className);
  if (over)
    classes.push(ClassDropping);
  const child = import_react2.default.Children.only(children);
  assertTrue(import_react2.default.isValidElement(child));
  const childNodes = () => {
    const childProps = child.props;
    return definitions.map((definition) => {
      const cloneProps = Object.assign(Object.assign({}, childProps), { key: definition.id });
      const children2 = import_react2.default.cloneElement(child, cloneProps);
      const contextProps = { children: children2, value: { definition }, key: definition.id };
      const context = import_react2.default.createElement(DefinitionContext.Provider, Object.assign({}, contextProps));
      return context;
    });
  };
  const viewProps = Object.assign(Object.assign({}, rest), { className: classes.join(" "), key: `browser-content`, children: childNodes(), onDrop, onDragOver, onDragLeave });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
var propsStringArray = (string, array, properties) => {
  if (string)
    return [string];
  if (!array)
    return properties ? properties.map((property) => property.name) : [];
  if (isString(array))
    return array.split(",").map((string2) => string2.trim());
  return array;
};
var propsDefinitionTypes = (type, types, id) => {
  const strings = propsStringArray(type, types);
  if (id && !strings.length)
    strings.push(id);
  const validStrings = strings.filter((string) => isDefinitionType(string));
  return validStrings.map((string) => string);
};
var propsSelectTypes = (type, types, id) => {
  const strings = propsStringArray(type, types);
  if (id && !strings.length)
    strings.push(id);
  const validStrings = strings.filter((string) => isSelectType(string));
  return validStrings.map((string) => string);
};
function BrowserPicker(props) {
  const { children, type, types, className, id } = props, rest = __rest2(props, ["children", "type", "types", "className", "id"]);
  assertPopulatedString(id);
  const browserContext = import_react2.default.useContext(BrowserContext);
  const { pick, picked, addPicker, removePicker } = browserContext;
  const classes = [];
  if (className)
    classes.push(className);
  if (picked === id)
    classes.push(ClassSelected);
  import_react2.default.useEffect(() => {
    addPicker(id, propsDefinitionTypes(type, types, id));
    return () => {
      removePicker(id);
    };
  }, []);
  const viewProps = Object.assign(Object.assign({}, rest), { className: classes.join(" "), key: `browser-picker-${id}`, onClick: () => {
    pick(id);
  } });
  const child = import_react2.default.Children.only(children);
  assertTrue(import_react2.default.isValidElement(child), Problems.child);
  return import_react2.default.cloneElement(child, viewProps);
}
var BrowserControlId = "upload-control-id";
function BrowserControl(props) {
  const { children } = props, rest = __rest2(props, ["children"]);
  const fileInput = import_react2.default.useRef(null);
  const apiContext = import_react2.default.useContext(ApiContext);
  const editorContext = import_react2.default.useContext(MasherContext);
  const { servers } = apiContext;
  const { drop } = editorContext;
  const onChange = (event) => {
    const { files } = event.currentTarget;
    if (files)
      drop(files);
  };
  const { file = {} } = servers;
  const { extensions = Object.fromEntries(UploadTypes.map((type) => [type, []])) } = file;
  assertObject(extensions);
  const accept = Object.entries(extensions).flatMap(([uploadType, noDots]) => {
    return [`${uploadType}/*`, ...noDots.map((noDot) => `.${noDot}`)];
  }).join(",");
  const inputProps = Object.assign({ accept, id: BrowserControlId, onChange, type: "file", key: "browser-control-input", ref: fileInput }, rest);
  const input = import_react2.default.createElement("input", Object.assign({}, inputProps));
  if (!import_react2.default.isValidElement(children))
    return input;
  const kids = [import_react2.default.Children.only(children), input];
  const labelProps = {
    children: kids,
    key: "browser-control",
    htmlFor: BrowserControlId
  };
  return import_react2.default.createElement("label", Object.assign({}, labelProps));
}
var useDefinition = () => import_react2.default.useContext(DefinitionContext).definition;
function DefinitionItem(props) {
  const { className, iconRatio } = props, rest = __rest2(props, ["className", "iconRatio"]);
  const ratio = iconRatio || 0.25;
  const svgRef = import_react2.default.useRef(null);
  const viewRef = import_react2.default.useRef(null);
  const editorContext = import_react2.default.useContext(MasherContext);
  const { editor, definition: selectedDefinition, changeDefinition } = editorContext;
  assertTrue(editor);
  const definition = useDefinition();
  const { id, label, type } = definition;
  const updateRef = () => __awaiter(this, void 0, void 0, function* () {
    const { rect, preloader } = editor;
    const { current } = svgRef;
    if (!(current && sizeAboveZero(rect)))
      return;
    const scaled = sizeCeil(sizeScale(sizeCopy(rect), ratio, ratio));
    const element = yield definition.definitionIcon(preloader, scaled);
    if (element)
      current.replaceChildren(element);
  });
  import_react2.default.useEffect(() => {
    updateRef();
  }, []);
  if (svgRef.current)
    updateRef();
  const childNodes = () => {
    const nodes = [import_react2.default.createElement(View, { key: "icon", ref: svgRef })];
    if (label)
      nodes.unshift(import_react2.default.createElement("label", { key: "label" }, label));
    return nodes;
  };
  const onPointerDown = (event) => {
    event.stopPropagation();
    changeDefinition(definition);
  };
  const onDragStart = (event) => {
    onPointerDown(event);
    const rect = viewRef.current.getBoundingClientRect();
    const { left } = rect;
    const { clientX } = event;
    const data = { offset: clientX - left, definitionObject: definition };
    const json = JSON.stringify(data);
    const { dataTransfer } = event;
    if (!dataTransfer)
      return;
    dataTransfer.effectAllowed = "copy";
    dataTransfer.setData(definition.type + DragSuffix, json);
  };
  const calculateClassName = () => {
    const classes = [];
    if (className)
      classes.push(className);
    if ((selectedDefinition === null || selectedDefinition === void 0 ? void 0 : selectedDefinition.id) === id)
      classes.push(ClassSelected);
    return classes.join(" ");
  };
  const viewProps = Object.assign(Object.assign({}, rest), { className, children: childNodes(), ref: viewRef, key: id });
  if (props.draggable) {
    viewProps.onDragStart = onDragStart;
    viewProps.onPointerDown = onPointerDown;
    viewProps.className = calculateClassName();
  }
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
var BrowserPropsDefault = function(props = {}) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const optionsStrict = panelOptionsStrict(props);
  const { icons } = optionsStrict;
  (_a = optionsStrict.props).key || (_a.key = "browser");
  (_b = optionsStrict.props).className || (_b.className = "panel browser");
  (_c = optionsStrict.props).initialPicked || (_c.initialPicked = "container");
  (_d = optionsStrict.header).content || (_d.content = [icons.browser]);
  (_e = optionsStrict.footer).content || (_e.content = [
    import_react2.default.createElement(BrowserPicker, { key: "effect", id: "effect", className: ClassButton, children: icons.browserEffect }),
    import_react2.default.createElement(BrowserPicker, { key: "container", id: "container", className: ClassButton, children: icons.container }),
    import_react2.default.createElement(BrowserPicker, { key: "content", id: "content", className: ClassButton, children: icons.content })
  ]);
  (_f = optionsStrict.footer).before || (_f.before = [
    import_react2.default.createElement(BrowserPicker, { key: "video", id: "video", types: "video,videosequence", className: ClassButton, children: icons.browserVideo }),
    import_react2.default.createElement(BrowserPicker, { key: "audio", id: "audio", className: ClassButton, children: icons.browserAudio }),
    import_react2.default.createElement(BrowserPicker, { key: "image", id: "image", className: ClassButton, children: icons.browserImage })
  ]);
  (_g = optionsStrict.footer).after || (_g.after = [
    import_react2.default.createElement(BrowserControl, { key: "import", children: icons.import })
  ]);
  (_h = optionsStrict.content).children || (_h.children = import_react2.default.createElement(DefinitionItem, { draggable: true, className: "definition preview" }));
  const children = import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement(Bar, Object.assign({}, optionsStrict.header)),
    import_react2.default.createElement(BrowserContent, Object.assign({}, optionsStrict.content.props), optionsStrict.content.children),
    import_react2.default.createElement(Bar, Object.assign({}, optionsStrict.footer))
  );
  return Object.assign(Object.assign({}, optionsStrict.props), { children });
};
var ClipContextDefault = {
  prevClipEnd: 0
};
var ClipContext = import_react2.default.createContext(ClipContextDefault);
var TrackContextDefault = {};
var TrackContext = import_react2.default.createContext(TrackContextDefault);
var TimelineContextDefault = {
  dragTypeValid() {
    return false;
  },
  frame: 0,
  frames: 0,
  onDragLeave: EmptyMethod,
  onDrop: EmptyMethod,
  rect: RectZero,
  refreshed: 0,
  refresh: EmptyMethod,
  scale: 0,
  scroll: { x: 0, y: 0 },
  setDroppingClip: EmptyMethod,
  setDroppingPosition: EmptyMethod,
  setDroppingTrack: EmptyMethod,
  setRect: EmptyMethod,
  setScroll: EmptyMethod,
  setZoom: EmptyMethod,
  zoom: 1
};
var TimelineContext = import_react2.default.createContext(TimelineContextDefault);
var LayerContextDefault = { depth: 0 };
var LayerContext = import_react2.default.createContext(LayerContextDefault);
var useLayer = () => import_react2.default.useContext(LayerContext).layer;
var useListeners = (events, target) => {
  const masherContext = import_react2.default.useContext(MasherContext);
  const { editor } = masherContext;
  const eventTarget = target || editor.eventTarget;
  const handleEvent = (event) => {
    const { type } = event;
    const handler = events[type];
    if (handler)
      handler(event);
  };
  const removeListeners = () => {
    const keys = Object.keys(events);
    keys.forEach((eventType) => {
      eventTarget.removeEventListener(eventType, handleEvent);
    });
  };
  const addListeners = () => {
    Object.keys(events).forEach((eventType) => {
      eventTarget.addEventListener(eventType, handleEvent);
    });
    return () => {
      removeListeners();
    };
  };
  import_react2.default.useEffect(() => addListeners(), []);
};
var ClipItemRefreshRate = 500;
function ClipItem(props) {
  const { className } = props, rest = __rest2(props, ["className"]);
  const svgRef = import_react2.default.useRef(null);
  const viewRef = import_react2.default.useRef(null);
  const editor = useEditor();
  const trackContext = import_react2.default.useContext(TrackContext);
  const timelineContext = import_react2.default.useContext(TimelineContext);
  const [nonce, setNonce] = import_react2.default.useState(0);
  const updateNonce = () => {
    setNonce((/* @__PURE__ */ new Date()).valueOf());
  };
  const watchingRef = import_react2.default.useRef({});
  const { current: watching } = watchingRef;
  const clipContext = import_react2.default.useContext(ClipContext);
  const { droppingPosition, droppingClip, scale, selectedClip, onDrop, dragTypeValid, setDroppingPosition, setDroppingClip, setDroppingTrack, onDragLeave } = timelineContext;
  const { track } = trackContext;
  const { clip, prevClipEnd } = clipContext;
  assertTrue(clip);
  const backgroundNode = (fill, size, spacing) => {
    const rgb = colorToRgb(fill);
    const differenceRgb = colorRgbDifference(rgb);
    const forecolor = colorFromRgb(differenceRgb);
    const framePolygon = svgPolygonElement(size, "", fill);
    const spaceRect = {
      x: size.width,
      y: 0,
      width: spacing,
      height: size.height
    };
    const spacePolygon = svgPolygonElement(spaceRect, "", forecolor);
    const patternSize = {
      width: size.width + spacing,
      height: size.height
    };
    const patternId = idGenerate("pattern");
    const patternItems = [framePolygon, spacePolygon];
    const pattern = svgPatternElement(patternSize, patternId, patternItems);
    const defsElement = svgDefsElement([pattern]);
    const patternedSize = { width: timelineContext.rect.width, height: parentHeight };
    const patternedPolygon = svgPolygonElement(patternedSize, "", svgUrl(patternId));
    return svgElement(patternedSize, [defsElement, patternedPolygon]);
  };
  const getParentHeight = () => {
    const { current } = svgRef;
    const parent = current === null || current === void 0 ? void 0 : current.parentNode;
    if (parent instanceof HTMLDivElement) {
      return parent.offsetHeight;
    }
    return 0;
  };
  const [parentHeight, setParentHeight] = import_react2.default.useState(getParentHeight);
  const { label, type, frame, frames } = clip;
  const getCurrentWidth = () => {
    if (!(isAboveZero(scale) && isAboveZero(frames))) {
      return 0;
    }
    const currentWidth2 = pixelFromFrame(frames, scale, "floor");
    const { width } = watching;
    if (currentWidth2 && currentWidth2 !== width) {
      watching.width = currentWidth2;
      updateNonce();
    }
    return currentWidth2;
  };
  const currentWidth = getCurrentWidth();
  const actionCallback = (event) => {
    if (watching.redraw)
      return;
    const { type: type2 } = event;
    if (!isEventType(type2))
      return;
    if (!(event instanceof CustomEvent))
      return;
    if (type2 !== EventType.Action)
      return;
    const { detail } = event;
    if (!detail)
      return;
    const { action } = detail;
    if (!action)
      return;
    const { target } = action;
    if (!isObject(target))
      return;
    switch (target) {
      case clip:
      case clip.container:
      case clip.content:
        break;
      default: {
        if (action.property === "color")
          break;
        return;
      }
    }
    updateNonce();
  };
  useListeners({ [EventType.Action]: actionCallback, [EventType.Save]: updateNonce });
  const frameSize = () => {
    const { rect } = editor;
    const size = {
      width: parentHeight * (rect.width / rect.height),
      height: parentHeight
    };
    return sizeCeil(size);
  };
  const clipSize = (size) => {
    const { width, height } = size;
    return { width: Math.max(width, currentWidth), height };
  };
  const populateSvg = () => {
    const { width, redraw } = watching;
    delete watching.timeout;
    delete watching.redraw;
    const { current } = svgRef;
    const { edited } = editor;
    const allOk = current && edited && width && width === getCurrentWidth();
    if (redraw || !allOk) {
      updateNonce();
      if (!allOk)
        return Promise.resolve();
    }
    const currentSize = frameSize();
    const fullSize = clipSize(currentSize);
    const promise = clip.clipIcon(fullSize, timelineContext.scale, 2);
    if (!promise)
      return Promise.resolve();
    return promise.then((element) => {
      const latestWidth = getCurrentWidth();
      if (element && width >= latestWidth) {
        current.replaceChildren(backgroundNode(edited.color, currentSize, 2), element);
      }
    });
  };
  const handleChange = () => {
    if (!parentHeight) {
      return setParentHeight(getParentHeight);
    }
    const { current } = svgRef;
    const { edited } = editor;
    if (!(current && edited))
      return;
    if (watching.timeout) {
      if (!watching.redraw) {
        watching.redraw = true;
      }
      return;
    }
    watching.timeout = setTimeout(populateSvg, ClipItemRefreshRate);
  };
  import_react2.default.useEffect(handleChange, [nonce, scale, parentHeight]);
  const onPointerDown = (event) => {
    event.stopPropagation();
    editor.selection.set(clip);
  };
  const onDragEnd = (event) => {
    eventStop(event);
    const { dataTransfer } = event;
    if (!dataTransfer)
      return;
    const { dropEffect } = dataTransfer;
    if (dropEffect === "none") {
      editor.removeClip(clip);
    }
  };
  const onDragStart = (event) => {
    onPointerDown(event);
    const { dataTransfer, clientX } = event;
    const { current } = viewRef;
    if (!(dataTransfer && current))
      return;
    const rect = current.getBoundingClientRect();
    const { left } = rect;
    const data = { offset: clientX - left };
    const json = JSON.stringify(data);
    dataTransfer.effectAllowed = "move";
    dataTransfer.setData(type + DragSuffix, json);
  };
  const onDragOver = (event) => {
    eventStop(event);
    const { dataTransfer } = event;
    if (!dataTransfer)
      return;
    const definitionType = dragTypeValid(dataTransfer, clip);
    const pos = definitionType ? DroppingPosition.At : DroppingPosition.None;
    setDroppingTrack(definitionType ? track : void 0);
    setDroppingClip(definitionType ? clip : void 0);
    setDroppingPosition(pos);
  };
  const calculateClassName = () => {
    const selected = clip === selectedClip;
    const classes = [];
    if (className)
      classes.push(className);
    if (selected)
      classes.push(ClassSelected);
    if (droppingClip === clip)
      classes.push(droppingPositionClass(droppingPosition));
    return classes.join(" ");
  };
  const childNodes = () => {
    const svgProps = {
      key: "clip-previews",
      ref: svgRef
    };
    const size = { width: currentWidth, height: parentHeight };
    if (sizeAboveZero(size)) {
      const { width, height } = size;
      svgProps.width = width;
      svgProps.height = height;
      svgProps.viewBox = `0 0 ${width} ${height}`;
    }
    const nodes = [import_react2.default.createElement("svg", Object.assign({}, svgProps))];
    if (label)
      nodes.unshift(import_react2.default.createElement("label", { key: "label" }, label));
    return nodes;
  };
  const style = { width: currentWidth };
  if (prevClipEnd > -1) {
    style.marginLeft = pixelFromFrame(frame - prevClipEnd, scale, "floor");
  }
  const clipProps = Object.assign(Object.assign({}, rest), {
    style,
    className: calculateClassName(),
    onPointerDown,
    onDragStart,
    onDragEnd,
    onDragOver,
    onDragLeave,
    onDrop,
    onClick: (event) => event.stopPropagation(),
    draggable: true,
    ref: viewRef,
    children: childNodes()
  });
  return import_react2.default.createElement(View, Object.assign({}, clipProps));
}
var useClip = () => import_react2.default.useContext(ClipContext).clip;
var ComposerContextDefault = {
  refreshed: 0,
  refresh: EmptyMethod,
  validDragType: () => {
    return void 0;
  },
  droppingPosition: DroppingPosition.None,
  setDroppingPosition: EmptyMethod,
  onDrop: EmptyMethod,
  setDroppingLayer: EmptyMethod,
  onDragLeave: EmptyMethod
};
var ComposerContext = import_react2.default.createContext(ComposerContextDefault);
function Composer(props) {
  const editorContext = import_react2.default.useContext(MasherContext);
  const [selectedLayer, setSelectedLayer] = import_react2.default.useState(void 0);
  const [droppingLayer, setDroppingLayer] = import_react2.default.useState(void 0);
  const [refreshed, setRefreshed] = import_react2.default.useState(0);
  const [droppingPosition, setDroppingPosition] = import_react2.default.useState(DroppingPosition.None);
  const { editor, draggable, drop } = editorContext;
  const refresh = () => {
    setRefreshed((value) => value + 1);
  };
  const handleSelection = () => {
    setSelectedLayer(editor.selection.layer);
  };
  useListeners({
    [EventType.Selection]: handleSelection,
    [EventType.Cast]: refresh
  });
  if (!editor)
    return null;
  const validDragType = (dataTransfer) => {
    if (!dataTransfer)
      return;
    const type = dragType(dataTransfer);
    if (!isDragType(type))
      return;
    if ([DragType.Mash, DragType.Layer].includes(type))
      return type;
  };
  const onDragLeave = () => {
    setDroppingPosition(DroppingPosition.None);
    setDroppingLayer(void 0);
  };
  const onDrop = (event) => {
    event.preventDefault();
    setDroppingPosition(DroppingPosition.None);
    refresh();
    const { dataTransfer } = event;
    assertObject(dataTransfer);
    const types = dragTypes(dataTransfer);
    if (types.includes(TransferTypeFiles)) {
      const editorIndex = {};
      drop(dataTransfer.files, editorIndex);
      return;
    }
    const dragType2 = validDragType(dataTransfer);
    if (!dragType2)
      return;
    const layerAndPosition = {
      layer: droppingLayer,
      position: droppingPosition
    };
    switch (dragType2) {
      case DragType.Layer: {
        if (isLayer(draggable))
          editor.moveLayer(draggable, layerAndPosition);
        break;
      }
      case DragType.Mash: {
        const mashAndDefinitions = {
          mashObject: {},
          definitionObjects: []
        };
        editor.addMash(mashAndDefinitions, layerAndPosition);
        break;
      }
      default: {
        if (draggable)
          drop(draggable);
      }
    }
  };
  const composerContext = {
    refreshed,
    refresh,
    selectedLayer,
    validDragType,
    droppingPosition,
    setDroppingPosition,
    onDrop,
    droppingLayer,
    setDroppingLayer,
    onDragLeave
  };
  const contextProps = {
    children: import_react2.default.createElement(View, Object.assign({}, props)),
    value: composerContext
  };
  return import_react2.default.createElement(ComposerContext.Provider, Object.assign({}, contextProps));
}
function ComposerLayer(props) {
  const ref = import_react2.default.useRef(null);
  import_react2.default.useContext(MasherContext);
  const composerContext = import_react2.default.useContext(ComposerContext);
  const layerContext = import_react2.default.useContext(LayerContext);
  const { validDragType, droppingPosition, setDroppingPosition, onDrop, droppingLayer, setDroppingLayer, onDragLeave } = composerContext;
  const editor = useEditor();
  const { layer } = layerContext;
  if (!layer)
    return null;
  const { className: propsClassName = "layer" } = props, rest = __rest2(props, ["className"]);
  const onClick = (event) => {
    event.stopPropagation();
    editor.selection.set(layer);
  };
  const onDragEnd = (event) => {
    const { dataTransfer } = event;
    if (!dataTransfer)
      return;
    const { dropEffect } = dataTransfer;
    if (dropEffect === "none")
      editor.removeLayer(layer);
  };
  const onPointerDown = (event) => {
    event.stopPropagation();
    editor.selection.set(layer);
  };
  const onDragStart = (event) => {
    const point = DragElementPoint(event, ref.current);
    onPointerDown(event);
    const { dataTransfer } = event;
    if (!isObject(dataTransfer))
      return;
    dataTransfer.effectAllowed = "move";
    dataTransfer.setData(`layer${DragSuffix}`, JSON.stringify(point));
  };
  const currentDroppingPosition = (event) => {
    const { dataTransfer } = event;
    const { current } = ref;
    if (!(current && validDragType(dataTransfer)))
      return DroppingPosition.None;
    const rect = DragElementRect(ref.current);
    const point = DragElementPoint(event, rect);
    const quarterHeight = Math.ceil(rect.height / 4);
    const folder = isLayerFolder(layer);
    if (point.y < quarterHeight * (folder ? 1 : 2))
      return DroppingPosition.Before;
    if (!folder || point.y > quarterHeight * 3)
      return DroppingPosition.After;
    return DroppingPosition.At;
  };
  const onDragOver = (event) => {
    const position = currentDroppingPosition(event);
    setDroppingPosition(position);
    setDroppingLayer(layer);
    eventStop(event);
  };
  const calculatedClassName = () => {
    const selected = layer === editor.selection.layer;
    const classes = [propsClassName];
    if (selected)
      classes.push(ClassSelected);
    if (droppingLayer === layer) {
      classes.push(droppingPositionClass(droppingPosition));
    }
    return classes.join(" ");
  };
  const className = import_react2.default.useMemo(calculatedClassName, [droppingPosition, droppingLayer, editor.selection.layer]);
  const viewProps = Object.assign(Object.assign({}, rest), {
    className,
    ref,
    onMouseDown: onPointerDown,
    onDragStart,
    onDragEnd,
    onClick,
    onDragLeave,
    onDragOver,
    onDrop,
    draggable: true
  });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
function ComposerContent(props) {
  const composerContext = import_react2.default.useContext(ComposerContext);
  const { droppingLayer, setDroppingLayer, droppingPosition, setDroppingPosition, onDrop, onDragLeave } = composerContext;
  const editor = useEditor();
  const { className: propsClassName = "content", children } = props, rest = __rest2(props, ["className", "children"]);
  const child = import_react2.default.Children.only(children);
  assertTrue(import_react2.default.isValidElement(child));
  const layersArray = (layers, depth = 0) => {
    return layers.flatMap((layer) => {
      if (!layer) {
        console.trace("layersArray no layer", depth, layers);
        return [];
      }
      return layerArray(layer, depth);
    });
  };
  const layerArray = (layer, depth) => {
    const layerContext = { layer, depth };
    const contextProps = {
      key: `layer-${layer.id}`,
      value: layerContext,
      children: import_react2.default.createElement(ComposerLayer, Object.assign({}, child.props))
    };
    const context = import_react2.default.createElement(LayerContext.Provider, Object.assign({}, contextProps));
    const elements = [context];
    if (isLayerFolder(layer) && !layer.collapsed) {
      elements.push(...layersArray(layer.layers, depth + 1));
    }
    return elements;
  };
  const viewChildren = import_react2.default.useMemo(() => {
    var _a;
    return layersArray(((_a = editor.selection.cast) === null || _a === void 0 ? void 0 : _a.layers) || []);
  }, [composerContext.refreshed, composerContext.selectedLayer]);
  const calculatedClassName = () => {
    const classes = [propsClassName];
    if (droppingPosition !== DroppingPosition.None && !droppingLayer) {
      classes.push(ClassDropping);
    }
    return classes.join(" ");
  };
  const className = import_react2.default.useMemo(calculatedClassName, [droppingPosition, droppingLayer, editor.selection.layer]);
  const onClick = () => {
    editor.selection.unset(SelectType.Layer);
  };
  const dragValid = (dataTransfer) => {
    if (!dataTransfer)
      return false;
    const types = dragTypes(dataTransfer);
    if (types.includes(TransferTypeFiles))
      return true;
    const type = dragType(dataTransfer);
    return !!type;
  };
  const onDragOver = (event) => {
    event.preventDefault();
    const { dataTransfer } = event;
    if (!dragValid(dataTransfer))
      return;
    setDroppingPosition(viewChildren.length);
    setDroppingLayer();
  };
  const viewProps = Object.assign(Object.assign({}, rest), { children: viewChildren, key: "composer-view", onClick, onDragLeave, onDragOver, onDrop, className });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
function ComposerDepth(props) {
  const layerContext = import_react2.default.useContext(LayerContext);
  const { depth } = layerContext;
  const child = import_react2.default.Children.only(props.children);
  if (!import_react2.default.isValidElement(child))
    throw Problems.child;
  const kids = new Array(depth).fill(true).map((_, index) => {
    const childProps = Object.assign(Object.assign({}, child.props), { key: `depth-${index}` });
    return import_react2.default.cloneElement(child, childProps);
  });
  return import_react2.default.createElement(import_react2.default.Fragment, null, kids);
}
function ComposerFolderClose(props) {
  const composerContext = import_react2.default.useContext(ComposerContext);
  const layer = useLayer();
  if (layer.type !== LayerType.Folder)
    return null;
  const layerFolder = layer;
  if (layerFolder.collapsed)
    return null;
  const { children } = props, rest = __rest2(props, ["children"]);
  const child = import_react2.default.Children.only(children);
  if (!import_react2.default.isValidElement(child))
    throw Problems.child;
  const onClick = () => {
    layerFolder.collapsed = true;
    composerContext.refresh();
  };
  const childProps = Object.assign(Object.assign({}, rest), { onClick });
  return import_react2.default.cloneElement(child, childProps);
}
function ComposerFolderOpen(props) {
  const { children } = props, rest = __rest2(props, ["children"]);
  const child = import_react2.default.Children.only(children);
  if (!import_react2.default.isValidElement(child))
    throw Problems.child;
  const composerContext = import_react2.default.useContext(ComposerContext);
  const layer = useLayer();
  if (layer.type !== LayerType.Folder)
    return null;
  const layerFolder = layer;
  if (!layerFolder.collapsed)
    return null;
  const onClick = () => {
    layerFolder.collapsed = false;
    composerContext.refresh();
  };
  const childProps = Object.assign(Object.assign({}, rest), { onClick });
  return import_react2.default.cloneElement(child, childProps);
}
function ComposerLayerFolder(props) {
  const layer = useLayer();
  if (layer.type !== LayerType.Folder)
    return null;
  return import_react2.default.createElement(import_react2.default.Fragment, null, props.children);
}
function ComposerLayerLabel(props) {
  const layer = useLayer();
  const [label, setLabel] = import_react2.default.useState(layer.label);
  const handleAction = (event) => {
    if (!isActionEvent(event))
      return;
    const { action } = event.detail;
    if (isChangeAction(action) && layer === action.target)
      setLabel(layer.label);
  };
  useListeners({ [EventType.Action]: handleAction });
  const labelProps = Object.assign(Object.assign({}, props), { children: label });
  return import_react2.default.createElement("label", Object.assign({}, labelProps));
}
function ComposerLayerMash(props) {
  const layer = useLayer();
  if (layer.type !== LayerType.Mash)
    return null;
  return import_react2.default.createElement(import_react2.default.Fragment, null, props.children);
}
function Button(props) {
  const { useView, selected } = props, rest = __rest2(props, ["useView", "selected"]);
  if (!useView)
    return import_react2.default.createElement("button", Object.assign({}, rest));
  const { disabled, className } = rest, pruned = __rest2(rest, ["disabled", "className"]);
  const classes = [ClassButton];
  if (className)
    classes.push(className);
  if (disabled)
    classes.push(ClassDisabled);
  else if (selected)
    classes.push(ClassSelected);
  const viewProps = Object.assign(Object.assign({}, pruned), { className: classes.join(" ") });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
function AddFolderControl(props) {
  const editor = useEditor();
  const composerContext = import_react2.default.useContext(ComposerContext);
  const { children } = props, rest = __rest2(props, ["children"]);
  const child = import_react2.default.Children.only(children);
  if (!import_react2.default.isValidElement(child))
    throw Problems.child;
  const childProps = Object.assign(Object.assign({}, rest), { onClick: () => {
    editor.addFolder();
    composerContext.refresh();
  } });
  return import_react2.default.cloneElement(child, childProps);
}
function AddMashControl(props) {
  const editor = useEditor();
  const composerContext = import_react2.default.useContext(ComposerContext);
  const { children } = props, rest = __rest2(props, ["children"]);
  const child = import_react2.default.Children.only(children);
  if (!import_react2.default.isValidElement(child))
    throw Problems.child;
  const childProps = Object.assign(Object.assign({}, rest), { onClick: () => {
    editor.addMash();
    composerContext.refresh();
  } });
  return import_react2.default.cloneElement(child, childProps);
}
var DefaultComposerProps = function(props = {}) {
  var _a, _b, _c, _d, _e, _f;
  const optionsStrict = panelOptionsStrict(props);
  const { icons } = optionsStrict;
  (_a = optionsStrict.props).key || (_a.key = "composer");
  (_b = optionsStrict.props).className || (_b.className = "panel composer");
  (_c = optionsStrict.props).initialPicked || (_c.initialPicked = "container");
  (_d = optionsStrict.header).content || (_d.content = [icons.composer]);
  (_e = optionsStrict.footer).content || (_e.content = [
    import_react2.default.createElement(
      AddMashControl,
      null,
      import_react2.default.createElement(
        Button,
        null,
        icons.add,
        icons.mmWide
      )
    ),
    import_react2.default.createElement(
      AddFolderControl,
      null,
      import_react2.default.createElement(
        Button,
        null,
        icons.add,
        icons.folder
      )
    )
  ]);
  (_f = optionsStrict.content).children || (_f.children = import_react2.default.createElement(
    "div",
    { key: "layer", className: "layer" },
    import_react2.default.createElement(
      "div",
      { key: "icons" },
      import_react2.default.createElement(
        ComposerDepth,
        { key: "depth" },
        import_react2.default.createElement("div", { className: "depth" })
      ),
      import_react2.default.createElement(
        ComposerLayerFolder,
        { key: "layer-folder" },
        import_react2.default.createElement(
          ComposerFolderOpen,
          { key: "folder-open" },
          import_react2.default.createElement("div", { className: ClassButton }, icons.folder)
        ),
        import_react2.default.createElement(
          ComposerFolderClose,
          { key: "folder-close" },
          import_react2.default.createElement("div", { className: ClassButton }, icons.folderOpen)
        )
      ),
      import_react2.default.createElement(
        ComposerLayerMash,
        { key: "layer-mash" },
        import_react2.default.createElement("div", { key: "mash-icon", className: ClassButton }, icons.mmTube)
      )
    ),
    import_react2.default.createElement(ComposerLayerLabel, { key: "label" }),
    import_react2.default.createElement("div", { key: "play-button", className: ClassButton }, icons.playerPlay)
  ));
  const children = import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement(Bar, Object.assign({}, optionsStrict.header)),
    import_react2.default.createElement(ComposerContent, Object.assign({}, optionsStrict.content.props), optionsStrict.content.children),
    import_react2.default.createElement(Bar, Object.assign({}, optionsStrict.footer))
  );
  return Object.assign(Object.assign({}, optionsStrict.props), { children });
};
function CreateEditedControl(props) {
  const { children } = props, rest = __rest2(props, ["children"]);
  const editor = useEditor();
  const getDisabled = () => editor.can(MasherAction.Save);
  const [disabled, setDisabled] = import_react2.default.useState(getDisabled);
  const updateDisabled = () => {
    setDisabled(getDisabled());
  };
  useListeners({
    [EventType.Action]: updateDisabled,
    [EventType.Mash]: updateDisabled,
    [EventType.Cast]: updateDisabled,
    [EventType.Save]: updateDisabled
  });
  const onClick = () => {
    if (disabled)
      return;
    editor.create();
  };
  const buttonOptions = Object.assign(Object.assign({}, rest), { onClick, disabled });
  return import_react2.default.cloneElement(import_react2.default.Children.only(children), buttonOptions);
}
function EditorRedoButton(props) {
  const [disabled, setDisabled] = import_react2.default.useState(true);
  const editor = useEditor();
  useListeners({
    [EventType.Action]: () => {
      setDisabled(!editor.can(MasherAction.Redo));
    }
  });
  const { children } = props, rest = __rest2(props, ["children"]);
  const onClick = () => {
    editor.redo();
  };
  const buttonOptions = Object.assign(Object.assign({}, rest), { onClick, disabled });
  return import_react2.default.cloneElement(import_react2.default.Children.only(children), buttonOptions);
}
function EditorRemoveButton(props) {
  const { children, type } = props, rest = __rest2(props, ["children", "type"]);
  const selectType = type || SelectType.Clip;
  assertSelectType(selectType);
  const editor = useEditor();
  const [disabled, setDisabled] = import_react2.default.useState(!editor.selection[selectType]);
  useListeners({
    [EventType.Selection]: () => {
      setDisabled(!editor.selection[selectType]);
    }
  });
  const onClick = () => {
    if (disabled)
      return;
    const selectable = editor.selection[selectType];
    if (isEffect(selectable))
      editor.removeEffect(selectable);
    else if (isClip(selectable))
      editor.removeClip(selectable);
    else if (isTrack(selectable))
      editor.removeTrack(selectable);
  };
  const child = import_react2.default.Children.only(children);
  const cloneProps = Object.assign(Object.assign(Object.assign({}, rest), child.props), { onClick, disabled });
  return import_react2.default.cloneElement(child, cloneProps);
}
function EditorUndoButton(props) {
  const editor = useEditor();
  const [disabled, setDisabled] = import_react2.default.useState(true);
  useListeners({
    [EventType.Action]: () => {
      setDisabled(!editor.can(MasherAction.Undo));
    }
  });
  const { children } = props, rest = __rest2(props, ["children"]);
  const onClick = () => {
    editor.undo();
  };
  const buttonOptions = Object.assign(Object.assign({}, rest), { onClick, disabled });
  return import_react2.default.cloneElement(import_react2.default.Children.only(children), buttonOptions);
}
function RenderControl(props) {
  const processContext = import_react2.default.useContext(ProcessContext);
  const apiContext = import_react2.default.useContext(ApiContext);
  const { children } = props, rest = __rest2(props, ["children"]);
  const { processing, setProcessing, setError } = processContext;
  const { endpointPromise } = apiContext;
  const editor = useEditor();
  const getDisabled = () => !editor.can(MasherAction.Render);
  const [disabled, setDisabled] = import_react2.default.useState(getDisabled);
  const updateDisabled = () => setDisabled(getDisabled());
  useListeners({
    [EventType.Save]: updateDisabled,
    [EventType.Mash]: updateDisabled,
    [EventType.Action]: updateDisabled
  });
  const handleApiCallback = (callback, mash) => {
    setTimeout(() => {
      console.debug("handleApiCallback request", callback);
      fetchCallback(callback).then((response) => {
        console.debug("handleApiCallback response", response);
        const { apiCallback, error } = response;
        if (error)
          handleError(callback.endpoint.prefix, callback.request, response, error);
        else if (apiCallback) {
          const { request, endpoint } = apiCallback;
          if (endpoint.prefix === Endpoints.data.mash.put) {
            const putRequest = request.body;
            const { rendering } = putRequest.mash;
            if (rendering)
              mash.rendering = rendering;
          }
          handleApiCallback(apiCallback, mash);
        } else
          setProcessing(false);
      });
    }, 2e3);
  };
  const handleError = (endpoint, request, response, error) => {
    setProcessing(false);
    setError(error);
    console.error(endpoint, request, response, error);
  };
  const onClick = () => {
    if (disabled || processing)
      return;
    const { edited } = editor;
    assertMash(edited);
    setProcessing(true);
    const request = {
      mash: edited.toJSON(),
      definitions: editor.definitions.map((definition) => definition.toJSON()),
      outputs: [{ outputType: OutputType.Video }]
    };
    console.debug("RenderingStartRequest", Endpoints.rendering.start, request);
    endpointPromise(Endpoints.rendering.start, request).then((response) => {
      console.debug("RenderingStartResponse", Endpoints.rendering.start, response);
      const { apiCallback, error } = response;
      if (error)
        handleError(Endpoints.rendering.start, request, response, error);
      else
        handleApiCallback(apiCallback, edited);
    });
  };
  const buttonOptions = Object.assign(Object.assign({}, rest), { onClick, disabled: disabled || processing });
  return import_react2.default.cloneElement(import_react2.default.Children.only(children), buttonOptions);
}
function SaveControl(props) {
  const editor = useEditor();
  const editorContext = import_react2.default.useContext(MasherContext);
  const { save } = editorContext;
  const getDisabled = () => !editor.can(MasherAction.Save);
  const [disabled, setDisabled] = import_react2.default.useState(getDisabled);
  const updateDisabled = () => {
    setDisabled(getDisabled());
  };
  useListeners({
    [EventType.Action]: updateDisabled,
    [EventType.Save]: updateDisabled
  });
  const { children } = props, rest = __rest2(props, ["children"]);
  const onClick = () => {
    if (disabled)
      return;
    setDisabled(true);
    save();
  };
  const buttonOptions = Object.assign(Object.assign({}, rest), { onClick, disabled });
  return import_react2.default.cloneElement(import_react2.default.Children.only(children), buttonOptions);
}
var InspectorContextDefault = {
  actionCount: 0,
  selectedInfo: {
    tweenDefined: {},
    tweenSelected: {},
    selectedType: SelectType.None,
    selectTypes: []
  },
  selectedItems: [],
  changeSelected: EmptyMethod,
  changeTweening: EmptyMethod
};
var InspectorContext = import_react2.default.createContext(InspectorContextDefault);
function SelectEditedControl(props) {
  var _a, _b;
  const editor = useEditor();
  const [requested, setRequested] = import_react2.default.useState(false);
  const [described, setDescribed] = import_react2.default.useState(() => []);
  const [editedId, setEditedId] = import_react2.default.useState(((_a = editor.edited) === null || _a === void 0 ? void 0 : _a.id) || "");
  const apiContext = import_react2.default.useContext(ApiContext);
  const inspectorContext = import_react2.default.useContext(InspectorContext);
  const { selectedInfo } = inspectorContext;
  const { selectedType } = selectedInfo;
  const [editedLabel, setEditedLabel] = import_react2.default.useState(((_b = editor.edited) === null || _b === void 0 ? void 0 : _b.label) || "");
  const getDisabled = () => editor.can(MasherAction.Save);
  const [disabled, setDisabled] = import_react2.default.useState(getDisabled);
  const { enabled, servers, endpointPromise } = apiContext;
  const updateDisabled = () => {
    setDisabled(getDisabled());
  };
  const handleEdited = (event) => {
    const { type } = event;
    if (!(isEventType(type) && isSelectType(type)))
      return;
    if (type !== selectedType)
      return;
    const { edited } = editor;
    assertObject(edited);
    const { id, label } = edited;
    setDescribed((original) => {
      const copy = original.filter((object) => isPopulatedString(object.label));
      const index = copy.findIndex((object) => object.id === id);
      if (isPositive(index))
        copy.splice(index, 1, edited);
      else
        copy.push(edited);
      setEditedId(id);
      setEditedLabel(label);
      return copy;
    });
  };
  const handleAction = () => {
    const { edited } = editor;
    assertObject(edited);
    const { label } = edited;
    if (editedLabel !== label) {
      setDescribed((original) => [...original]);
      setEditedLabel(label);
    }
    updateDisabled();
  };
  useListeners({
    [EventType.Action]: handleAction,
    [EventType.Mash]: handleEdited,
    [EventType.Cast]: handleEdited,
    [EventType.Save]: updateDisabled
  }, editor.eventTarget);
  const onChange = (event) => {
    if (disabled)
      return;
    const { selectedIndex } = event.target;
    const object = described[selectedIndex];
    assertObject(object);
    const { id } = object;
    const request = { id };
    const { editType } = editor;
    const endpoint = Endpoints.data[editType].get;
    console.debug("GetRequest", endpoint, request);
    endpointPromise(endpoint, request).then((response) => {
      console.debug("GetResponse", endpoint, response);
      const { error } = response;
      if (error)
        console.error("GetResponse", endpoint, error);
      else
        return editor.load(response);
    });
  };
  import_react2.default.useEffect(() => {
    if (!(enabled && servers[ServerType.Data]))
      return;
    if (requested)
      return;
    setRequested(true);
    const request = { partial: true };
    const endpoint = Endpoints.data[editor.editType].retrieve;
    console.debug("RetrieveRequest", endpoint, request);
    endpointPromise(endpoint, request).then((response) => {
      console.debug("RetrieveResponse", endpoint, response);
      const { described: described2, error } = response;
      if (error)
        console.error("RetrieveResponse", endpoint, error);
      else
        setDescribed((original) => {
          const copy = [...original];
          described2.forEach((object) => {
            const { id, label } = object;
            const found = copy.find((object2) => object2.id === id);
            if (found || !isPopulatedString(label))
              return;
            copy.push(object);
          });
          return copy;
        });
    });
  }, [servers, enabled]);
  if (described.length < 2)
    return null;
  const describedOptions = () => {
    const { editType, edited } = editor;
    const elements = [import_react2.default.createElement("optgroup", { key: "group", label: labelTranslate("open") })];
    if (!edited)
      return elements;
    const { id: editedId2, label: editedLabel2 } = edited;
    elements.push(...described.map((object) => {
      const { label: objectLabel, id } = object;
      const label = id === editedId2 ? editedLabel2 : objectLabel;
      const children2 = isPopulatedString(label) ? label : labelInterpolate("unlabeled", { type: editType });
      const optionProps = { children: children2, value: id, key: id };
      const option = import_react2.default.createElement("option", Object.assign({}, optionProps));
      return option;
    }));
    return elements;
  };
  const { children } = props, rest = __rest2(props, ["children"]);
  const child = import_react2.default.Children.only(children);
  assertTrue(import_react2.default.isValidElement(child));
  const selectOptions = {
    key: "edited-select",
    onChange,
    disabled,
    children: describedOptions(),
    value: editedId
  };
  const viewProps = Object.assign(Object.assign({}, rest), { children: [child, import_react2.default.createElement("select", Object.assign({}, selectOptions))] });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
function ViewControl(props) {
  const editor = useEditor();
  const getDisabled = () => {
    const { edited } = editor;
    if (!isMash(edited))
      return true;
    const { rendering } = edited;
    return !rendering;
  };
  const [disabled, setDisabled] = import_react2.default.useState(getDisabled);
  const updateDisabled = () => setDisabled(getDisabled());
  useListeners({
    [EventType.Render]: updateDisabled,
    [EventType.Mash]: updateDisabled
  });
  const { children } = props, rest = __rest2(props, ["children"]);
  const onClick = () => {
    if (disabled)
      return;
    const { edited } = editor;
    assertMash(edited);
    const url = urlForEndpoint(editor.preloader.endpoint, edited.rendering);
    window.open(url);
  };
  const buttonOptions = Object.assign(Object.assign({}, rest), { onClick, disabled });
  return import_react2.default.cloneElement(import_react2.default.Children.only(children), buttonOptions);
}
function ConstEmptyElementFunction(props) {
  return null;
}
var EmptyElement = import_react2.default.createElement(ConstEmptyElementFunction, { key: "empty" });
var TweenInputKey = "tween-input-key";
var DataTypeInputs = {
  [DataType.Frame]: EmptyElement,
  [DataType.Number]: EmptyElement,
  [DataType.Rgb]: EmptyElement,
  [DataType.String]: EmptyElement,
  [DataType.DefinitionId]: EmptyElement,
  [DataType.FontId]: EmptyElement,
  [DataType.Percent]: EmptyElement,
  [DataType.ContainerId]: EmptyElement,
  [DataType.ContentId]: EmptyElement,
  [DataType.Boolean]: EmptyElement,
  [DataType.Timing]: EmptyElement,
  [DataType.Sizing]: EmptyElement
};
var InputContextDefault = {
  value: "",
  name: "",
  property: { type: DataType.String, name: "", defaultValue: "" }
};
var InputContext = import_react2.default.createContext(InputContextDefault);
function BooleanTypeInput() {
  const inputContext = import_react2.default.useContext(InputContext);
  const { changeHandler, property, value, name } = inputContext;
  if (!property)
    return null;
  const inputProps = {
    type: "checkbox",
    name,
    checked: !!value
  };
  if (changeHandler) {
    inputProps.onChange = (event) => {
      changeHandler(name, event.target.checked);
    };
  } else
    inputProps.disabled = true;
  return import_react2.default.createElement("input", Object.assign({}, inputProps));
}
DataTypeInputs[DataType.Boolean] = import_react2.default.createElement(BooleanTypeInput, null);
function DefinitionDrop(props) {
  const { type, types, children, className } = props, rest = __rest2(props, ["type", "types", "children", "className"]);
  const child = import_react2.default.Children.only(children);
  assertTrue(import_react2.default.isValidElement(child));
  const [isOver, setIsOver] = import_react2.default.useState(false);
  const inputContext = import_react2.default.useContext(InputContext);
  const editorContext = import_react2.default.useContext(MasherContext);
  const { drop } = editorContext;
  const { changeHandler, value, name } = inputContext;
  assertTrue(changeHandler);
  const definitionTypes = propsDefinitionTypes(type, types);
  const childNodes = () => {
    if (!value)
      return null;
    assertPopulatedString(value);
    const definition = Defined.fromId(value);
    assertDefinition(definition);
    const definitionProps = { definition, key: definition.id };
    const children2 = import_react2.default.cloneElement(child, definitionProps);
    const contextProps = { children: children2, value: { definition } };
    return import_react2.default.createElement(DefinitionContext.Provider, Object.assign({}, contextProps));
  };
  const dropAllowed = (event) => {
    const { dataTransfer } = event;
    assertTrue(dataTransfer);
    const types2 = dragTypes(dataTransfer);
    if (types2.includes(TransferTypeFiles))
      return true;
    const draggingType = dragType(dataTransfer);
    if (!isDefinitionType(draggingType))
      return false;
    return definitionTypes.includes(draggingType);
  };
  const onDragLeave = () => {
    setIsOver(false);
  };
  const onDragOver = (event) => {
    const allowed = dropAllowed(event);
    setIsOver(allowed);
    if (allowed)
      event.preventDefault();
  };
  const onDrop = (event) => __awaiter(this, void 0, void 0, function* () {
    eventStop(event);
    setIsOver(false);
    if (!dropAllowed(event))
      return;
    const { dataTransfer } = event;
    assertTrue(dataTransfer);
    const types2 = dragTypes(dataTransfer);
    if (types2.includes(TransferTypeFiles)) {
      yield drop(dataTransfer.files).then((definitions) => {
        if (!definitions.length)
          return;
        const container = name === "containerId";
        const valid = container ? definitions.filter(isContainerDefinition) : definitions;
        const [definition2] = valid;
        if (definition2) {
          assertTrue(Defined.installed(definition2.id), `${definition2.type} installed`);
          changeHandler(name, definition2.id);
        }
      });
      return;
    }
    const type2 = dropType(dataTransfer);
    const json = dataTransfer.getData(type2);
    const data = JSON.parse(json);
    const { definitionObject } = data;
    const [definition] = Defined.define(definitionObject);
    if (name === "containerId" && !isContainerDefinition(definition))
      return;
    changeHandler(name, definitionObject.id);
  });
  const calculateClassName = () => {
    const classes = [];
    if (className)
      classes.push(className);
    if (isOver)
      classes.push(ClassDropping);
    return classes.join(" ");
  };
  const memoClassName = import_react2.default.useMemo(calculateClassName, [isOver]);
  const viewProps = Object.assign(Object.assign({}, rest), {
    className: memoClassName,
    children: childNodes(),
    onDragLeave,
    onDragOver,
    onDrop,
    value: String(value),
    key: `${name}-drop`
  });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
DataTypeInputs[DataType.ContainerId] = import_react2.default.createElement(
  DefinitionDrop,
  { types: ContainerTypes, className: "definition-drop" },
  import_react2.default.createElement(DefinitionItem, { className: "definition preview" })
);
DataTypeInputs[DataType.ContentId] = import_react2.default.createElement(
  DefinitionDrop,
  { types: ContentTypes, className: "definition-drop" },
  import_react2.default.createElement(DefinitionItem, { className: "definition preview" })
);
function DefinitionSelect() {
  const inputContext = import_react2.default.useContext(InputContext);
  const { changeHandler, value, name } = inputContext;
  assertTrue(changeHandler);
  const onChange = (event) => {
    changeHandler(name, event.target.value);
  };
  const options = Defined.byType(DefinitionType.Font).map((object) => {
    const { id, label } = object;
    const optionProps = { value: id, children: label, key: id };
    return import_react2.default.createElement("option", Object.assign({}, optionProps));
  });
  const selectProps = {
    children: options,
    name,
    onChange,
    value: String(value),
    key: `${name}-select`
  };
  return import_react2.default.createElement("select", Object.assign({}, selectProps));
}
DataTypeInputs[DataType.FontId] = import_react2.default.createElement(DefinitionSelect, null);
function NumericTypeInput() {
  const inputContext = import_react2.default.useContext(InputContext);
  const editor = useEditor();
  const { changeHandler, property, value, name, time } = inputContext;
  if (!property)
    return null;
  const { min, max, step } = property;
  const inputProps = {
    type: "number",
    name,
    value: String(value)
  };
  if (isDefined(min))
    inputProps.min = min;
  if (isDefined(max))
    inputProps.max = max;
  if (isDefined(step))
    inputProps.step = step;
  if (changeHandler) {
    inputProps.onChange = (event) => __awaiter(this, void 0, void 0, function* () {
      const { value: value2 } = event.target;
      if (time)
        yield editor.goToTime(time);
      changeHandler(name, value2);
    });
  } else
    inputProps.disabled = true;
  return import_react2.default.createElement("input", Object.assign({}, inputProps));
}
DataTypeInputs[DataType.Number] = import_react2.default.createElement(NumericTypeInput, null);
DataTypeInputs[DataType.Frame] = import_react2.default.createElement(NumericTypeInput, null);
function Slider(props) {
  const { className, onChange } = props;
  const options = Object.assign({}, props);
  const classes = ["slider"];
  if (className)
    classes.push(className);
  options.className = classes.join(" ");
  if (onChange) {
    const handleChange = (event) => {
      onChange(event, event.currentTarget.valueAsNumber);
    };
    options.onChange = handleChange;
  }
  const input = import_react2.default.createElement("input", Object.assign({ type: "range" }, options));
  return input;
}
function PercentTypeInput() {
  const editor = useEditor();
  const inputContext = import_react2.default.useContext(InputContext);
  const { changeHandler, property, value: contextValue, name, time, defaultValue: contextDefault } = inputContext;
  if (!property)
    return null;
  const { max, min, step, defaultValue: propertyDefault } = property;
  const value = isDefined(contextValue) ? contextValue : isDefined(contextDefault) ? contextDefault : propertyDefault;
  const sliderProps = {
    value,
    min: isNumber(min) ? min : 0,
    max: isNumber(max) ? max : 1,
    step: isNumber(step) ? step : 0.01,
    name
  };
  if (changeHandler) {
    const onChange = (_event, values) => __awaiter(this, void 0, void 0, function* () {
      const value2 = isArray(values) ? values[0] : values;
      if (time)
        yield editor.goToTime(time);
      changeHandler(name, value2);
    });
    sliderProps.onChange = onChange;
  } else
    sliderProps.disabled = true;
  return import_react2.default.createElement(Slider, Object.assign({ className: "slider" }, sliderProps));
}
DataTypeInputs[DataType.Percent] = import_react2.default.createElement(PercentTypeInput, null);
function RgbTypeInput() {
  import_react2.default.useContext(MasherContext);
  const inputContext = import_react2.default.useContext(InputContext);
  const editor = useEditor();
  const { changeHandler, property, value: contextValue, name, time, defaultValue: contextDefault } = inputContext;
  if (!property)
    return null;
  const { defaultValue: propertyDefault } = property;
  const value = isDefined(contextValue) ? contextValue : isDefined(contextDefault) ? contextDefault : propertyDefault;
  const colorProps = {
    type: "color",
    name,
    value: String(value)
  };
  if (changeHandler) {
    colorProps.onChange = (event) => __awaiter(this, void 0, void 0, function* () {
      const { value: value2 } = event.target;
      if (time)
        yield editor.goToTime(time);
      changeHandler(name, value2);
    });
  } else
    colorProps.disabled = true;
  return import_react2.default.createElement("input", Object.assign({}, colorProps));
}
DataTypeInputs[DataType.Rgb] = import_react2.default.createElement(RgbTypeInput, null);
function SizingTypeInput() {
  const inputContext = import_react2.default.useContext(InputContext);
  const { changeHandler, property, value, name } = inputContext;
  if (!property)
    return null;
  const options = Sizings.map((id) => {
    const optionProps = { value: id, children: id, key: id };
    return import_react2.default.createElement("option", Object.assign({}, optionProps));
  });
  const selectProps = {
    children: options,
    name,
    value: String(value),
    key: `${name}-select`
  };
  if (changeHandler) {
    selectProps.onChange = (event) => {
      changeHandler(name, event.target.value);
    };
  } else
    selectProps.disabled = true;
  return import_react2.default.createElement("select", Object.assign({}, selectProps));
}
DataTypeInputs[DataType.Sizing] = import_react2.default.createElement(SizingTypeInput, null);
function TextTypeInput() {
  const inputContext = import_react2.default.useContext(InputContext);
  const { changeHandler, property, value, name } = inputContext;
  if (!property)
    return null;
  const inputProps = {
    name,
    type: "text",
    value: String(value)
  };
  if (changeHandler) {
    inputProps.onChange = (event) => {
      changeHandler(name, event.target.value);
    };
  } else
    inputProps.disabled = true;
  return import_react2.default.createElement("input", Object.assign({}, inputProps));
}
DataTypeInputs[DataType.String] = import_react2.default.createElement(TextTypeInput, null);
function TimingTypeInput() {
  const inputContext = import_react2.default.useContext(InputContext);
  const { changeHandler, property, value, name } = inputContext;
  if (!property)
    return null;
  const options = Timings.map((id) => {
    const optionProps = { value: id, children: id, key: id };
    return import_react2.default.createElement("option", Object.assign({}, optionProps));
  });
  const selectProps = {
    children: options,
    name,
    value: String(value),
    key: `${name}-select`
  };
  if (changeHandler) {
    selectProps.onChange = (event) => {
      changeHandler(name, event.target.value);
    };
  } else
    selectProps.disabled = true;
  return import_react2.default.createElement("select", Object.assign({}, selectProps));
}
DataTypeInputs[DataType.Timing] = import_react2.default.createElement(TimingTypeInput, null);
var DataGroupInputs = {
  [DataGroup.Size]: EmptyElement,
  [DataGroup.Sizing]: EmptyElement,
  [DataGroup.Point]: EmptyElement,
  [DataGroup.Opacity]: EmptyElement,
  [DataGroup.Color]: EmptyElement,
  [DataGroup.Effects]: EmptyElement,
  [DataGroup.Timing]: EmptyElement
};
function ColorGroupInput(props) {
  const masherContext = import_react2.default.useContext(MasherContext);
  const { icons } = masherContext;
  const editor = useEditor();
  const { selectType } = props, rest = __rest2(props, ["selectType"]);
  assertSelectType(selectType);
  const inspectorContext = import_react2.default.useContext(InspectorContext);
  const { selectedItems, changeTweening, selectedInfo } = inspectorContext;
  const { tweenDefined, tweenSelected, onEdge, time, nearStart, timeRange } = selectedInfo;
  assertTimeRange(timeRange);
  assertTime(time);
  const endDefined = tweenDefined[DataGroup.Color];
  const endSelected = tweenSelected[DataGroup.Color];
  const byName = selectedPropertyObject(selectedItems, DataGroup.Color, selectType);
  const { color, [`color${PropertyTweenSuffix}`]: colorEnd } = byName;
  const colorProperty = endSelected ? colorEnd : color;
  const { property, changeHandler, value, name: nameOveride } = colorProperty;
  const { type, name: propertyName } = property;
  const name = nameOveride || propertyName;
  const input = DataTypeInputs[type];
  const inputContext = {
    property,
    value,
    name,
    changeHandler
  };
  inputContext.time = tweenInputTime(timeRange, onEdge, nearStart, endDefined, endSelected);
  if (endSelected) {
    inputContext.defaultValue = color.value;
  }
  const selectedButton = [ClassSelected, ClassButton].join(" ");
  const startProps = {
    children: icons.start,
    className: endSelected ? ClassButton : selectedButton,
    key: "start",
    onClick: () => {
      editor.goToTime(timeRange.startTime);
      changeTweening(DataGroup.Color, false);
    }
  };
  const endProps = {
    key: "end",
    className: endSelected ? selectedButton : ClassButton,
    children: endDefined ? icons.end : icons.endUndefined,
    onClick: () => {
      editor.goToTime(timeRange.lastTime);
      changeTweening(DataGroup.Color, true);
    }
  };
  const providerProps = { key: "context", value: inputContext, children: input };
  const viewProps = Object.assign(Object.assign({}, rest), { key: `inspector-${selectType}-${name}`, children: [
    icons.color,
    import_react2.default.createElement(InputContext.Provider, Object.assign({}, providerProps)),
    import_react2.default.createElement(
      View,
      { className: "start-end", key: "start-end" },
      import_react2.default.createElement(View, Object.assign({}, startProps)),
      import_react2.default.createElement(View, Object.assign({}, endProps))
    )
  ] });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
DataGroupInputs[DataGroup.Color] = import_react2.default.createElement(ColorGroupInput, { className: "color tween row", key: "color-group-input" });
var elementSetPreviewSize = (current, size) => {
  if (!(size && current))
    return;
  const { width, height } = size;
  current.style.setProperty("--preview-width", `${width}px`);
  current.style.setProperty("--preview-height", `${height}px`);
};
var sessionGet = (key) => {
  return globalThis.window.sessionStorage.getItem(key) || "";
};
var sessionSet = (key, value) => {
  globalThis.window.sessionStorage.setItem(key, String(value));
};
var VideoView = import_react2.default.forwardRef((props, ref) => import_react2.default.createElement("video", Object.assign({}, props, { ref })));
function InspectorEffect(props) {
  const { className, removeHandler, index, effect, selectedEffect, setSelectedEffect } = props, rest = __rest2(props, ["className", "removeHandler", "index", "effect", "selectedEffect", "setSelectedEffect"]);
  const selected = selectedEffect === effect;
  const onMouseDown = () => {
    if (!selected)
      setSelectedEffect(effect);
  };
  const onDragEnd = (event) => {
    const { dataTransfer } = event;
    if (!dataTransfer)
      return;
    const { dropEffect } = dataTransfer;
    if (dropEffect === "none")
      removeHandler(effect);
  };
  const onDragStart = (event) => {
    if (!selected)
      onMouseDown();
    const data = { index };
    const json = JSON.stringify(data);
    const { dataTransfer } = event;
    if (!dataTransfer)
      return;
    dataTransfer.effectAllowed = "move";
    dataTransfer.setData(`effect${DragSuffix}`, json);
  };
  const classes = [className || "effect"];
  if (selected)
    classes.push(ClassSelected);
  const viewProps = Object.assign(Object.assign({}, rest), { children: effect.label, className: classes.join(" "), onMouseDown, onDragStart, onDragEnd, onClick: (event) => event.stopPropagation(), draggable: true });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
function InspectorProperty(props) {
  const { defaultValue: propsDefault, changeHandler, time, property, value, name } = props;
  const { type, defaultValue: propertyDefault } = property;
  const defaultValue = isDefined(propsDefault) ? propsDefault : propertyDefault;
  const inputContext = {
    property,
    value,
    changeHandler,
    name,
    time,
    defaultValue
  };
  const contextProps = {
    key: "context",
    value: inputContext,
    children: DataTypeInputs[type]
  };
  return import_react2.default.createElement(InputContext.Provider, Object.assign({}, contextProps));
}
function InspectorProperties(props) {
  const masherContext = import_react2.default.useContext(MasherContext);
  const { icons } = masherContext;
  const inspectorContext = import_react2.default.useContext(InspectorContext);
  const { selectedItems: propsItems } = props;
  const { selectedItems: inspectorItems } = inspectorContext;
  const selectedItems = propsItems || inspectorItems;
  const ungroupedInputs = [];
  const groupedInputs = [];
  const groups = {};
  const selectTypes = /* @__PURE__ */ new Set();
  selectedItems.forEach((selectedProperty) => {
    if (isSelectedProperty(selectedProperty)) {
      const { property, changeHandler, selectType, value, name: nameOveride } = selectedProperty;
      const { name: propertyName, group } = property;
      if (group) {
        const key = [group, selectType].join("-");
        if (!groups[key]) {
          groups[key] = true;
          groupedInputs.push(import_react2.default.cloneElement(DataGroupInputs[group], { selectType }));
        }
        return;
      }
      const name = nameOveride || propertyName;
      selectTypes.add(selectType);
      const propertyProps = Object.assign({ key: `inspector-${selectType}-${name}`, property, value, changeHandler, name }, props);
      const icon = icons[name];
      const inspectorProperty = import_react2.default.createElement(InspectorProperty, Object.assign({}, propertyProps));
      if (icon) {
        const viewChildren = [inspectorProperty];
        viewChildren.unshift(icon);
        const viewProps = {
          children: viewChildren,
          className: "row",
          key: `icon-${selectType}-${name}`
        };
        ungroupedInputs.push(import_react2.default.createElement(View, Object.assign({}, viewProps)));
      } else
        ungroupedInputs.push(inspectorProperty);
    } else {
      const effectsProps = {
        key: "inspector-effects",
        selectedEffects: selectedProperty
      };
      groupedInputs.push(import_react2.default.cloneElement(DataGroupInputs.effects, effectsProps));
    }
  });
  if (selectTypes.has(SelectType.Clip)) {
    ungroupedInputs.push();
  }
  return import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    ungroupedInputs,
    groupedInputs
  );
}
function EffectsGroupInput(props) {
  const masherContext = import_react2.default.useContext(MasherContext);
  const { icons } = masherContext;
  const { selectedEffects } = props, rest = __rest2(props, ["selectedEffects"]);
  const ref = import_react2.default.useRef(null);
  const [isOver, setIsOver] = import_react2.default.useState(false);
  const [selectedEffect, setSelectedEffect] = import_react2.default.useState(null);
  const editor = useEditor();
  const { actions } = editor;
  assertTrue(selectedEffects);
  const { value: effects, addHandler, removeHandler, moveHandler } = selectedEffects;
  const selected = selectedEffect && effects.includes(selectedEffect) ? selectedEffect : null;
  if (selected !== selectedEffect)
    setSelectedEffect(selected);
  const dropIndex = (event) => {
    const { target } = event;
    if (target && target instanceof HTMLDivElement) {
      const index = target.getAttribute("index");
      if (index)
        return Number(index);
    }
    return effects.length;
  };
  const dropAllowed = (event) => {
    const { dataTransfer } = event;
    const type = dragType(dataTransfer);
    return type === DefinitionType.Effect;
  };
  const onDragLeave = () => {
    setIsOver(false);
  };
  const onDragOver = (event) => {
    const allowed = dropAllowed(event);
    setIsOver(allowed);
    if (allowed)
      event.preventDefault();
  };
  const onDrop = (event) => {
    setIsOver(false);
    if (!dropAllowed(event))
      return;
    event.preventDefault();
    const { dataTransfer } = event;
    if (!dataTransfer)
      return;
    const type = dropType(dataTransfer);
    const json = dataTransfer.getData(type);
    const data = JSON.parse(json);
    const { definitionObject, index } = data;
    const droppedIndex = dropIndex(event);
    if (!isObject(definitionObject)) {
      if (droppedIndex === index)
        return;
      assertEffect(selected);
      moveHandler(selected, droppedIndex);
    } else {
      const definition = Defined.fromObject(definitionObject);
      if (isEffectDefinition(definition)) {
        const effect = definition.instanceFromObject();
        addHandler(effect, droppedIndex);
      }
    }
  };
  const onClick = () => {
    setSelectedEffect(null);
  };
  const childNodes = () => {
    return effects.map((effect, index) => {
      const clipProps = {
        key: effect.id,
        selectedEffect: selected,
        setSelectedEffect,
        effect,
        index,
        removeHandler
      };
      return import_react2.default.createElement(InspectorEffect, Object.assign({}, clipProps));
    });
  };
  const calculateClassName = () => {
    const classes = ["list"];
    if (isOver)
      classes.push(ClassDropping);
    return classes.join(" ");
  };
  const memoClassName = import_react2.default.useMemo(calculateClassName, [isOver]);
  const listViewProps = {
    children: childNodes(),
    ref,
    onDragLeave,
    onDragOver,
    onDrop,
    onClick,
    key: "view",
    className: memoClassName
  };
  const viewProps = Object.assign(Object.assign({}, rest), { key: "effects", children: [icons.browserEffect, import_react2.default.createElement(View, Object.assign({}, listViewProps))] });
  const effectsView = import_react2.default.createElement(View, Object.assign({}, viewProps));
  if (!selected)
    return effectsView;
  return import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    effectsView,
    import_react2.default.createElement(InspectorProperties, { selectedItems: selected.selectedItems(actions) })
  );
}
DataGroupInputs[DataGroup.Effects] = import_react2.default.createElement(EffectsGroupInput, { className: "effects row", key: "effects-group-input" });
function OpacityGroupInput(props) {
  const masherContext = import_react2.default.useContext(MasherContext);
  const { icons } = masherContext;
  const editor = useEditor();
  const { selectType } = props, rest = __rest2(props, ["selectType"]);
  assertSelectType(selectType);
  const inspectorContext = import_react2.default.useContext(InspectorContext);
  const { selectedItems: properties, changeTweening, selectedInfo } = inspectorContext;
  const { tweenDefined, tweenSelected, onEdge, time, nearStart, timeRange } = selectedInfo;
  assertTimeRange(timeRange);
  assertTime(time);
  const endDefined = tweenDefined[DataGroup.Opacity];
  const endSelected = tweenSelected[DataGroup.Opacity];
  const byName = selectedPropertyObject(properties, DataGroup.Opacity, selectType);
  const { opacity, [`opacity${PropertyTweenSuffix}`]: opacityEnd } = byName;
  const opacityProperty = endSelected ? opacityEnd : opacity;
  const { property, changeHandler, value, name: nameOveride } = opacityProperty;
  const { type, name: propertyName } = property;
  const name = nameOveride || propertyName;
  const input = DataTypeInputs[type];
  const inputContext = {
    property,
    value,
    name,
    changeHandler
  };
  inputContext.time = tweenInputTime(timeRange, onEdge, nearStart, endDefined, endSelected);
  if (endSelected) {
    inputContext.defaultValue = opacity.value;
  }
  const selectedButton = [ClassSelected, ClassButton].join(" ");
  const startProps = {
    children: icons.start,
    className: endSelected ? ClassButton : selectedButton,
    key: "start",
    onClick: () => {
      editor.goToTime(timeRange.startTime);
      changeTweening(DataGroup.Opacity, false);
    }
  };
  const endProps = {
    key: "end",
    className: endSelected ? selectedButton : ClassButton,
    children: endDefined ? icons.end : icons.endUndefined,
    onClick: () => {
      editor.goToTime(timeRange.lastTime);
      changeTweening(DataGroup.Opacity, true);
    }
  };
  const providerProps = { key: "context", value: inputContext, children: input };
  const viewProps = Object.assign(Object.assign({}, rest), { key: `inspector-${selectType}-${name}`, children: [
    icons.opacity,
    import_react2.default.createElement(InputContext.Provider, Object.assign({}, providerProps)),
    import_react2.default.createElement(
      View,
      { className: "start-end", key: "start-end" },
      import_react2.default.createElement(View, Object.assign({}, startProps)),
      import_react2.default.createElement(View, Object.assign({}, endProps))
    )
  ] });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
DataGroupInputs[DataGroup.Opacity] = import_react2.default.createElement(OpacityGroupInput, { className: "opacity tween row", key: "opacity-group-input" });
function PointGroupInput(props) {
  const masherContext = import_react2.default.useContext(MasherContext);
  const { icons } = masherContext;
  const editor = useEditor();
  const { selectType } = props;
  assertSelectType(selectType);
  const inspectorContext = import_react2.default.useContext(InspectorContext);
  const { selectedItems: properties, changeTweening, selectedInfo } = inspectorContext;
  const { tweenDefined, tweenSelected, onEdge, time, nearStart, timeRange } = selectedInfo;
  assertTimeRange(timeRange);
  assertTime(time);
  const endDefined = tweenDefined[DataGroup.Point];
  const endSelected = tweenSelected[DataGroup.Point];
  const byName = selectedPropertyObject(properties, DataGroup.Point, selectType);
  const values = selectedPropertiesScalarObject(byName);
  const { offE, offW, offN, offS, x, y, [`x${PropertyTweenSuffix}`]: xEnd, [`y${PropertyTweenSuffix}`]: yEnd } = byName;
  const xProperty = endSelected ? xEnd : x;
  const yProperty = endSelected ? yEnd : y;
  const { offE: offEValue, offW: offWValue, offN: offNValue, offS: offSValue } = values;
  const elementsByName = {};
  const inspectingProperties = [xProperty, yProperty];
  const goTime = tweenInputTime(timeRange, onEdge, nearStart, endDefined, endSelected);
  inspectingProperties.forEach((selectedProperty) => {
    if (!selectedProperty) {
      console.error("PointInput", xProperty, yProperty);
      return;
    }
    const { property, changeHandler, value, name: nameOveride } = selectedProperty;
    const { type, name: propertyName } = property;
    const name = nameOveride || propertyName;
    const baseName = name.replace(PropertyTweenSuffix, "");
    const input = DataTypeInputs[type];
    const key = `inspector-${selectType}-${name}`;
    const inputContext = {
      property,
      value,
      name,
      changeHandler,
      time: goTime
    };
    if (endSelected) {
      inputContext.defaultValue = values[baseName];
    }
    const providerProps = { key, value: inputContext, children: input };
    elementsByName[baseName] = import_react2.default.createElement(InputContext.Provider, Object.assign({}, providerProps));
  });
  const selectedButton = [ClassSelected, ClassButton].join(" ");
  const startProps = {
    children: icons.start,
    className: endSelected ? ClassButton : selectedButton,
    key: "start",
    onClick: () => {
      editor.goToTime(timeRange.startTime);
      changeTweening(DataGroup.Point, false);
    }
  };
  const endProps = {
    key: "end",
    className: endSelected ? selectedButton : ClassButton,
    children: endDefined ? icons.end : icons.endUndefined,
    onClick: () => {
      editor.goToTime(timeRange.lastTime);
      changeTweening(DataGroup.Point, true);
    }
  };
  const legendElements = [
    icons.point,
    import_react2.default.createElement(
      View,
      { className: "start-end", key: `${selectType}-point-start-end` },
      import_react2.default.createElement(View, Object.assign({}, startProps)),
      import_react2.default.createElement(View, Object.assign({}, endProps))
    )
  ];
  const xElements = [import_react2.default.createElement(View, { key: "horz-icon", children: icons.horz, className: ClassButton })];
  const yElements = [import_react2.default.createElement(View, { key: "vert-icon", children: icons.vert, className: ClassButton })];
  if (offE) {
    const lockOffEProps = {
      key: "lock-east",
      className: ClassButton,
      children: offEValue ? icons.unlock : icons.lock,
      onClick: () => {
        offE.changeHandler("offE", !offEValue);
      }
    };
    const lockOffE = import_react2.default.createElement(View, Object.assign({}, lockOffEProps));
    xElements.push(lockOffE);
  }
  xElements.push(elementsByName.x);
  if (offW) {
    const lockOffWProps = {
      key: "lock-west",
      className: ClassButton,
      children: offWValue ? icons.unlock : icons.lock,
      onClick: () => {
        offW.changeHandler("offW", !offWValue);
      }
    };
    const lockOffW = import_react2.default.createElement(View, Object.assign({}, lockOffWProps));
    xElements.push(lockOffW);
  }
  if (offN) {
    const lockOffNProps = {
      key: "lock-north",
      className: ClassButton,
      children: offNValue ? icons.unlock : icons.lock,
      onClick: () => {
        offN.changeHandler("offN", !offNValue);
      }
    };
    const lockOffN = import_react2.default.createElement(View, Object.assign({}, lockOffNProps));
    yElements.push(lockOffN);
  }
  yElements.push(elementsByName.y);
  if (offS) {
    const lockOffSProps = {
      key: "lock-south",
      className: ClassButton,
      children: offSValue ? icons.unlock : icons.lock,
      onClick: () => {
        offS.changeHandler("offS", !offSValue);
      }
    };
    const lockOffS = import_react2.default.createElement(View, Object.assign({}, lockOffSProps));
    yElements.push(lockOffS);
  }
  const elements = [
    import_react2.default.createElement(View, { key: "x", children: xElements }),
    import_react2.default.createElement(View, { key: "y", children: yElements })
  ];
  return import_react2.default.createElement(
    "fieldset",
    null,
    import_react2.default.createElement(
      "legend",
      { key: "legend" },
      import_react2.default.createElement(View, null, legendElements)
    ),
    elements
  );
}
DataGroupInputs[DataGroup.Point] = import_react2.default.createElement(PointGroupInput, { key: "point-input" });
var SizeInputOrientations = {
  [Orientation.H]: "width",
  [Orientation.V]: "height"
};
function SizeGroupInput(props) {
  const masherContext = import_react2.default.useContext(MasherContext);
  const { icons } = masherContext;
  const editor = useEditor();
  const { selectType } = props;
  assertSelectType(selectType, "selectType");
  const inspectorContext = import_react2.default.useContext(InspectorContext);
  const { selectedItems: properties, selectedInfo, changeTweening } = inspectorContext;
  const { tweenDefined, tweenSelected, onEdge, time, nearStart, timeRange } = selectedInfo;
  assertTimeRange(timeRange);
  assertTime(time);
  const endDefined = tweenDefined[DataGroup.Size];
  const endSelected = tweenSelected[DataGroup.Size];
  const byName = selectedPropertyObject(properties, DataGroup.Size, selectType);
  const { lock, width, height, [`width${PropertyTweenSuffix}`]: widthEnd, [`height${PropertyTweenSuffix}`]: heightEnd } = byName;
  const widthProperty = endSelected ? widthEnd : width;
  const heightProperty = endSelected ? heightEnd : height;
  const values = selectedPropertiesScalarObject(byName);
  const { lock: lockValue } = values;
  assertString(lockValue, "lockValue");
  const orientation = isOrientation(lockValue) ? lockValue : void 0;
  const elementsByName = {};
  const inspectingProperties = [widthProperty, heightProperty];
  const goTime = tweenInputTime(timeRange, onEdge, nearStart, endDefined, endSelected);
  inspectingProperties.forEach((selectedProperty) => {
    const { property, changeHandler, value, name: nameOveride } = selectedProperty;
    const { type, name: propertyName } = property;
    const name = nameOveride || propertyName;
    const baseName = name.replace(PropertyTweenSuffix, "");
    const input = DataTypeInputs[type];
    const key = `inspector-${selectType}-${name}`;
    const inputContext = {
      property,
      value,
      name,
      time: goTime
    };
    if (endSelected) {
      inputContext.defaultValue = values[baseName];
    }
    if (!(orientation && baseName === SizeInputOrientations[orientation])) {
      inputContext.changeHandler = changeHandler;
    }
    const providerProps = {
      key,
      value: inputContext,
      children: input
    };
    elementsByName[baseName] = import_react2.default.createElement(InputContext.Provider, Object.assign({}, providerProps));
  });
  const lockWidthProps = {
    key: "lock-width",
    className: ClassButton,
    children: orientation === Orientation.H ? icons.lock : icons.unlock,
    onClick: () => {
      const value = orientation === Orientation.H ? "" : Orientation.H;
      lock.changeHandler("lock", value);
    }
  };
  const lockWidth = import_react2.default.createElement(View, Object.assign({}, lockWidthProps));
  const lockHeightProps = {
    key: "lock-height",
    className: ClassButton,
    children: orientation === Orientation.V ? icons.lock : icons.unlock,
    onClick: () => {
      const value = orientation === Orientation.V ? "" : Orientation.V;
      lock.changeHandler("lock", value);
    }
  };
  const selectedButton = [ClassSelected, ClassButton].join(" ");
  const lockHeight = import_react2.default.createElement(View, Object.assign({}, lockHeightProps));
  const startProps = {
    children: icons.start,
    className: endSelected ? ClassButton : selectedButton,
    key: "start",
    onClick: () => {
      editor.goToTime(timeRange.startTime);
      changeTweening(DataGroup.Size, false);
    }
  };
  const endProps = {
    key: "end",
    className: endSelected ? selectedButton : ClassButton,
    children: endDefined ? icons.end : icons.endUndefined,
    onClick: () => {
      editor.goToTime(timeRange.lastTime);
      changeTweening(DataGroup.Size, true);
    }
  };
  const legendElements = [
    icons.size,
    import_react2.default.createElement(
      View,
      { className: "start-end", key: `${selectType}-size-start-end` },
      import_react2.default.createElement(View, Object.assign({}, startProps)),
      import_react2.default.createElement(View, Object.assign({}, endProps))
    )
  ];
  const widthElements = [
    import_react2.default.createElement(View, { key: "width-icon", children: icons.width, className: ClassButton }),
    elementsByName.width,
    lockWidth
  ];
  const heightElements = [
    import_react2.default.createElement(View, { key: "height-icon", children: icons.height, className: ClassButton }),
    elementsByName.height,
    lockHeight
  ];
  const elements = [
    import_react2.default.createElement(View, { key: "width", children: widthElements }),
    import_react2.default.createElement(View, { key: "height", children: heightElements })
  ];
  return import_react2.default.createElement(
    "fieldset",
    null,
    import_react2.default.createElement(
      "legend",
      { key: "legend" },
      import_react2.default.createElement(View, null, legendElements)
    ),
    elements
  );
}
DataGroupInputs[DataGroup.Size] = import_react2.default.createElement(SizeGroupInput, { key: "size-group-input" });
function SizingGroupInput(props) {
  const { selectType } = props;
  assertSelectType(selectType);
  const inspectorContext = import_react2.default.useContext(InspectorContext);
  const { selectedItems: properties } = inspectorContext;
  const byName = selectedPropertyObject(properties, DataGroup.Sizing, selectType);
  const elementsByName = Object.fromEntries(Object.entries(byName).map(([key, selectedProperty]) => {
    const { property, changeHandler, selectType: selectType2, value, name: nameOveride } = selectedProperty;
    const { name: propertyName } = property;
    const name = nameOveride || propertyName;
    const propertyProps = Object.assign({ key: `inspector-${selectType2}-group-${name}`, property, value, changeHandler, name }, props);
    return [key, import_react2.default.createElement(InspectorProperty, Object.assign({}, propertyProps))];
  }));
  return import_react2.default.createElement(View, null, Object.values(elementsByName));
}
DataGroupInputs[DataGroup.Sizing] = import_react2.default.createElement(SizingGroupInput, { key: "sizing-group-input" });
function TimingGroupInput(props) {
  const masherContext = import_react2.default.useContext(MasherContext);
  const { icons } = masherContext;
  const { selectType } = props;
  assertSelectType(selectType);
  const inspectorContext = import_react2.default.useContext(InspectorContext);
  const { selectedItems: properties } = inspectorContext;
  const byName = selectedPropertyObject(properties, DataGroup.Timing, selectType);
  const elementsByName = Object.fromEntries(Object.entries(byName).map(([key, selectedProperty]) => {
    const { property, changeHandler, selectType: selectType2, value, name: nameOveride } = selectedProperty;
    const { name: propertyName } = property;
    const name = nameOveride || propertyName;
    const propertyProps = Object.assign({ key: `inspector-${selectType2}-group-${name}`, property, value, changeHandler, name }, props);
    return [key, import_react2.default.createElement(InspectorProperty, Object.assign({}, propertyProps))];
  }));
  const { timing } = elementsByName, rest = __rest2(elementsByName, ["timing"]);
  if (!isPopulatedObject(rest)) {
    const viewProps = {
      key: "timing",
      children: [icons.timing, timing],
      className: "row"
    };
    return import_react2.default.createElement(View, Object.assign({}, viewProps));
  }
  const legendElements = [icons.timing];
  if (timing)
    legendElements.push(timing);
  const elements = Object.entries(rest).map(([key, value]) => {
    const icon = icons[key];
    const children = [value];
    if (icon)
      children.unshift(import_react2.default.createElement(View, { key: `${key}-icon`, children: icon, className: ClassButton }));
    const frameProps = { key: `${key}-view`, children };
    return import_react2.default.createElement(View, Object.assign({}, frameProps));
  });
  return import_react2.default.createElement(
    "fieldset",
    null,
    import_react2.default.createElement(
      "legend",
      { key: "legend" },
      import_react2.default.createElement(View, null, legendElements)
    ),
    elements
  );
}
DataGroupInputs[DataGroup.Timing] = import_react2.default.createElement(TimingGroupInput, { key: "timing-group-input" });
function Inspector(props) {
  const editor = useEditor();
  const [actionCount, setActionCount] = import_react2.default.useState(() => 0);
  const info = import_react2.default.useRef({
    tweenDefined: {},
    tweenSelected: {},
    selectedType: SelectType.None,
    selectTypes: []
  });
  const [orderedTypes, setOrderedTypes] = import_react2.default.useState(() => SelectTypes);
  const [selectedItems, setSelectedItems] = import_react2.default.useState(() => []);
  const handleAction = () => {
    setActionCount((value) => value + 1);
  };
  const handleSelection = () => {
    const { selection } = editor;
    const { selectTypes: types, clip, mash } = selection;
    const { current } = info;
    const { selectedType, selectTypes } = current;
    const bestType = orderedTypes.find((type) => types.includes(type));
    assertSelectType(bestType);
    if (bestType !== selectedType) {
      current.selectedType = bestType;
    }
    arraySet(selectTypes, types);
    const items = editor.selection.selectedItems([bestType]);
    const tweening = {};
    if (clip && mash) {
      const tweenItems = items.filter((item) => {
        if (!isSelectedProperty(item))
          return;
        const { property, name } = item;
        const { tweenable, group } = property;
        if (!(tweenable && group && name))
          return;
        return name.endsWith(PropertyTweenSuffix);
      });
      tweenItems.forEach((item) => {
        const { property, value } = item;
        const { group } = property;
        assertDataGroup(group);
        tweening[group] = isDefined(value);
      });
      if (tweenItems.length) {
        const { time, quantize } = mash;
        const timeRange = clip.timeRange(quantize);
        current.time = time;
        current.timeRange = timeRange;
        const frame = timeRange.frame + Math.round(timeRange.frames / 2);
        const halfTime = timeFromArgs(frame, quantize);
        const [midTime, timeScaled] = timeEqualizeRates(halfTime, time);
        current.nearStart = midTime.frame > timeScaled.frame;
        const edge = current.nearStart ? timeRange.startTime : timeRange.lastTime;
        current.onEdge = time.equalsTime(edge);
      }
    }
    current.tweenDefined = tweening;
    setSelectedItems(items);
    handleAction();
  };
  useListeners({
    [EventType.Action]: handleAction,
    [EventType.Selection]: handleSelection
  });
  const changeSelected = import_react2.default.useCallback((type) => {
    assertSelectType(type);
    setOrderedTypes((original) => {
      const index = original.indexOf(type);
      assertPositive(index);
      const types = [type];
      if (index)
        types.push(...original.slice(0, index));
      if (index < original.length - 1)
        types.push(...original.slice(index + 1));
      assertTrue(types.length === original.length, "type lengths match");
      arraySet(original, types);
      handleSelection();
      return original;
    });
    info.current.selectedType = type;
    setSelectedItems(editor.selection.selectedItems([type]));
  }, []);
  const changeTweening = (group, tweening) => {
    info.current.tweenSelected[group] = tweening;
    handleSelection();
  };
  const inspectorContext = Object.assign(Object.assign({}, InspectorContextDefault), {
    actionCount,
    selectedItems,
    changeSelected,
    changeTweening,
    selectedInfo: info.current
  });
  return import_react2.default.createElement(
    InspectorContext.Provider,
    { value: inspectorContext },
    import_react2.default.createElement(View, Object.assign({}, props))
  );
}
function InspectorContent(props) {
  return import_react2.default.createElement(View, Object.assign({}, props));
}
function InspectorPicked(props) {
  const inspectorContext = import_react2.default.useContext(InspectorContext);
  const { selectedInfo } = inspectorContext;
  const { selectedType } = selectedInfo;
  const { type, types, children } = props;
  const selectTypes = propsSelectTypes(type, types);
  assertPopulatedArray(selectTypes);
  if (!selectTypes.includes(selectedType))
    return null;
  return import_react2.default.createElement(import_react2.default.Fragment, null, children);
}
function InspectorPicker(props) {
  const { id, children, className } = props;
  assertSelectType(id);
  const inspectorContext = import_react2.default.useContext(InspectorContext);
  const { changeSelected, selectedInfo } = inspectorContext;
  const { selectTypes, selectedType } = selectedInfo;
  if (!selectTypes.includes(id))
    return null;
  const onClick = () => {
    changeSelected(id);
  };
  const classes = [];
  if (isPopulatedString(className))
    classes.push(className);
  if (selectedType === id)
    classes.push(ClassSelected);
  const viewProps = { children, onClick, className: classes.join(" ") };
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
var InspectorPropsDefault = function(props = {}) {
  var _a, _b, _c, _d, _e;
  const optionsStrict = panelOptionsStrict(props);
  const { icons } = optionsStrict;
  (_a = optionsStrict.props).key || (_a.key = "inspector");
  (_b = optionsStrict.props).className || (_b.className = "panel inspector");
  (_c = optionsStrict.header).content || (_c.content = [
    icons.inspector,
    import_react2.default.createElement(
      EditorUndoButton,
      { key: "undo" },
      import_react2.default.createElement(
        Button,
        null,
        icons.undo,
        labelTranslate("undo")
      )
    ),
    import_react2.default.createElement(
      EditorRedoButton,
      { key: "redo" },
      import_react2.default.createElement(
        Button,
        null,
        icons.redo,
        labelTranslate("redo")
      )
    )
  ]);
  (_d = optionsStrict.footer).content || (_d.content = [
    import_react2.default.createElement(InspectorPicker, { key: "mash", className: ClassButton, id: "mash" }, icons.document),
    import_react2.default.createElement(InspectorPicker, { key: "cast", className: ClassButton, id: "cast" }, icons.document),
    import_react2.default.createElement(InspectorPicker, { key: "layer", className: ClassButton, id: "layer" }, icons.composer),
    import_react2.default.createElement(InspectorPicker, { key: "clip", className: ClassButton, id: "clip" }, icons.clip),
    import_react2.default.createElement(InspectorPicker, { key: "container", className: ClassButton, id: "container" }, icons.container),
    import_react2.default.createElement(InspectorPicker, { key: "content", className: ClassButton, id: "content" }, icons.content)
  ]);
  const contentChildren = [import_react2.default.createElement(InspectorProperties, { key: "properties" })];
  const types = [SelectType.Clip, SelectType.Track, SelectType.Layer];
  contentChildren.push(import_react2.default.createElement(
    ApiEnabled,
    { key: "api-enabled" },
    import_react2.default.createElement(
      InspectorPicked,
      { type: "mash", key: "inspector-mash" },
      import_react2.default.createElement(
        View,
        null,
        import_react2.default.createElement(
          RenderControl,
          { key: "render-process" },
          import_react2.default.createElement(
            Button,
            null,
            labelTranslate("render"),
            icons.render
          )
        ),
        import_react2.default.createElement(
          ViewControl,
          { key: "view-control" },
          import_react2.default.createElement(
            Button,
            null,
            labelTranslate("view"),
            icons.view
          )
        )
      )
    ),
    import_react2.default.createElement(
      InspectorPicked,
      { types: "mash,cast", key: "inspector-document" },
      import_react2.default.createElement(SelectEditedControl, { key: "select-edited", className: "row", children: icons.document }),
      import_react2.default.createElement(
        View,
        { key: "view" },
        import_react2.default.createElement(
          SaveControl,
          { key: "save-process" },
          import_react2.default.createElement(
            Button,
            { key: "button" },
            labelTranslate("update"),
            icons.document
          )
        ),
        import_react2.default.createElement(
          CreateEditedControl,
          { key: "create-edited" },
          import_react2.default.createElement(
            Button,
            null,
            labelTranslate("create"),
            icons.document
          )
        )
      )
    )
  ));
  types.forEach((type) => {
    contentChildren.push(import_react2.default.createElement(
      InspectorPicked,
      { key: `${type}-delete`, type },
      import_react2.default.createElement(
        EditorRemoveButton,
        { type },
        import_react2.default.createElement(
          Button,
          null,
          labelInterpolate("delete", { type }),
          icons.remove
        )
      )
    ));
  });
  (_e = optionsStrict.content).children || (_e.children = import_react2.default.createElement(import_react2.default.Fragment, null, contentChildren));
  const children = import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement(Bar, Object.assign({}, optionsStrict.header)),
    import_react2.default.createElement(InspectorContent, Object.assign({}, optionsStrict.content.props), optionsStrict.content.children),
    import_react2.default.createElement(Bar, Object.assign({}, optionsStrict.footer))
  );
  return Object.assign(Object.assign({}, optionsStrict.props), { children });
};
function Masher(props) {
  const { editType = EditType.Mash, previewSize, icons = {}, edited } = props, rest = __rest2(props, ["editType", "previewSize", "icons", "edited"]);
  const editorIndexRef = import_react2.default.useRef({});
  const svgRef = import_react2.default.useRef(null);
  const { current: editorIndex } = editorIndexRef;
  const [definition, setDefinition] = import_react2.default.useState();
  const ref = import_react2.default.useRef(null);
  const apiContext = import_react2.default.useContext(ApiContext);
  const [editor] = import_react2.default.useState(() => editorInstance({ editType }));
  const [requested, setRequested] = import_react2.default.useState(false);
  const [draggable, setDraggable] = import_react2.default.useState();
  const { enabled, endpointPromise, servers } = apiContext;
  import_react2.default.useEffect(() => {
    elementSetPreviewSize(ref.current, previewSize);
  }, [previewSize]);
  const editorLoad = (object) => {
    const loadObject = object || edited || { [editType]: {}, definitions: [] };
    const { previewSize: size = previewSize } = loadObject, rest2 = __rest2(loadObject, ["previewSize"]);
    const { current: svg } = svgRef;
    const { current: div } = ref;
    assertObject(svg);
    if (sizeAboveZero(size)) {
      elementSetPreviewSize(div, size);
    }
    editor.svgElement = svg;
    editor.load(rest2);
  };
  import_react2.default.useEffect(() => {
    if (!enabled) {
      editorLoad();
      return;
    }
    if (!requested && servers[ServerType.Data]) {
      setRequested(true);
      const request = {};
      const promise = endpointPromise(Endpoints.data[editType].default, request);
      promise.then((response) => {
        var _a;
        console.debug("DataDefaultResponse", Endpoints.data[editType].default, response);
        __rest2(response, ["previewSize"]);
        if ((_a = servers.file) === null || _a === void 0 ? void 0 : _a.prefix) {
          editor.preloader.endpoint.prefix = String(servers.file.prefix);
        }
        editorLoad(response);
      });
    }
  }, [servers]);
  const dropFiles = (files, editorIndex2) => {
    const fileInfos = dropFilesFromList(files, servers.file);
    if (fileInfos.length) {
      const errors = [];
      const validFiles = [];
      const { eventTarget } = editor;
      fileInfos.forEach((fileInfo) => {
        if (fileInfo instanceof File)
          validFiles.push(fileInfo);
        else
          errors.push(fileInfo);
      });
      if (errors.length) {
        errors.forEach((error) => {
          const id = idGenerate("activity-error");
          const info = Object.assign({ id, type: ActivityType.Error }, error);
          eventTarget.emit(EventType.Active, info);
        });
      }
      if (validFiles.length)
        return editor.addFiles(validFiles, editorIndex2);
    }
    return Promise.resolve([]);
  };
  const dropDefinitionObject = (definitionObject, editorIndex2) => {
    return editor.add(definitionObject, editorIndex2);
  };
  const drop = (draggable2, editorIndex2) => {
    if (!draggable2)
      return Promise.resolve([]);
    if (isClip(draggable2)) {
      return Promise.resolve([]);
    }
    if (isEffect(draggable2)) {
      return Promise.resolve([]);
    }
    if (isLayer(draggable2)) {
      return Promise.resolve([]);
    }
    if (isDefinitionObject(draggable2)) {
      return dropDefinitionObject(draggable2, editorIndex2);
    }
    if (isMashAndDefinitionsObject(draggable2)) {
      return Promise.resolve([]);
    }
    return dropFiles(draggable2, editorIndex2).then((definitions) => {
      const [definition2] = definitions;
      if (isDefinition(definition2))
        changeDefinition(definition2);
      return definitions;
    });
  };
  const delayPromise = () => new Promise((resolve) => {
    setTimeout(resolve, 2e3);
  });
  const handleApiCallback = (id, definition2, callback) => {
    console.debug("handleApiCallback request", callback);
    const { eventTarget } = editor;
    return fetchCallback(callback).then((response) => {
      console.debug("handleApiCallback response", response);
      const { apiCallback, error } = response;
      if (error)
        return handleError(callback.endpoint.prefix, error, id);
      if (apiCallback) {
        const { request, endpoint } = apiCallback;
        if (endpoint.prefix === Endpoints.data.definition.put) {
          assertObject(request);
          const { body } = request;
          assertObject(body);
          const putRequest = body;
          const { definition: definitionObject } = putRequest;
          editor.updateDefinition(definitionObject, definition2);
        }
        if (callback.endpoint.prefix === Endpoints.rendering.status) {
          const statusResponse = response;
          let steps = 0;
          let step = 0;
          OutputTypes.forEach((type) => {
            const state = statusResponse[type];
            if (!state)
              return;
            steps += state.total;
            step += state.completed;
          });
          if (steps)
            eventTarget.emit(EventType.Active, {
              id,
              step,
              steps,
              type: ActivityType.Render
            });
        }
        return delayPromise().then(() => handleApiCallback(id, definition2, apiCallback));
      }
      eventTarget.emit(EventType.Active, { id, type: ActivityType.Complete });
    });
  };
  const handleError = (endpoint, error, id) => {
    editor.eventTarget.emit(EventType.Active, {
      id,
      type: ActivityType.Error,
      error: "import.render",
      value: error
    });
    console.error(endpoint, error);
    return Promise.reject(error);
  };
  const saveDefinitionsPromise = (definitions) => {
    let promise = Promise.resolve();
    const { eventTarget } = editor;
    definitions.forEach((definition2) => {
      assertPreloadableDefinition(definition2);
      const { label, type, source } = definition2;
      const id = idGenerate("activity");
      eventTarget.emit(EventType.Active, { id, label, type: ActivityType.Render });
      const { rendering } = Endpoints;
      const responsePromise = fetch(source);
      const blobPromise = responsePromise.then((response) => response.blob());
      const filePromise = blobPromise.then((blob) => new File([blob], label));
      const callbackPromise = filePromise.then((file) => {
        const request = { type, name: label, size: file.size };
        console.debug("RenderingUploadRequest", rendering.upload, request);
        const responsePromise2 = endpointPromise(rendering.upload, request);
        return responsePromise2.then((response) => {
          console.debug("RenderingUploadResponse", rendering.upload, response);
          const { error, fileApiCallback, apiCallback, fileProperty } = response;
          if (error)
            return handleError(rendering.upload, error, id);
          else if (fileApiCallback && fileApiCallback.request) {
            if (fileProperty)
              fileApiCallback.request.body[fileProperty] = file;
            else
              fileApiCallback.request.body = file;
            return fetchCallback(fileApiCallback).then((response2) => {
              console.debug("FileStoreResponse", response2);
              const { error: error2 } = response2;
              if (error2)
                return handleError(fileApiCallback.endpoint.prefix, error2, id);
              assertObject(apiCallback);
              return handleApiCallback(id, definition2, apiCallback);
            });
          }
          assertObject(apiCallback);
          return handleApiCallback(id, definition2, apiCallback);
        });
      });
      promise = promise.then(() => callbackPromise);
    });
    return promise;
  };
  const save = () => __awaiter(this, void 0, void 0, function* () {
    const { definitionsUnsaved } = editor;
    const definitionsPromise = saveDefinitionsPromise(definitionsUnsaved);
    const requestPromise = definitionsPromise.then(() => editor.dataPutRequest());
    const savePromise = requestPromise.then((request) => {
      const { editType: editType2 } = editor;
      console.debug("DataPutRequest", Endpoints.data[editType2].put, JSON.parse(JSON.stringify(request)));
      endpointPromise(Endpoints.data[editType2].put, request).then((response) => {
        console.debug("DataPutResponse", Endpoints.data[editType2].put, response);
        const { error, temporaryIdLookup } = response;
        if (error)
          console.error(Endpoints.data[editType2].put, error);
        else
          editor.saved(temporaryIdLookup);
      });
    });
    yield savePromise;
  });
  const changeDefinition = (definition2) => {
    setDefinition(definition2);
  };
  const editorContext = {
    editor,
    draggable,
    setDraggable,
    save,
    editorIndex,
    drop,
    definition,
    changeDefinition,
    icons
  };
  const viewProps = Object.assign(Object.assign({}, rest), { onDrop: eventStop, ref });
  return import_react2.default.createElement(
    MasherContext.Provider,
    { value: editorContext },
    import_react2.default.createElement(View, Object.assign({}, viewProps)),
    import_react2.default.createElement("svg", { style: { display: "none" }, ref: svgRef })
  );
}
var PlayerContextDefault = {
  paused: false,
  changePaused: EmptyMethod,
  changeVolume: EmptyMethod,
  volume: 0
};
var PlayerContext = import_react2.default.createContext(PlayerContextDefault);
var PlayerRefreshRate = 10;
function PlayerContent(props) {
  const { children, className } = props, rest = __rest2(props, ["children", "className"]);
  const editor = useEditor();
  const [rect, setRect] = import_react2.default.useState(() => rectCopy(editor.rect));
  const svgRef = import_react2.default.useRef(null);
  const viewRef = import_react2.default.useRef(null);
  const masherContext = import_react2.default.useContext(MasherContext);
  const [over, setOver] = import_react2.default.useState(false);
  const playerContext = import_react2.default.useContext(PlayerContext);
  const { disabled } = playerContext;
  const { drop } = masherContext;
  const watchingRef = import_react2.default.useRef({});
  const { current: watching } = watchingRef;
  const handleResize = () => {
    const { current } = viewRef;
    if (!current)
      return;
    const rect2 = rectRound(current.getBoundingClientRect());
    setRect(() => {
      editor.rect = rect2;
      return rectCopy(rect2);
    });
  };
  const [resizeObserver] = import_react2.default.useState(new ResizeObserver(handleResize));
  import_react2.default.useEffect(() => {
    const { current } = viewRef;
    if (current)
      resizeObserver.observe(current);
    return () => {
      resizeObserver.disconnect();
    };
  }, []);
  const swapChildren = (elements) => {
    const { current } = svgRef;
    if (!current)
      return;
    current.replaceChildren(...elements);
  };
  const requestItemsPromise = () => {
    const { redraw } = watching;
    delete watching.timeout;
    delete watching.redraw;
    return editor.previewItems(!disabled).then((svgs) => {
      swapChildren(svgs);
      if (redraw)
        handleDraw();
    });
  };
  const requestItems = () => {
    requestItemsPromise().then(EmptyMethod);
  };
  const handleDraw = () => {
    const { current } = svgRef;
    const { rect: rect2 } = editor;
    if (!(current && sizeAboveZero(rect2)))
      return;
    if (watching.timeout) {
      watching.redraw = true;
      return;
    }
    watching.timeout = setTimeout(requestItems, PlayerRefreshRate);
  };
  useListeners({ [EventType.Draw]: handleDraw, [EventType.Selection]: handleDraw });
  const dragValid = (dataTransfer) => {
    if (!dataTransfer)
      return false;
    const types = dragTypes(dataTransfer);
    if (types.includes(TransferTypeFiles))
      return true;
    return isDefinitionType(dragType(dataTransfer));
  };
  const onDragLeave = (event) => {
    eventStop(event);
    setOver(false);
  };
  const onDrop = (event) => {
    onDragLeave(event);
    const { dataTransfer } = event;
    if (!dragValid(dataTransfer))
      return;
    const { edited } = editor;
    assertObject(edited);
    const editorIndex = {
      clip: editor.time.scale(edited.quantize).frame,
      track: -1
    };
    const types = dragTypes(dataTransfer);
    if (types.includes(TransferTypeFiles)) {
      drop(dataTransfer.files, editorIndex);
    } else {
      const type = dragType(dataTransfer);
      assertDefinitionType(type);
      const data = dragData(dataTransfer, type);
      assertDragDefinitionObject(data);
      drop(data.definitionObject, editorIndex);
    }
  };
  const onDragOver = (event) => {
    eventStop(event);
    setOver(dragValid(event.dataTransfer));
  };
  const classes = [];
  if (className)
    classes.push(className);
  if (over)
    classes.push(ClassDropping);
  const viewProps = Object.assign(Object.assign({}, rest), { ref: viewRef, className: classes.join(" "), key: "player-content", onDragOver, onDrop, onDragLeave, onPointerDown: () => {
    editor.selection.unset(SelectType.Clip);
  } });
  if (sizeAboveZero(rect)) {
    const svgProps = { ref: svgRef, key: "svg", className: "svgs" };
    const nodes = [import_react2.default.createElement("div", Object.assign({}, svgProps))];
    if (children) {
      const child = import_react2.default.Children.only(children);
      if (import_react2.default.isValidElement(child))
        nodes.push(child);
    }
    viewProps.children = nodes;
  }
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
function PlayerButton(props) {
  const playerContext = import_react2.default.useContext(PlayerContext);
  const { paused, changePaused: setPaused } = playerContext;
  const onClick = () => {
    setPaused(!paused);
  };
  const viewProps = Object.assign(Object.assign({}, props), { key: "player-button", onClick });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
function PlayerTimeControl(props) {
  const editor = useEditor();
  const getTimeRange = () => editor.timeRange.timeRange;
  const [timeRange, setTimeRange] = import_react2.default.useState(getTimeRange);
  const update = () => {
    setTimeRange(getTimeRange());
  };
  useListeners({
    [EventType.Time]: update,
    [EventType.Duration]: update
  }, editor.eventTarget);
  const onChange = (_event, values) => {
    const number = isArray(values) ? values[0] : values;
    editor.time = timeFromArgs(number, timeRange.fps);
  };
  const sliderProps = Object.assign({ value: timeRange.frame, min: 0, max: timeRange.frames, step: 1, onChange, className: "frame slider" }, props);
  return import_react2.default.createElement(Slider, Object.assign({}, sliderProps));
}
function PlayerPlaying(props) {
  const playerContext = import_react2.default.useContext(PlayerContext);
  if (playerContext.paused)
    return null;
  return props.children;
}
function PlayerNotPlaying(props) {
  const playerContext = import_react2.default.useContext(PlayerContext);
  if (!playerContext.paused)
    return null;
  return props.children;
}
function PlayerTime(props) {
  const editor = useEditor();
  const getTimeRange = () => editor.timeRange;
  const [timeRange, setTimeRange] = import_react2.default.useState(getTimeRange);
  const update = () => {
    setTimeRange(getTimeRange());
  };
  useListeners({
    [EventType.Time]: update,
    [EventType.Duration]: update
  }, editor.eventTarget);
  const { seconds, fps, lengthSeconds } = timeRange;
  const viewChildren = [
    stringSeconds(seconds, fps, lengthSeconds),
    "/",
    stringSeconds(lengthSeconds, fps, lengthSeconds)
  ];
  const viewProps = Object.assign(Object.assign({}, props), { key: "player-time", children: viewChildren });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
var DefaultPlayerProps = function(props = {}) {
  var _a, _b, _c, _d, _e;
  const optionsStrict = panelOptionsStrict(props);
  const { icons } = optionsStrict;
  (_a = optionsStrict.props).key || (_a.key = "player");
  (_b = optionsStrict.props).className || (_b.className = "panel player");
  (_c = optionsStrict.content).children || (_c.children = import_react2.default.createElement(
    PlayerContent,
    Object.assign({}, optionsStrict.content.props),
    import_react2.default.createElement(View, { key: "drop-box", className: "drop-box" })
  ));
  (_d = optionsStrict.header).content || (_d.content = [icons.app]);
  (_e = optionsStrict.footer).content || (_e.content = [
    import_react2.default.createElement(
      PlayerButton,
      { key: "play-button", className: ClassButton },
      import_react2.default.createElement(PlayerPlaying, { key: "playing" }, icons.playerPause),
      import_react2.default.createElement(PlayerNotPlaying, { key: "not-playing" }, icons.playerPlay)
    ),
    import_react2.default.createElement(PlayerTimeControl, { key: "time-slider" }),
    import_react2.default.createElement(PlayerTime, { key: "time", className: "time" })
  ]);
  const children = import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement(Bar, Object.assign({}, optionsStrict.header)),
    optionsStrict.content.children,
    import_react2.default.createElement(Bar, Object.assign({}, optionsStrict.footer))
  );
  return Object.assign(Object.assign({}, optionsStrict.props), { children });
};
function TimelineScrubberElement(props) {
  const timelineContext = import_react2.default.useContext(TimelineContext);
  const { scale, frame } = timelineContext;
  const calculateViewProps = () => {
    const viewProps2 = Object.assign(Object.assign({}, props), { style: { left: pixelFromFrame(frame, scale) } });
    return viewProps2;
  };
  const viewProps = import_react2.default.useMemo(calculateViewProps, [frame, scale]);
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
function TimelineTrack(props) {
  const editor = useEditor();
  const { selection } = editor;
  const { mash } = selection;
  const { className: propsClassName, children } = props, rest = __rest2(props, ["className", "children"]);
  const child = import_react2.default.Children.only(children);
  assertTrue(import_react2.default.isValidElement(child));
  const trackContext = import_react2.default.useContext(TrackContext);
  const timelineContext = import_react2.default.useContext(TimelineContext);
  const { track } = trackContext;
  const { dragTypeValid, onDragLeave, onDrop, droppingTrack, setDroppingTrack, droppingPosition, setDroppingPosition, setDroppingClip, selectedTrack } = timelineContext;
  const calculatedClassName = () => {
    const selected = track === selectedTrack;
    const classes = [];
    if (propsClassName)
      classes.push(propsClassName);
    if (selected)
      classes.push(ClassSelected);
    if (droppingTrack === track)
      classes.push(droppingPositionClass(droppingPosition));
    return classes.join(" ");
  };
  const className = import_react2.default.useMemo(calculatedClassName, [droppingPosition, droppingTrack, selectedTrack]);
  if (!(mash && track))
    return null;
  const { clips, dense, index } = track;
  const childNodes = () => {
    let prevClipEnd = dense ? -1 : 0;
    const childProps = child.props;
    return clips.map((clip) => {
      const cloneProps = Object.assign(Object.assign({}, childProps), { key: clip.id });
      const children2 = import_react2.default.cloneElement(child, cloneProps);
      const contextProps = { children: children2, value: { clip, prevClipEnd }, key: clip.id };
      const context = import_react2.default.createElement(ClipContext.Provider, Object.assign({}, contextProps));
      if (!dense)
        prevClipEnd = clip.frames + clip.frame;
      return context;
    });
  };
  const onDragOver = (event) => {
    eventStop(event);
    const { dataTransfer } = event;
    if (!dataTransfer)
      return;
    const definitionType = dragTypeValid(dataTransfer);
    const pos = definitionType ? DroppingPosition.At : DroppingPosition.None;
    setDroppingClip();
    setDroppingTrack(definitionType ? track : void 0);
    setDroppingPosition(pos);
  };
  const viewProps = Object.assign(Object.assign({}, rest), { className, children: childNodes(), onDragLeave, onDragOver, onDrop, key: `track-${index}` });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
function TimelineSizer(props) {
  const ref = import_react2.default.useRef(null);
  const timelineContext = import_react2.default.useContext(TimelineContext);
  const handleResize = () => {
    const { setRect } = timelineContext;
    const rect = ref.current.getBoundingClientRect();
    setRect(rect);
  };
  const [resizeObserver] = import_react2.default.useState(new ResizeObserver(handleResize));
  import_react2.default.useEffect(() => {
    const { current } = ref;
    if (current)
      resizeObserver.observe(current);
    return () => {
      resizeObserver.disconnect();
    };
  }, [ref.current]);
  const viewProps = Object.assign(Object.assign({}, props), { ref });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
function TimelineZoomer(props) {
  const editor = useEditor();
  const timelineContext = import_react2.default.useContext(TimelineContext);
  const getDisabled = () => !editor.selection.mash;
  const [disabled, setDisabled] = import_react2.default.useState(getDisabled);
  const updateDisabled = () => {
    setDisabled(getDisabled());
  };
  useListeners({ [EventType.Selection]: updateDisabled });
  const handleChange = (_event, values) => {
    const number = isArray(values) ? values[0] : values;
    if (timelineContext.zoom !== number)
      timelineContext.setZoom(number);
  };
  const sliderProps = Object.assign({ disabled, key: "time-slider", value: timelineContext.zoom, min: 0, max: 1, step: 0.01, onChange: handleChange }, props);
  return import_react2.default.createElement(Slider, Object.assign({ className: "zoom slider" }, sliderProps));
}
function TimelineTracks(props) {
  const [refresh, setRefreshed] = import_react2.default.useState(() => 0);
  const updateRefreshed = () => {
    setRefreshed((nonce) => nonce + 1);
  };
  const editor = useEditor();
  useListeners({
    [EventType.Mash]: updateRefreshed,
    [EventType.Track]: updateRefreshed
  });
  const { children } = props;
  const childNodes = () => {
    const { mash } = editor.selection;
    if (!mash)
      return [];
    const { tracks } = mash;
    const reversedTracks = arrayReversed(tracks);
    return reversedTracks.map((track, i) => {
      const { identifier, index } = track;
      const clones = import_react2.default.Children.map(children, (child) => {
        if (!import_react2.default.isValidElement(child))
          throw `TimelineTracks`;
        return import_react2.default.cloneElement(child, {
          key: `track-clone-${i}-${index}-${identifier}`
        });
      });
      const contextProps = {
        children: clones,
        value: { track },
        key: `track-context-${i}-${index}-${identifier}`
      };
      return import_react2.default.createElement(TrackContext.Provider, Object.assign({}, contextProps));
    });
  };
  const viewChildren = import_react2.default.useMemo(childNodes, [refresh]);
  const fragmentProps = {
    key: `track-content`,
    children: viewChildren
  };
  return import_react2.default.createElement(import_react2.default.Fragment, Object.assign({}, fragmentProps));
}
function TimelineScrubber(props) {
  const editor = useEditor();
  const clientXRef = import_react2.default.useRef(-1);
  const ref = import_react2.default.useRef(null);
  const timelineContext = import_react2.default.useContext(TimelineContext);
  const { frames, scale, rect } = timelineContext;
  const { className, inactive, styleHeight, styleWidth } = props, rest = __rest2(props, ["className", "inactive", "styleHeight", "styleWidth"]);
  const getDisabled = () => !editor.selection.mash;
  const [disabled, setDisabled] = import_react2.default.useState(getDisabled);
  const updateDisabled = () => {
    setDisabled(getDisabled());
  };
  useListeners({ [EventType.Selection]: updateDisabled });
  const addHandlers = () => {
    const { window: window2 } = globalThis;
    const removeWindowHandlers = () => {
      window2.removeEventListener("pointermove", pointerMove);
      window2.removeEventListener("pointerup", pointerUp);
    };
    const pointerMove = (event) => {
      eventStop(event);
      const { current } = ref;
      if (!(current && editor.selection.mash))
        return;
      const { clientX } = event;
      if (clientXRef.current === clientX)
        return;
      clientXRef.current = clientX;
      const rect2 = current.getBoundingClientRect();
      const pixel = Math.max(0, Math.min(rect2.width, clientX - rect2.x));
      const frame = pixelToFrame(pixel, scale, "floor");
      editor.time = timeFromArgs(frame, editor.selection.mash.quantize);
    };
    const pointerUp = (event) => {
      pointerMove(event);
      removeWindowHandlers();
    };
    const pointerDown = (event) => {
      event.stopPropagation();
      clientXRef.current = -1;
      window2.addEventListener("pointermove", pointerMove);
      window2.addEventListener("pointerup", pointerUp);
      pointerMove(event);
    };
    return pointerDown;
  };
  const { width, height } = rect;
  const calculateViewProps = () => {
    const classes = [];
    if (className)
      classes.push(className);
    if (disabled)
      classes.push(ClassDisabled);
    const viewProps2 = Object.assign(Object.assign({}, rest), { ref, className: classes.join(" ") });
    if (styleWidth || styleHeight) {
      const style = {};
      if (styleHeight)
        style.minHeight = height;
      if (styleWidth) {
        const width2 = pixelFromFrame(frames, scale, "ceil");
        style.minWidth = Math.max(width2, width2);
      }
      viewProps2.style = style;
    }
    if (!(inactive || disabled))
      viewProps2.onPointerDown = addHandlers();
    return viewProps2;
  };
  const viewProps = import_react2.default.useMemo(calculateViewProps, [frames, scale, width, height, disabled]);
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
function TimelineContent(props) {
  const { className } = props, rest = __rest2(props, ["className"]);
  const timelineContext = import_react2.default.useContext(TimelineContext);
  const { dragTypeValid, onDrop: contextDrop, setScroll, setDroppingClip, setDroppingTrack, setDroppingPosition } = timelineContext;
  const ref = import_react2.default.useRef(null);
  const [over, setOver] = import_react2.default.useState(false);
  const editor = useEditor();
  const resetScroll = () => {
    var _a;
    (_a = ref.current) === null || _a === void 0 ? void 0 : _a.scrollTo(0, 0);
  };
  useListeners({ [EventType.Mash]: resetScroll });
  const onPointerDown = (event) => {
    editor.selection.unset(SelectType.Track);
  };
  const onScroll = () => {
    const { current } = ref;
    if (!current)
      return;
    const { scrollLeft: x, scrollTop: y } = current;
    setScroll({ x, y });
  };
  const onDragLeave = (event) => {
    eventStop(event);
    setOver(false);
  };
  const onDrop = (event) => {
    onDragLeave(event);
    contextDrop(event);
  };
  const onDragOver = (event) => {
    eventStop(event);
    const { dataTransfer } = event;
    if (!dataTransfer)
      return;
    const valid = dragTypeValid(dataTransfer);
    const pos = valid ? DroppingPosition.At : DroppingPosition.None;
    setDroppingClip();
    setDroppingTrack();
    setDroppingPosition(pos);
    setOver(valid);
  };
  const classes = [];
  if (className)
    classes.push(className);
  if (over)
    classes.push(ClassDropping);
  const viewProps = Object.assign(Object.assign({ className: classes.join(" ") }, rest), { onPointerDown, onScroll, onDragOver, onDragLeave, onDrop, ref });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
function TimelineAddTrackControl(props) {
  const editor = useEditor();
  const getDisabled = () => !editor.selection.mash;
  const [disabled, setDisabled] = import_react2.default.useState(getDisabled);
  const updateDisabled = () => {
    setDisabled(getDisabled());
  };
  useListeners({ [EventType.Selection]: updateDisabled });
  const { children } = props, rest = __rest2(props, ["children"]);
  const cloneProps = Object.assign(Object.assign({}, rest), { disabled });
  cloneProps.onClick = () => {
    editor.addTrack();
  };
  return import_react2.default.cloneElement(import_react2.default.Children.only(children), cloneProps);
}
function TimelineTrackIcon(props) {
  const { className: propsClassName, icons } = props, rest = __rest2(props, ["className", "icons"]);
  const timelineContext = import_react2.default.useContext(TimelineContext);
  const trackContext = import_react2.default.useContext(TrackContext);
  const { droppingTrack, droppingPosition, selectedTrack } = timelineContext;
  const { track } = trackContext;
  const calculatedClassName = () => {
    const classes = [];
    if (propsClassName)
      classes.push(propsClassName);
    if (track === selectedTrack)
      classes.push(ClassSelected);
    if (track === droppingTrack)
      classes.push(droppingPositionClass(droppingPosition));
    return classes.join(" ");
  };
  const className = import_react2.default.useMemo(calculatedClassName, [droppingPosition, droppingTrack, selectedTrack]);
  if (!track)
    return null;
  const { dense, index } = track;
  const children = dense ? icons.trackDense : icons.track;
  const viewProps = Object.assign(Object.assign({}, rest), { className, children, key: `track-icon-${index}` });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
function TimelineZoom(props) {
  const editor = useEditor();
  const { zoom, children } = props, rest = __rest2(props, ["zoom", "children"]);
  const timelineContext = import_react2.default.useContext(TimelineContext);
  const getDisabled = () => !editor.selection.mash;
  const [disabled, setDisabled] = import_react2.default.useState(getDisabled);
  const updateDisabled = () => {
    setDisabled(getDisabled());
  };
  useListeners({ [EventType.Selection]: updateDisabled });
  const onClick = () => {
    timelineContext.setZoom(zoom);
  };
  const buttonOptions = Object.assign(Object.assign({}, rest), { onClick, disabled });
  return import_react2.default.cloneElement(import_react2.default.Children.only(children), buttonOptions);
}
function TimelineAddClipControl(props) {
  const editor = useEditor();
  const editorContext = import_react2.default.useContext(MasherContext);
  const { definition, drop } = editorContext;
  const getDisabled = () => !editor.selection.mash;
  const [disabled, setDisabled] = import_react2.default.useState(getDisabled);
  const updateDisabled = () => {
    setDisabled(getDisabled());
  };
  useListeners({ [EventType.Selection]: updateDisabled });
  const { children } = props, rest = __rest2(props, ["children"]);
  const cloneProps = Object.assign(Object.assign({}, rest), { disabled });
  cloneProps.onClick = () => {
    const { selection, edited } = editor;
    const { clip, track } = selection;
    const object = (definition === null || definition === void 0 ? void 0 : definition.toJSON()) || { id: DefaultContentId };
    const editorIndex = {
      clip: 0,
      track: -1
    };
    if (clip && track) {
      editorIndex.clip = track.dense ? track.clips.indexOf(clip) : clip.endFrame;
      editorIndex.track = track.index;
    } else {
      editorIndex.clip = editor.time.scale(edited.quantize).frame;
    }
    drop(object, editorIndex);
  };
  return import_react2.default.cloneElement(import_react2.default.Children.only(children), cloneProps);
}
var DefaultTimelineProps = function(props = {}) {
  var _a, _b, _c, _d, _e;
  const optionsStrict = panelOptionsStrict(props);
  const { icons } = optionsStrict;
  (_a = optionsStrict.props).key || (_a.key = "timeline");
  (_b = optionsStrict.props).className || (_b.className = "panel timeline");
  (_c = optionsStrict.header).content || (_c.content = [icons.timeline]);
  (_d = optionsStrict.footer).content || (_d.content = [
    import_react2.default.createElement(
      TimelineAddClipControl,
      { key: "add-clip" },
      import_react2.default.createElement(Button, { children: icons.add })
    ),
    import_react2.default.createElement(
      TimelineAddTrackControl,
      { key: "add-track" },
      import_react2.default.createElement(Button, { children: [icons.add, icons.trackDense] })
    ),
    import_react2.default.createElement(
      TimelineZoom,
      { key: "zoom-out", zoom: 0 },
      import_react2.default.createElement(Button, { useView: true }, icons.zoomLess)
    ),
    import_react2.default.createElement(TimelineZoomer, { key: "zoomer" }),
    import_react2.default.createElement(
      TimelineZoom,
      { key: "zoom-in", zoom: 1 },
      import_react2.default.createElement(Button, { useView: true }, icons.zoomMore)
    )
  ]);
  (_e = optionsStrict.content).children || (_e.children = import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement(
      TimelineScrubber,
      { styleWidth: true, inactive: true, styleHeight: true, className: "scrubber-bar" },
      import_react2.default.createElement(TimelineScrubberElement, { className: "scrubber-element-bar" })
    ),
    import_react2.default.createElement(
      TimelineScrubber,
      { styleWidth: true, className: "scrubber-icon" },
      import_react2.default.createElement(TimelineScrubberElement, { className: "scrubber-element-icon" })
    ),
    import_react2.default.createElement(
      TimelineTracks,
      null,
      import_react2.default.createElement(TimelineTrackIcon, { className: "track-icon", icons }),
      import_react2.default.createElement(
        TimelineTrack,
        { className: "track" },
        import_react2.default.createElement(ClipItem, { className: "clip preview" })
      )
    ),
    import_react2.default.createElement(TimelineSizer, { className: "drop-box" })
  ));
  const children = import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement(Bar, Object.assign({}, optionsStrict.header)),
    import_react2.default.createElement(TimelineContent, Object.assign({}, optionsStrict.content.props), optionsStrict.content.children),
    import_react2.default.createElement(Bar, Object.assign({}, optionsStrict.footer))
  );
  return Object.assign(Object.assign({}, optionsStrict.props), { children });
};
function Player(props) {
  const { disabled } = props, rest = __rest2(props, ["disabled"]);
  const editor = useEditor();
  const [paused, setPaused] = import_react2.default.useState(editor.paused);
  const [volume, setVolume] = import_react2.default.useState(editor.volume);
  const updatePaused = () => {
    setPaused(editor.paused);
  };
  useListeners({
    [EventType.Pause]: updatePaused,
    [EventType.Play]: updatePaused,
    [EventType.Volume]: () => {
      setVolume(editor.volume);
    }
  });
  const changePaused = (value) => {
    editor.paused = value;
  };
  const changeVolume = (value) => {
    editor.volume = value;
  };
  const playerContext = {
    paused,
    disabled,
    volume,
    changePaused,
    changeVolume
  };
  const contextProps = {
    value: playerContext,
    children: import_react2.default.createElement(View, Object.assign({}, rest))
  };
  return import_react2.default.createElement(PlayerContext.Provider, Object.assign({}, contextProps));
}
var TimelineDefaultZoom = 1;
function Timeline(props) {
  const editor = useEditor();
  const editorContext = import_react2.default.useContext(MasherContext);
  const { drop } = editorContext;
  const currentFrame = () => {
    var _a;
    return ((_a = editor.selection.mash) === null || _a === void 0 ? void 0 : _a.frame) || 0;
  };
  const currentFrames = () => {
    var _a;
    return ((_a = editor.selection.mash) === null || _a === void 0 ? void 0 : _a.frames) || 0;
  };
  const [frames, setFrames] = import_react2.default.useState(currentFrames);
  const [frame, setFrame] = import_react2.default.useState(currentFrame);
  const updateFrames = () => {
    setFrames(currentFrames());
  };
  const updateFrame = () => {
    setFrame(currentFrame());
  };
  const [droppingPosition, setDroppingPosition] = import_react2.default.useState(DroppingPosition.None);
  const [droppingTrack, setDroppingTrack] = import_react2.default.useState();
  const [droppingClip, setDroppingClip] = import_react2.default.useState();
  const [selectedTrack, setSelectedTrack] = import_react2.default.useState();
  const [refreshed, setRefreshed] = import_react2.default.useState(0);
  const [selectedClip, setSelectedClip] = import_react2.default.useState();
  const [zoom, setZoom] = import_react2.default.useState(TimelineDefaultZoom);
  const [rect, setRect] = import_react2.default.useState(RectZero);
  const [scroll, setScroll] = import_react2.default.useState(RectZero);
  const refresh = () => {
    setRefreshed((value) => value + 1);
  };
  useListeners({
    [EventType.Mash]: () => {
      setZoom(TimelineDefaultZoom);
    },
    [EventType.Action]: refresh,
    [EventType.Selection]: () => {
      setSelectedClip(editor.selection.clip);
      setSelectedTrack(editor.selection.track);
    },
    [EventType.Time]: updateFrame,
    [EventType.Duration]: updateFrames
  }, editor.eventTarget);
  const dragTypeValid = (dataTransfer, clip) => {
    const types = dragTypes(dataTransfer);
    if (types.includes(TransferTypeFiles))
      return true;
    const type = types.find(isTransferType);
    if (!type)
      return false;
    if (clip)
      return true;
    const definitionType = dragDefinitionType(type);
    return definitionType !== DefinitionType.Effect;
  };
  const onDragLeave = (event) => {
    eventStop(event);
    setDroppingPosition(DroppingPosition.None);
    setDroppingTrack(void 0);
    setDroppingClip(void 0);
  };
  const frameToIndex = (frame2, clips) => {
    const { length } = clips;
    if (!length)
      return 0;
    const foundIndex = clips.findIndex((clip) => frame2 < clip.frame + clip.frames);
    if (foundIndex > -1)
      return foundIndex;
    return length;
  };
  const dropIndex = (dense, clips) => {
    if (!dense)
      return -1;
    if (!droppingClip)
      return 0;
    const clipIndex = clips.indexOf(droppingClip);
    if (droppingPosition === DroppingPosition.After)
      return clipIndex + 1;
    return clipIndex;
  };
  const onDrop = (event) => {
    eventStop(event);
    const { dataTransfer, clientX } = event;
    if (!(dataTransfer && dragTypeValid(dataTransfer, droppingClip))) {
      console.log("Timeline onDrop invalid", dataTransfer === null || dataTransfer === void 0 ? void 0 : dataTransfer.types, !!droppingClip);
      return;
    }
    const types = dragTypes(dataTransfer);
    const droppingFiles = types.includes(TransferTypeFiles);
    const dense = !!(droppingTrack === null || droppingTrack === void 0 ? void 0 : droppingTrack.dense);
    const index = droppingTrack ? droppingTrack.index : -1;
    const clips = (droppingTrack === null || droppingTrack === void 0 ? void 0 : droppingTrack.clips) || [];
    const data = droppingFiles ? {} : dragData(dataTransfer);
    const draggingItem = !droppingFiles && isDragOffsetObject(data);
    const offset = draggingItem ? data.offset : 0;
    let indexDrop = dropIndex(dense, clips);
    if (!isPositive(indexDrop)) {
      const offsetDrop = clientX - rect.x;
      const frame2 = pixelToFrame(Math.max(0, scroll.x + (offsetDrop - offset)), scale);
      indexDrop = dense ? frameToIndex(frame2, clips) : frame2;
    }
    const editorIndex = { clip: indexDrop, track: index };
    if (droppingFiles) {
      drop(dataTransfer.files, editorIndex);
    } else if (draggingItem) {
      if (isDragDefinitionObject(data)) {
        const { definitionObject } = data;
        drop(definitionObject, editorIndex);
      } else {
        const { clip } = editor.selection;
        assertClip(clip);
        editor.moveClip(clip, editorIndex);
      }
    }
    onDragLeave(event);
  };
  const { width } = rect;
  const calculatedScale = () => {
    const scale2 = width ? pixelPerFrame(frames, width, zoom) : 0;
    return scale2;
  };
  const scale = import_react2.default.useMemo(calculatedScale, [zoom, width, frames]);
  const timelineContext = {
    scroll,
    setScroll,
    scale,
    refreshed,
    refresh,
    zoom,
    setZoom,
    rect,
    setRect,
    droppingTrack,
    setDroppingTrack,
    droppingClip,
    setDroppingClip,
    droppingPosition,
    setDroppingPosition,
    onDragLeave,
    onDrop,
    dragTypeValid,
    selectedClip,
    selectedTrack,
    frame,
    frames
  };
  const contextProps = {
    children: import_react2.default.createElement(View, Object.assign({}, props)),
    value: timelineContext
  };
  return import_react2.default.createElement(TimelineContext.Provider, Object.assign({}, contextProps));
}
function Panels(props) {
  return import_react2.default.createElement(View, Object.assign({}, props));
}
var MasherDefaultProps = function(options = {}) {
  options.className || (options.className = "editor masher");
  options.icons || (options.icons = Icons);
  const { panels = {} } = options, rest = __rest2(options, ["panels"]);
  const { player = {}, browser = {}, timeline = {}, inspector = {}, activity = {} } = panels;
  const masherChildren = [];
  if (player) {
    player.icons || (player.icons = options.icons);
    masherChildren.push(import_react2.default.createElement(Player, Object.assign({}, DefaultPlayerProps(player))));
  }
  if (browser) {
    browser.icons || (browser.icons = options.icons);
    masherChildren.push(import_react2.default.createElement(Browser, Object.assign({}, BrowserPropsDefault(browser))));
  }
  if (inspector || activity) {
    const panelsChildren = [];
    if (inspector) {
      inspector.icons || (inspector.icons = options.icons);
      panelsChildren.push(import_react2.default.createElement(Inspector, Object.assign({}, InspectorPropsDefault(inspector))));
    }
    if (activity) {
      activity.icons || (activity.icons = options.icons);
      panelsChildren.push(import_react2.default.createElement(Activity, Object.assign({}, ActivityPropsDefault(activity))));
    }
    const panelsProps = {
      children: panelsChildren,
      key: "panels",
      className: "panels"
    };
    masherChildren.push(import_react2.default.createElement(Panels, Object.assign({}, panelsProps)));
  }
  if (timeline) {
    timeline.icons || (timeline.icons = options.icons);
    masherChildren.push(import_react2.default.createElement(Timeline, Object.assign({}, DefaultTimelineProps(timeline))));
  }
  return Object.assign(Object.assign({ className: "editor masher" }, rest), { editType: EditType.Mash, children: masherChildren });
};
var MasherCastProps = function(props = {}) {
  props.className || (props.className = "editor caster");
  const mashProps = MasherDefaultProps(props);
  const { panels = {} } = props;
  const { composer = {} } = panels;
  if (!composer)
    return mashProps;
  composer.icons || (composer.icons = props.icons);
  const children = import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    mashProps.children,
    import_react2.default.createElement(Composer, Object.assign({}, DefaultComposerProps(composer)))
  );
  return Object.assign(Object.assign({}, mashProps), { children, editType: EditType.Cast });
};
function PanelContent(props) {
  const { children, className } = props;
  if (!children)
    return null;
  const viewProps = { className, children };
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
function PanelHead(props) {
  const { children, className } = props;
  if (!children)
    return null;
  const viewProps = { className, children };
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
function Process(props) {
  const apiContext = import_react2.default.useContext(ApiContext);
  const [processing, setProcessing] = import_react2.default.useState(false);
  const [progress, setProgress] = import_react2.default.useState(0);
  const [status, setStatus] = import_react2.default.useState("");
  const [error, setError] = import_react2.default.useState("");
  const { children, id } = props;
  const { enabled, servers } = apiContext;
  if (!ServerTypes.map(String).includes(id))
    return null;
  const serverType = id;
  if (!(enabled && servers[serverType]))
    return null;
  const processContext = {
    processing,
    setProcessing,
    status,
    setStatus,
    progress,
    setProgress,
    error,
    setError
  };
  return import_react2.default.createElement(ProcessContext.Provider, { value: processContext }, children);
}
function ProcessActive(props) {
  const processContext = import_react2.default.useContext(ProcessContext);
  const { processing, error } = processContext;
  if (!(processing || error))
    return import_react2.default.createElement(View, null);
  return import_react2.default.createElement(import_react2.default.Fragment, null, props.children);
}
function ProcessInactive(props) {
  const processContext = import_react2.default.useContext(ProcessContext);
  if (processContext.processing)
    return null;
  return import_react2.default.createElement(import_react2.default.Fragment, null, props.children);
}
function ProcessStatus(props) {
  const { className } = props, rest = __rest2(props, ["className"]);
  const processContext = import_react2.default.useContext(ProcessContext);
  const { status, error, setError } = processContext;
  const classes = ["process-status"];
  if (className)
    classes.push(className);
  if (error)
    classes.push("error");
  const onClick = () => {
    if (error)
      setError("");
  };
  const viewProps = Object.assign(Object.assign({}, rest), { onClick, key: "process-status", className: classes.join(" "), children: error || status });
  return import_react2.default.createElement(View, Object.assign({}, viewProps));
}
function ProcessProgress(_) {
  const processContext = import_react2.default.useContext(ProcessContext);
  const { progress, processing } = processContext;
  if (!processing)
    return import_react2.default.createElement(View, { className: "progress-holder" });
  const progressProps = {
    value: progress,
    max: 1,
    children: `${Math.round(100 * progress)}%`
  };
  return import_react2.default.createElement("progress", Object.assign({}, progressProps));
}
var ShooterContextDefault = { devices: [] };
var ShooterContext = import_react2.default.createContext(ShooterContextDefault);
function Shooter(props) {
  const getDevices = () => {
    navigator.mediaDevices.enumerateDevices().then(setDevices);
  };
  const [devices, setDevices] = import_react2.default.useState([]);
  import_react2.default.useEffect(getDevices, []);
  const context = { devices };
  const viewProps = {
    children: devices.map((device) => import_react2.default.createElement(View, null, JSON.stringify(device)))
  };
  return import_react2.default.createElement(
    ShooterContext.Provider,
    { value: context },
    import_react2.default.createElement(View, Object.assign({}, viewProps))
  );
}
function Streamer(props) {
  return import_react2.default.createElement(View, Object.assign({}, props));
}
function Streamers(props) {
  return import_react2.default.createElement(View, Object.assign({}, props));
}
function StreamersCreateControl(props) {
  return import_react2.default.createElement(View, Object.assign({}, props));
}
var WebrtcContextDefault = {
  setClient: () => {
  }
};
var WebrtcContext = import_react2.default.createContext(WebrtcContextDefault);
function enableStereoOpus(sdp) {
  return sdp.replace(/a=fmtp:111/, "a=fmtp:111 stereo=1\r\na=fmtp:111");
}
var WebrtcClient = class {
  constructor(endpointPromise, setStatus) {
    this.setStatus = setStatus;
    this.endpointPromise = endpointPromise;
  }
  beforeAnswer(peerConnection) {
    return __awaiter(this, void 0, void 0, function* () {
      const promise = window.navigator.mediaDevices.getUserMedia({
        audio: true,
        video: true
      }).then((something) => something).catch((error) => {
        console.error("beforeAnswer", error);
        return void 0;
      });
      this.localStream = yield promise;
      if (!this.localStream)
        return;
      this.localStream.getTracks().forEach((track) => {
        if (!this.localStream)
          return;
        peerConnection.addTrack(track, this.localStream);
      });
      const { close } = peerConnection;
      peerConnection.close = (...args) => {
        if (!this.localStream)
          return;
        this.localStream.getTracks().forEach((track) => {
          track.stop();
        });
        return close.apply(peerConnection, args);
      };
    });
  }
  closeConnection() {
    var _a;
    (_a = this.localPeerConnection) === null || _a === void 0 ? void 0 : _a.close();
  }
  createConnection(options = {}) {
    const { stereo } = options;
    const request = {};
    return this.endpointPromise(Endpoints.streaming.webrtc, request).then((response) => {
      const { id, localDescription } = response;
      const rtcConfiguration = {};
      const peer = new RTCPeerConnection(rtcConfiguration);
      this.localPeerConnection = peer;
      peer.close = () => {
        const request2 = { id };
        this.endpointPromise(Endpoints.streaming.delete, request2).then((response2) => {
        });
        return RTCPeerConnection.prototype.close.apply(peer);
      };
      try {
        peer.setRemoteDescription(localDescription).then(() => {
          this.beforeAnswer(peer).then(() => {
            peer.createAnswer().then((originalAnswer) => {
              const updatedAnswer = new RTCSessionDescription({
                type: "answer",
                sdp: stereo ? enableStereoOpus(originalAnswer.sdp) : originalAnswer.sdp
              });
              console.debug(this.constructor.name, "createConnection setLocalDescription");
              peer.setLocalDescription(updatedAnswer).then(() => {
                const { localDescription: localDescription2 } = peer;
                if (!localDescription2)
                  throw Errors.invalid.object + "localDescription";
                const request2 = { id, localDescription: localDescription2 };
                console.debug("StreamingRemoteRequest", Endpoints.streaming.remote, request2);
                this.endpointPromise(Endpoints.streaming.remote, request2).then((response2) => {
                  console.debug("StreamingRemoteResponse", Endpoints.streaming.remote, response2);
                });
              });
            });
            return peer;
          });
        });
      } catch (error) {
        console.trace(this.constructor.name, "createConnection", error);
        this.localPeerConnection.close();
        throw error;
      }
    });
  }
};
function WebrtcButton(props) {
  const webrtcContext = import_react2.default.useContext(WebrtcContext);
  const processContext = import_react2.default.useContext(ProcessContext);
  const apiContext = import_react2.default.useContext(ApiContext);
  const { setStatus, processing, setProcessing } = processContext;
  const { endpointPromise } = apiContext;
  const { client, setClient } = webrtcContext;
  const onClick = () => {
    if (client) {
      setStatus("Closing WebRTC connection");
      client.closeConnection();
      setProcessing(false);
      setClient(void 0);
    } else {
      const client2 = new WebrtcClient(endpointPromise, setStatus);
      setStatus("Opening WebRTC connection...");
      client2.createConnection().then(() => {
        setStatus("Opened WebRTC connection");
        setProcessing(true);
        setClient(client2);
      });
    }
  };
  const broadcastingOptions = Object.assign(Object.assign({}, props), { onClick });
  return import_react2.default.createElement(View, Object.assign({}, broadcastingOptions));
}
function WebrtcContent(props) {
  const ref = import_react2.default.useRef(null);
  const webrtcContext = import_react2.default.useContext(WebrtcContext);
  const processContext = import_react2.default.useContext(ProcessContext);
  const { client } = webrtcContext;
  const { processing } = processContext;
  const addListeners = () => {
    return () => {
    };
  };
  const { current } = ref;
  if (current)
    current.srcObject = processing ? (client === null || client === void 0 ? void 0 : client.localStream) || null : null;
  import_react2.default.useEffect(() => addListeners(), []);
  const rest = __rest2(props, ["children"]);
  const videoProps = Object.assign(Object.assign({}, rest), { ref, autoPlay: true, muted: true });
  return import_react2.default.createElement(VideoView, Object.assign({}, videoProps));
}
function Webrtc(props) {
  const [client, setClient] = import_react2.default.useState();
  const apiContext = import_react2.default.useContext(ApiContext);
  const { enabled, servers } = apiContext;
  if (!(enabled && servers[ServerType.Streaming]))
    return null;
  const context = { client, setClient };
  return import_react2.default.createElement(
    WebrtcContext.Provider,
    { value: context },
    import_react2.default.createElement(View, Object.assign({}, props))
  );
}
var application = import_react2.default.createElement(
  Webrtc,
  { className: "panel webrtc" },
  import_react2.default.createElement(
    "div",
    { className: "head" },
    import_react2.default.createElement(
      WebrtcButton,
      null,
      import_react2.default.createElement(
        ProcessActive,
        null,
        import_react2.default.createElement(Button, null, "Stop Broadcasting")
      ),
      import_react2.default.createElement(
        ProcessInactive,
        null,
        import_react2.default.createElement(Button, null, "Start Broadcasting")
      )
    )
  ),
  import_react2.default.createElement(WebrtcContent, { className: "content" }),
  import_react2.default.createElement("div", { className: "foot" })
);
var DefaultStreamerProps = (args) => {
  return { className: "editor caster", children: application };
};
export {
  Activity,
  ActivityContent,
  ActivityContentContext,
  ActivityContentContextDefault,
  ActivityContext,
  ActivityContextDefault,
  ActivityGroup,
  ActivityGroups,
  ActivityItem,
  ActivityLabel,
  ActivityPicked,
  ActivityPicker,
  ActivityProgress,
  ActivityPropsDefault,
  ApiClient,
  ApiContext,
  ApiContextDefault,
  ApiEnabled,
  Bar,
  BooleanTypeInput,
  Broadcaster,
  BroadcasterContent,
  BroadcasterControl,
  BroadcasterPreloadControl,
  BroadcasterUpdateControl,
  Browser,
  BrowserContent,
  BrowserContext,
  BrowserContextDefault,
  BrowserControl,
  BrowserPicker,
  BrowserPropsDefault,
  Button,
  ClipContext,
  ClipContextDefault,
  ClipItem,
  ColorGroupInput,
  Composer,
  ComposerContent,
  ComposerContext,
  ComposerContextDefault,
  ComposerDepth,
  ComposerFolderClose,
  ComposerFolderOpen,
  ComposerLayer,
  ComposerLayerFolder,
  ComposerLayerLabel,
  ComposerLayerMash,
  CreateEditedControl,
  DataGroupInputs,
  DataTypeInputs,
  DefaultComposerProps,
  DefaultPlayerProps,
  DefaultStreamerProps,
  DefaultTimelineProps,
  DefinitionContext,
  DefinitionContextDefault,
  DefinitionDrop,
  DefinitionItem,
  DefinitionSelect,
  DragElementPoint,
  DragElementRect,
  DragSuffix,
  DragType,
  DragTypes,
  EditorRedoButton,
  EditorRemoveButton,
  EditorUndoButton,
  EffectsGroupInput,
  EmptyElement,
  InputContext,
  InputContextDefault,
  Inspector,
  InspectorContent,
  InspectorContext,
  InspectorContextDefault,
  InspectorEffect,
  InspectorPicked,
  InspectorPicker,
  InspectorProperties,
  InspectorProperty,
  InspectorPropsDefault,
  LayerContext,
  LayerContextDefault,
  Masher,
  MasherCastProps,
  MasherContext,
  MasherContextDefault,
  MasherDefaultProps,
  NumericTypeInput,
  OpacityGroupInput,
  Panel,
  PanelContent,
  PanelFoot,
  PanelHead,
  Panels,
  PercentTypeInput,
  Player,
  PlayerButton,
  PlayerContent,
  PlayerContext,
  PlayerContextDefault,
  PlayerNotPlaying,
  PlayerPlaying,
  PlayerTime,
  PlayerTimeControl,
  PointGroupInput,
  Problems,
  Process,
  ProcessActive,
  ProcessContext,
  ProcessContextDefault,
  ProcessInactive,
  ProcessProgress,
  ProcessStatus,
  RenderControl,
  RgbTypeInput,
  SaveControl,
  SelectEditedControl,
  Shooter,
  ShooterContext,
  ShooterContextDefault,
  SizeGroupInput,
  SizingGroupInput,
  SizingTypeInput,
  Slider,
  Streamer,
  Streamers,
  StreamersCreateControl,
  TextTypeInput,
  Timeline,
  TimelineAddClipControl,
  TimelineAddTrackControl,
  TimelineContent,
  TimelineContext,
  TimelineContextDefault,
  TimelineDefaultZoom,
  TimelineScrubber,
  TimelineScrubberElement,
  TimelineSizer,
  TimelineTrack,
  TimelineTrackIcon,
  TimelineTracks,
  TimelineZoom,
  TimelineZoomer,
  TimingGroupInput,
  TimingTypeInput,
  TrackContext,
  TrackContextDefault,
  TransferTypeFiles,
  TweenInputKey,
  VideoView,
  View,
  ViewControl,
  ViewerContext,
  ViewerContextDefault,
  Webrtc,
  WebrtcButton,
  WebrtcClient,
  WebrtcContent,
  WebrtcContext,
  WebrtcContextDefault,
  activityLabel,
  assertActivityGroup,
  assertDragDefinitionObject,
  assertDragOffsetObject,
  dragData,
  dragDefinitionType,
  dragType,
  dragTypes,
  dropFilesFromList,
  dropType,
  droppingPositionClass,
  elementSetPreviewSize,
  isActivityGroup,
  isDragDefinitionObject,
  isDragOffsetObject,
  isDragType,
  isTransferType,
  labelInterpolate,
  labelLookup,
  labelObjects,
  labelTranslate,
  labels,
  panelOptionsStrict,
  propsDefinitionTypes,
  propsSelectTypes,
  sessionGet,
  sessionSet,
  useApiDefinitions,
  useClip,
  useDefinition,
  useEditor,
  useEditorActivity,
  useEditorDefinitions,
  useLayer,
  useListeners
};
//# sourceMappingURL=@moviemasher_client-react.js.map
