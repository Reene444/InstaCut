import {
  __publicField
} from "./chunk-OCBYBPSH.js";

// node_modules/@moviemasher/moviemasher.js/esm/moviemasher.js
var isCustomEvent = (value) => value instanceof CustomEvent;
var throwError = (value, expected, name = "value") => {
  const type2 = typeof value;
  const typeName = type2 === "object" ? value.constructor.name : type2;
  console.error("throwError", value);
  throw new Error(`${name} is "${value}" (${typeName}) instead of ${expected}`);
};
var isObject = (value) => typeof value === "object";
function assertObject(value, name) {
  if (!isObject(value))
    throwError(value, "Object", name);
}
var isString = (value) => typeof value === "string";
function assertString(value, name) {
  if (!isString(value))
    throwError(value, "String", name);
}
var isUndefined = (value) => typeof value === "undefined";
var isNumberOrNaN = (value) => typeof value === "number";
function assertNumber(value, name) {
  if (!isNumberOrNaN(value))
    throwError(value, "Number", name);
}
var isBoolean = (value) => typeof value === "boolean";
function assertBoolean(value, name) {
  if (!isBoolean(value))
    throwError(value, "Boolean", name);
}
var isMethod = (value) => typeof value === "function";
var isDefined = (value) => !isUndefined(value);
function assertDefined(value, name) {
  if (!isDefined(value))
    throwError(value, "defined", name);
}
var isNan = (value) => isNumberOrNaN(value) && Number.isNaN(value);
var isNumber = (value) => isNumberOrNaN(value) && !Number.isNaN(value);
var isInteger = (value) => Number.isInteger(value);
var isFloat = (value) => isNumber(value) && !isInteger(value);
var isPositive = (value) => isNumber(value) && value >= 0;
function assertPositive(value, name) {
  if (!isPositive(value))
    throwError(value, ">= 0", name);
}
var isBelowOne = (value) => isNumber(value) && value < 1;
var isAboveZero = (value) => isNumber(value) && value > 0;
function assertAboveZero(value, name) {
  if (!isAboveZero(value))
    throwError(value, "> zero", name);
}
var isArray = (value) => isDefined(Array.isArray) ? Array.isArray(value) : value instanceof Array;
function assertArray(value, name) {
  if (!isArray(value))
    throwError(value, "Array", name);
}
var length = (value) => !!value.length;
var isPopulatedString = (value) => isString(value) && length(String(value));
function assertPopulatedString(value, name = "value") {
  if (!isPopulatedString(value))
    throwError(value, "populated string", name);
}
var isPopulatedArray = (value) => isArray(value) && length(value);
function assertPopulatedArray(value, name = "value") {
  if (!isPopulatedArray(value))
    throwError(value, "populated array", name);
}
var isPopulatedObject = (value) => isObject(value) && length(Object.keys(value));
function assertPopulatedObject(value, name = "value") {
  if (!isPopulatedObject(value))
    throwError(value, "populated array", name);
}
var isNumeric = (value) => (isNumber(value) || isPopulatedString(value)) && !isNan(Number(value));
function assertTrue(value, name = "value") {
  if (!value)
    throwError(value, "true", name);
}
var isRgb = (value) => {
  return isObject(value) && "r" in value && "g" in value && "b" in value;
};
function assertRgb(value, name) {
  if (!isRgb(value))
    throwError(value, "Rgb", name);
}
var isTime = (value) => {
  return isObject(value) && "isRange" in value;
};
function assertTime(value, name) {
  if (!isTime(value))
    throwError(value, "Time", name);
}
var isTimeRange = (value) => {
  return isTime(value) && value.isRange;
};
function assertTimeRange(value, name) {
  if (!isTimeRange(value))
    throwError(value, "TimeRange", name);
}
var isValue = (value) => {
  return isNumber(value) || isString(value);
};
var isTrueValue = (value) => {
  if (!isValue(value))
    return false;
  if (isNumeric(value))
    return !!Number(value);
  return isPopulatedString(value);
};
function assertValue(value, name) {
  if (!isValue(value))
    throwError(value, "Value", name);
}
var isValueObject = (value) => {
  return isObject(value) && Object.values(value).every((value2) => isValue(value2));
};
function assertValueObject(value, name) {
  if (!isValueObject(value))
    throwError(value, "ValueObject", name);
}
var DroppingPosition;
(function(DroppingPosition2) {
  DroppingPosition2["At"] = "at";
  DroppingPosition2["After"] = "after";
  DroppingPosition2["Before"] = "before";
  DroppingPosition2["None"] = "none";
})(DroppingPosition || (DroppingPosition = {}));
var LayerType;
(function(LayerType2) {
  LayerType2["Mash"] = "mash";
  LayerType2["Folder"] = "folder";
})(LayerType || (LayerType = {}));
var LayerTypes = Object.values(LayerType);
var isLayerType = (value) => {
  return LayerTypes.includes(value);
};
function assertLayerType(value) {
  if (!isLayerType(value))
    throw new Error("expected LayerType");
}
var ActionType;
(function(ActionType2) {
  ActionType2["AddClipToTrack"] = "addClipToTrack";
  ActionType2["AddEffect"] = "addEffect";
  ActionType2["AddLayer"] = "addLayer";
  ActionType2["AddTrack"] = "addTrack";
  ActionType2["Change"] = "change";
  ActionType2["ChangeMultiple"] = "changeMultiple";
  ActionType2["ChangeFrame"] = "changeFrame";
  ActionType2["ChangeGain"] = "changeGain";
  ActionType2["MoveClip"] = "moveClip";
  ActionType2["MoveEffect"] = "moveEffect";
  ActionType2["MoveLayer"] = "moveLayer";
  ActionType2["RemoveClip"] = "removeClip";
  ActionType2["RemoveLayer"] = "removeLayer";
})(ActionType || (ActionType = {}));
var EditType;
(function(EditType2) {
  EditType2["Mash"] = "mash";
  EditType2["Cast"] = "cast";
})(EditType || (EditType = {}));
var EditTypes = Object.values(EditType);
var isEditType = (value) => {
  return EditTypes.includes(value);
};
function assertEditType(value, name) {
  if (!isEditType(value))
    throwError(value, "EditType", name);
}
var AVType;
(function(AVType2) {
  AVType2["Audio"] = "audio";
  AVType2["Both"] = "both";
  AVType2["Video"] = "video";
})(AVType || (AVType = {}));
var SelectType;
(function(SelectType2) {
  SelectType2["Cast"] = "cast";
  SelectType2["Clip"] = "clip";
  SelectType2["Container"] = "container";
  SelectType2["Content"] = "content";
  SelectType2["Effect"] = "effect";
  SelectType2["Layer"] = "layer";
  SelectType2["Mash"] = "mash";
  SelectType2["None"] = "none";
  SelectType2["Track"] = "track";
})(SelectType || (SelectType = {}));
var SelectTypes = Object.values(SelectType);
var isSelectType = (value) => {
  return SelectTypes.includes(value);
};
function assertSelectType(value, name) {
  if (!isSelectType(value))
    throwError(value, "SelectType", name);
}
var ClipSelectTypes = [SelectType.Content, SelectType.Container];
var isClipSelectType = (type2) => {
  return isSelectType(type2) && ClipSelectTypes.includes(type2);
};
var OutputFormat;
(function(OutputFormat2) {
  OutputFormat2["AudioConcat"] = "wav";
  OutputFormat2["Flv"] = "flv";
  OutputFormat2["Hls"] = "hls";
  OutputFormat2["Jpeg"] = "jpeg";
  OutputFormat2["Mdash"] = "mdash";
  OutputFormat2["Mp3"] = "mp3";
  OutputFormat2["Mp4"] = "mp4";
  OutputFormat2["Png"] = "image2";
  OutputFormat2["Rtmp"] = "rtmp";
  OutputFormat2["VideoConcat"] = "yuv4mpegpipe";
})(OutputFormat || (OutputFormat = {}));
var StreamingFormat;
(function(StreamingFormat2) {
  StreamingFormat2["Hls"] = "hls";
  StreamingFormat2["Mdash"] = "mdash";
  StreamingFormat2["Rtmp"] = "rtmp";
})(StreamingFormat || (StreamingFormat = {}));
var OutputType;
(function(OutputType2) {
  OutputType2["Audio"] = "audio";
  OutputType2["Image"] = "image";
  OutputType2["ImageSequence"] = "imagesequence";
  OutputType2["Video"] = "video";
  OutputType2["Waveform"] = "waveform";
})(OutputType || (OutputType = {}));
var OutputTypes = Object.values(OutputType);
var FillType;
(function(FillType2) {
  FillType2["Color"] = "color";
  FillType2["Fill"] = "fill";
})(FillType || (FillType = {}));
var FillTypes = Object.values(FillType);
var isFillType = (type2) => {
  return FillTypes.includes(type2);
};
var GraphFileType;
(function(GraphFileType2) {
  GraphFileType2["Svg"] = "svg";
  GraphFileType2["SvgSequence"] = "svgsequence";
  GraphFileType2["Txt"] = "txt";
})(GraphFileType || (GraphFileType = {}));
var GraphFileTypes = Object.values(GraphFileType);
var isGraphFileType = (type2) => {
  return isPopulatedString(type2) && GraphFileTypes.includes(type2);
};
var LoadType;
(function(LoadType2) {
  LoadType2["Audio"] = "audio";
  LoadType2["Font"] = "font";
  LoadType2["Image"] = "image";
  LoadType2["Video"] = "video";
})(LoadType || (LoadType = {}));
var LoadTypes = Object.values(LoadType);
var isLoadType = (type2) => {
  return isPopulatedString(type2) && LoadTypes.includes(type2);
};
function assertLoadType(value, name) {
  if (!isLoadType(value))
    throwError(value, "LoadType", name);
}
var UploadTypes = LoadTypes.filter((type2) => type2 !== LoadType.Font);
var isUploadType = (type2) => {
  return isLoadType(type2) && UploadTypes.includes(type2);
};
var DefinitionType;
(function(DefinitionType2) {
  DefinitionType2["Audio"] = "audio";
  DefinitionType2["Clip"] = "clip";
  DefinitionType2["Container"] = "container";
  DefinitionType2["Content"] = "content";
  DefinitionType2["Effect"] = "effect";
  DefinitionType2["Filter"] = "filter";
  DefinitionType2["Font"] = "font";
  DefinitionType2["Image"] = "image";
  DefinitionType2["Video"] = "video";
  DefinitionType2["VideoSequence"] = "videosequence";
})(DefinitionType || (DefinitionType = {}));
var DefinitionTypes = Object.values(DefinitionType);
var isDefinitionType = (type2) => {
  return DefinitionTypes.includes(type2);
};
function assertDefinitionType(value, message = "") {
  if (!isDefinitionType(value))
    throw new Error(`expected '${value}' to be DefinitionType ${message}`);
}
var SizingDefinitionTypes = [DefinitionType.Container, DefinitionType.Image, DefinitionType.Video, DefinitionType.VideoSequence];
var isSizingDefinitionType = (type2) => {
  return isDefinitionType(type2) && SizingDefinitionTypes.includes(type2);
};
var TimingDefinitionTypes = [DefinitionType.Audio, DefinitionType.Video, DefinitionType.VideoSequence];
var isTimingDefinitionType = (type2) => {
  return isDefinitionType(type2) && TimingDefinitionTypes.includes(type2);
};
var ContainerTypes = [DefinitionType.Image, DefinitionType.Container, DefinitionType.VideoSequence];
var isContainerType = (type2) => {
  return isDefinitionType(type2) && ContainerTypes.includes(type2);
};
function assertContainerType(type2) {
  if (!isContainerType(type2))
    throw new Error("expected ContainerType");
}
var ContentTypes = [DefinitionType.Content, DefinitionType.Image, DefinitionType.Video, DefinitionType.VideoSequence, DefinitionType.Audio];
var isContentType = (type2) => {
  return isDefinitionType(type2) && ContentTypes.includes(type2);
};
function assertContentType(type2) {
  if (!isContentType(type2))
    throw new Error("expected ContentType");
}
var DataType;
(function(DataType2) {
  DataType2["Boolean"] = "boolean";
  DataType2["ContainerId"] = "containerid";
  DataType2["ContentId"] = "contentid";
  DataType2["DefinitionId"] = "definitionid";
  DataType2["FontId"] = "fontid";
  DataType2["Frame"] = "frame";
  DataType2["Number"] = "number";
  DataType2["Percent"] = "percent";
  DataType2["Rgb"] = "rgb";
  DataType2["String"] = "string";
  DataType2["Timing"] = "timing";
  DataType2["Sizing"] = "sizing";
})(DataType || (DataType = {}));
var DataTypes = Object.values(DataType);
var isDataType = (type2) => {
  return DataTypes.includes(type2);
};
function assertDataType(value, name) {
  if (!isDataType(value))
    throwError(value, "DataType", name);
}
var Orientation;
(function(Orientation2) {
  Orientation2["H"] = "H";
  Orientation2["V"] = "V";
})(Orientation || (Orientation = {}));
var Orientations = Object.values(Orientation);
var isOrientation = (value) => {
  return isPopulatedString(value) && Orientations.includes(value);
};
var Direction;
(function(Direction2) {
  Direction2["E"] = "E";
  Direction2["N"] = "N";
  Direction2["S"] = "S";
  Direction2["W"] = "W";
})(Direction || (Direction = {}));
var Directions = Object.values(Direction);
var isDirection = (value) => {
  return Directions.includes(value);
};
function assertDirection(value, name) {
  if (!isDirection(value))
    throwError(value, "Direction", name);
}
var Anchor;
(function(Anchor2) {
  Anchor2["E"] = "E";
  Anchor2["N"] = "N";
  Anchor2["NE"] = "NE";
  Anchor2["NW"] = "NW";
  Anchor2["S"] = "S";
  Anchor2["SE"] = "SE";
  Anchor2["SW"] = "SW";
  Anchor2["W"] = "W";
})(Anchor || (Anchor = {}));
var Anchors = Object.values(Anchor);
var TriggerType;
(function(TriggerType2) {
  TriggerType2["Init"] = "init";
  TriggerType2["Stop"] = "stop";
  TriggerType2["Start"] = "start";
})(TriggerType || (TriggerType = {}));
var TriggerTypes = Object.values(TriggerType);
var isTriggerType = (type2) => {
  return TriggerTypes.includes(type2);
};
var TransformType;
(function(TransformType2) {
  TransformType2["Scale"] = "scale";
  TransformType2["Translate"] = "translate";
})(TransformType || (TransformType = {}));
var EventType;
(function(EventType2) {
  EventType2["Action"] = "action";
  EventType2["Active"] = "active";
  EventType2["Added"] = "added";
  EventType2["Cast"] = "cast";
  EventType2["Draw"] = "draw";
  EventType2["Duration"] = "durationchange";
  EventType2["Ended"] = "ended";
  EventType2["Fps"] = "ratechange";
  EventType2["Loaded"] = "loadeddata";
  EventType2["Mash"] = "mash";
  EventType2["Pause"] = "pause";
  EventType2["Play"] = "play";
  EventType2["Playing"] = "playing";
  EventType2["Render"] = "render";
  EventType2["Resize"] = "resize";
  EventType2["Save"] = "save";
  EventType2["Seeked"] = "seeked";
  EventType2["Seeking"] = "seeking";
  EventType2["Selection"] = "selection";
  EventType2["Time"] = "timeupdate";
  EventType2["Track"] = "track";
  EventType2["Volume"] = "volumechange";
  EventType2["Waiting"] = "waiting";
})(EventType || (EventType = {}));
var EventTypes = Object.values(EventType);
var isEventType = (type2) => {
  return EventTypes.includes(type2);
};
var MoveType;
(function(MoveType2) {
  MoveType2["Audio"] = "audio";
  MoveType2["Effect"] = "effect";
  MoveType2["Video"] = "video";
})(MoveType || (MoveType = {}));
var MasherAction;
(function(MasherAction2) {
  MasherAction2["Redo"] = "redo";
  MasherAction2["Remove"] = "remove";
  MasherAction2["Render"] = "render";
  MasherAction2["Save"] = "save";
  MasherAction2["Undo"] = "undo";
})(MasherAction || (MasherAction = {}));
var GraphType;
(function(GraphType2) {
  GraphType2["Mash"] = "mash";
  GraphType2["Cast"] = "cast";
})(GraphType || (GraphType = {}));
var ServerType;
(function(ServerType2) {
  ServerType2["Api"] = "api";
  ServerType2["Data"] = "data";
  ServerType2["File"] = "file";
  ServerType2["Rendering"] = "rendering";
  ServerType2["Streaming"] = "streaming";
  ServerType2["Web"] = "web";
})(ServerType || (ServerType = {}));
var ServerTypes = Object.values(ServerType);
var Duration;
(function(Duration2) {
  Duration2[Duration2["Unknown"] = -1] = "Unknown";
  Duration2[Duration2["Unlimited"] = -2] = "Unlimited";
  Duration2[Duration2["None"] = 0] = "None";
})(Duration || (Duration = {}));
var Timing;
(function(Timing2) {
  Timing2["Custom"] = "custom";
  Timing2["Content"] = "content";
  Timing2["Container"] = "container";
})(Timing || (Timing = {}));
var Timings = Object.values(Timing);
var Sizing;
(function(Sizing2) {
  Sizing2["Preview"] = "preview";
  Sizing2["Content"] = "content";
  Sizing2["Container"] = "container";
})(Sizing || (Sizing = {}));
var Sizings = Object.values(Sizing);
var ApiVersion = "5.1.1";
var EndpointsApi = {
  servers: "",
  callbacks: ""
};
var EndpointsEncode = {
  start: "",
  status: ""
  // stop: '',
};
var EndpointsRendering = { ...EndpointsEncode, upload: "" };
var EndpointsCrud = {
  delete: "",
  get: "",
  put: "",
  retrieve: ""
};
var EndpointsData = {
  cast: { ...EndpointsCrud, default: "" },
  mash: { ...EndpointsCrud, default: "" },
  stream: { ...EndpointsCrud },
  definition: { ...EndpointsCrud }
};
var EndpointsStreaming = {
  ...EndpointsEncode,
  ...EndpointsCrud,
  preload: "",
  cut: "",
  webrtc: "",
  rtmp: "",
  remote: "",
  local: ""
};
var EndpointsFile = {
  store: ""
};
var Endpoints = {
  [ServerType.Api]: EndpointsApi,
  [ServerType.Data]: EndpointsData,
  [ServerType.File]: EndpointsFile,
  [ServerType.Rendering]: EndpointsRendering,
  [ServerType.Streaming]: EndpointsStreaming
};
Object.entries(Endpoints).forEach(([serverType, server]) => {
  if (isObject(server))
    Object.entries(server).forEach(([key1, value1]) => {
      if (isString(value1))
        server[key1] = `/${serverType}/${key1}`;
      else
        Object.entries(value1).forEach(([key2, value2]) => {
          if (!value2)
            value1[key2] = `/${serverType}/${key1}/${key2}`;
        });
    });
});
var Factories = {};
var Factory = Factories;
var ExtHls = "m3u8";
var ExtTs = "ts";
var ExtRtmp = "flv";
var ExtDash = "dash";
var ExtJpeg = "jpg";
var ExtPng = "png";
var ExtJson = "json";
var ExtText = "txt";
var OutputFilterGraphPadding = 6;
var EmptyMethod = () => {
};
var NamespaceSvg = "http://www.w3.org/2000/svg";
var NamespaceXhtml = "http://www.w3.org/1999/xhtml";
var NamespaceLink = "http://www.w3.org/1999/xlink";
var IdPrefix = "com.moviemasher.";
var IdSuffix = ".default";
var ClassDisabled = "disabled";
var ClassButton = "button";
var ClassCollapsed = "collapsed";
var ClassSelected = "selected";
var ClassDropping = "dropping";
var ClassDroppingBefore = "dropping-before";
var ClassDroppingAfter = "dropping-after";
var isDefinitionObject = (value) => {
  return isObject(value) && "id" in value && (!value.type || isDefinitionType(value.type));
};
var isDefinition = (value) => {
  return isObject(value) && isDefinitionType(value.type) && "instanceFromObject" in value;
};
function assertDefinition(value, name) {
  if (!isDefinition(value))
    throwError(value, "Definition", name);
}
var Defined = class {
  static byIdAdd(definition) {
    const definitions = Array.isArray(definition) ? definition : [definition];
    definitions.forEach((definition2) => this.byId.set(definition2.id, definition2));
  }
  static byType(type2) {
    const list = this.definitionsByType.get(type2);
    if (list)
      return list;
    const definitions = Factory[type2].defaults || [];
    this.definitionsByType.set(type2, definitions);
    return definitions;
  }
  static define(...objects) {
    return objects.map((object) => this.fromObject(object));
  }
  static definitionDelete(definition) {
    const { type: type2, id: id2 } = definition;
    const definitions = this.byType(type2);
    const index = definitions.findIndex((definition2) => id2 === definition2.id);
    if (index < 0)
      return;
    definitions.splice(index, 1);
  }
  static definitionsType(id2) {
    const type2 = id2.split(".").slice(-2).shift();
    return isDefinitionType(type2) ? type2 : void 0;
  }
  static fromId(id2) {
    if (this.installed(id2))
      return this.byId.get(id2);
    const definitionType = this.definitionsType(id2);
    assertDefinitionType(definitionType, `in Defined.fromId('${id2}')`);
    return Factory[definitionType].definitionFromId(id2);
  }
  static fromObject(object) {
    const { id: id2, type: type2 } = object;
    assertPopulatedString(id2);
    if (this.installed(id2) || this.predefined(id2))
      return this.fromId(id2);
    const definitionType = type2 || this.definitionsType(id2);
    assertDefinitionType(definitionType);
    return this.install(Factory[definitionType].definition(object));
  }
  static get ids() {
    return [...this.byId.keys()];
  }
  static install(definition) {
    const { type: type2, id: id2 } = definition;
    if (this.installed(id2)) {
      this.uninstall(definition);
      return this.updateDefinition(this.fromId(id2), definition);
    }
    this.byIdAdd(definition);
    this.byType(type2).push(definition);
    return definition;
  }
  static installed(id2) {
    return this.byId.has(id2);
  }
  static predefined(id2) {
    if (id2.startsWith(IdPrefix))
      return true;
    const definitionType = this.definitionsType(id2);
    if (!definitionType)
      return false;
    const array = this.byType(definitionType);
    return array.some((definition) => definition.id === id2);
  }
  static undefineAll() {
    this.byId = /* @__PURE__ */ new Map();
    this.definitionsByType = /* @__PURE__ */ new Map();
  }
  static updateDefinition(oldDefinition, newDefinition) {
    this.uninstall(oldDefinition);
    this.install(newDefinition);
    return newDefinition;
  }
  static updateDefinitionId(oldId, newId) {
    const definition = this.byId.get(oldId);
    assertDefinition(definition);
    this.byId.delete(oldId);
    this.byId.set(newId, definition);
  }
  static uninstall(definition) {
    this.definitionDelete(definition);
    const { id: id2 } = definition;
    this.byId.delete(id2);
    return definition;
  }
};
__publicField(Defined, "byId", /* @__PURE__ */ new Map());
__publicField(Defined, "definitionsByType", /* @__PURE__ */ new Map());
var colorRgbKeys = "rgb".split("");
var colorRgbaKeys = [...colorRgbKeys, "a"];
var colorTransparent = "#00000000";
var colorBlack = "#000000";
var colorWhite = "#FFFFFF";
var colorWhiteTransparent = "#FFFFFF00";
var colorBlackTransparent = "#00000000";
var colorWhiteOpaque = "#FFFFFFFF";
var colorBlackOpaque = "#000000FF";
var colorGreen = "#00FF00";
var colorYellow = "#FFFF00";
var colorRed = "#FF0000";
var colorBlue = "#0000FF";
var Color;
(function(Color2) {
  Color2["Transparent"] = "#00000000";
  Color2["Black"] = "#000000";
  Color2["White"] = "#FFFFFF";
  Color2["WhiteTransparent"] = "#FFFFFF00";
  Color2["BlackTransparent"] = "#00000000";
  Color2["WhiteOpaque"] = "#FFFFFFFF";
  Color2["BlackOpaque"] = "#000000FF";
  Color2["Green"] = "#00FF00";
  Color2["Yellow"] = "#FFFF00";
  Color2["Red"] = "#FF0000";
  Color2["Blue"] = "#0000FF";
})(Color || (Color = {}));
var Colors = Object.values(Color);
var colorName = (color2) => {
  for (const entry of Object.entries(Color)) {
    const [key, value] = entry;
    if (value === color2)
      return key;
  }
  return "";
};
var rgbValue = (value) => Math.min(255, Math.max(0, Math.floor(Number(value))));
var rgbNumeric = (rgb) => ({
  r: rgbValue(rgb.r),
  g: rgbValue(rgb.g),
  b: rgbValue(rgb.b)
});
var yuvNumeric = (rgb) => ({
  y: rgbValue(rgb.y),
  u: rgbValue(rgb.u),
  v: rgbValue(rgb.v)
});
var colorYuvToRgb = (yuv) => {
  const floats = yuvNumeric(yuv);
  return rgbNumeric({
    r: floats.y + 1.4075 * (floats.v - 128),
    g: floats.y - 0.3455 * (floats.u - 128) - 0.7169 * (floats.v - 128),
    b: floats.y + 1.779 * (floats.u - 128)
  });
};
var colorRgbToHex = (rgb) => {
  let r = rgb.r.toString(16);
  let g2 = rgb.g.toString(16);
  let b = rgb.b.toString(16);
  if (r.length < 2)
    r = `0${r}`;
  if (g2.length < 2)
    g2 = `0${g2}`;
  if (b.length < 2)
    b = `0${b}`;
  return `#${r}${g2}${b}`;
};
var colorRgbaToHex = (object) => {
  let r = object.r.toString(16);
  let g2 = object.g.toString(16);
  let b = object.b.toString(16);
  let a = Math.round(255 * Number(object.a)).toString(16);
  if (r.length < 2)
    r = `0${r}`;
  if (g2.length < 2)
    g2 = `0${g2}`;
  if (b.length < 2)
    b = `0${b}`;
  if (a.length < 2)
    a = `0${a}`;
  return `#${r}${g2}${b}${a}`;
};
var colorYuvDifference = (fromYuv, toYuv, similarity, blend) => {
  const du = fromYuv.u - toYuv.u;
  const dv = fromYuv.v - toYuv.v;
  const diff = Math.sqrt((du * du + dv * dv) / (255 * 255));
  if (blend > 1e-4) {
    return Math.min(1, Math.max(0, (diff - similarity) / blend)) * 255;
  }
  return diff > similarity ? 255 : 0;
};
var colorYuvBlend = (yuvs, yuv, similarity, blend) => {
  let diff = 0;
  const blendYuv = yuvNumeric(yuv);
  yuvs.forEach((yuvObject) => {
    const numericYuv = yuvNumeric(yuvObject);
    const du = numericYuv.u - blendYuv.u;
    const dv = numericYuv.v - blendYuv.v;
    diff += Math.sqrt((du * du + dv * dv) / (255 * 255));
  });
  diff /= yuvs.length;
  if (blend > 1e-4) {
    return Math.min(1, Math.max(0, (diff - similarity) / blend)) * 255;
  }
  return diff > similarity ? 255 : 0;
};
var colorRgbToYuv = (rgb) => {
  const ints = rgbNumeric(rgb);
  return {
    y: ints.r * 0.299 + ints.g * 0.587 + ints.b * 0.114,
    u: ints.r * -0.168736 + ints.g * -0.331264 + ints.b * 0.5 + 128,
    v: ints.r * 0.5 + ints.g * -0.418688 + ints.b * -0.081312 + 128
  };
};
var colorRgbRegex = /^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/;
var colorRgbaRegex = /^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),(\d*(?:\.\d+)?)\)$/;
var colorHexRegex = /^#([A-Fa-f0-9]{3,4}){1,2}$/;
var colorStrip = (color2) => color2.toLowerCase().replaceAll(/[\s]/g, "");
var colorValid = (color2) => {
  const stripped = colorStrip(color2);
  if (colorValidHex(stripped) || colorValidRgba(stripped) || colorValidRgb(stripped))
    return true;
  const style = new Option().style;
  style.color = color2;
  const styleStripped = colorStrip(style.color);
  if (!styleStripped)
    return false;
  if (colorValidRgba(stripped) || colorValidRgb(stripped))
    return true;
  return styleStripped === stripped;
};
var colorValidHex = (value) => colorHexRegex.test(value);
var colorValidRgba = (value) => colorRgbaRegex.test(value);
var colorValidRgb = (value) => colorRgbRegex.test(value);
var getChunksFromString = (st, chunkSize) => st.match(new RegExp(`.{${chunkSize}}`, "g"));
var hex256 = (hexStr) => parseInt(hexStr.repeat(2 / hexStr.length), 16);
var colorAlpha = (value) => {
  if (!isPositive(value))
    return 1;
  return Math.max(0, Math.min(1, value / 255));
};
var colorHexToRgba = (hex) => {
  if (!colorValidHex(hex))
    return colorRgba;
  const chunkSize = Math.floor((hex.length - 1) / 3);
  const hexArr = getChunksFromString(hex.slice(1), chunkSize);
  if (!hexArr)
    return colorRgba;
  const [r, g2, b, a] = hexArr.map(hex256);
  return { r, g: g2, b, a: colorAlpha(a) };
};
var colorHexToRgb = (hex) => {
  if (!colorValidHex(hex))
    return colorRgb;
  const chunkSize = Math.floor((hex.length - 1) / 3);
  const hexArr = getChunksFromString(hex.slice(1), chunkSize);
  if (!hexArr)
    return colorRgb;
  const [r, g2, b] = hexArr.map(hex256);
  return { r, g: g2, b };
};
var colorRgbaToRgba = (value) => {
  const color2 = colorStrip(value);
  const rgbaMatch = color2.match(colorRgbaRegex);
  if (!rgbaMatch)
    return colorRgba;
  return {
    r: Number(rgbaMatch[1]),
    g: Number(rgbaMatch[2]),
    b: Number(rgbaMatch[3]),
    a: Number(rgbaMatch[4])
  };
};
var colorToRgb = (value) => {
  const color2 = colorStrip(value);
  if (colorValidHex(color2))
    return colorHexToRgb(color2);
  const rgbMatch = color2.match(colorRgbRegex);
  if (!rgbMatch)
    return colorRgb;
  return {
    r: Number(rgbMatch[1]),
    g: Number(rgbMatch[2]),
    b: Number(rgbMatch[3])
  };
};
var colorToRgba = (value) => {
  if (!colorValid(value))
    return colorRgba;
  const color2 = colorStrip(value);
  if (colorValidHex(color2))
    return colorHexToRgba(color2);
  if (colorValidRgba(color2))
    return colorRgbaToRgba(color2);
  if (colorValidRgb(color2))
    return { a: 1, ...colorToRgb(color2) };
  return colorRgba;
};
var colorAlphaColor = (value) => {
  const toRgba = colorToRgba(value);
  return { alpha: toRgba.a, color: colorRgbToHex(toRgba) };
};
var colorFromRgb = (rgb) => {
  const { r, g: g2, b } = rgb;
  return `rgb(${r},${g2},${b})`;
};
var colorFromRgba = (object) => {
  const { r, g: g2, b, a } = object;
  return `rgb(${r},${g2},${b},${a})`;
};
var colorRgb = { r: 0, g: 0, b: 0 };
var colorRgba = { ...colorRgb, a: 1 };
var colorRgbaTransparent = { ...colorRgb, a: 0 };
var colorServer = (color2) => {
  if (!colorValidHex(color2))
    return color2;
  return `${color2.slice(0, 7)}@0x${color2.slice(-2)}`;
};
var colorRgbDifference = (rgb) => {
  const { r, g: g2, b } = rgb;
  return {
    ...rgb,
    r: 255 - r,
    g: 255 - g2,
    b: 255 - b
  };
};
var PropertyTypesNumeric = [
  DataType.Frame,
  DataType.Percent,
  DataType.Number
];
var propertyTypeRepresentedAsNumber = (dataType) => {
  return isDataType(dataType) && PropertyTypesNumeric.includes(dataType);
};
var propertyTypeIsString = (dataType) => {
  if (dataType === DataType.Boolean)
    return false;
  if (propertyTypeRepresentedAsNumber(dataType))
    return false;
  return true;
};
var propertyTypeDefault = (dataType) => {
  if (isDefinitionType(dataType))
    return `${IdPrefix}${dataType}${IdSuffix}`;
  switch (dataType) {
    case DataType.Boolean:
      return false;
    case DataType.Rgb:
      return colorBlack;
  }
  return propertyTypeRepresentedAsNumber(dataType) ? 0 : "";
};
var propertyTypeValidBoolean = (value) => {
  if (isBoolean(value))
    return true;
  if (isNumber(value))
    return value === 0 || value === 1;
  return ["true", "false", ""].includes(value);
};
var propertyTypeValid = (value, dataType) => {
  if (isDefinitionType(dataType))
    return isPopulatedString(value);
  switch (dataType) {
    case DataType.Boolean:
      return propertyTypeValidBoolean(value);
    case DataType.Rgb:
      return colorValid(String(value));
    case DataType.Frame:
    case DataType.Percent:
    case DataType.Number:
      return isNumeric(value);
    case DataType.String:
      return true;
    case DataType.ContainerId:
    case DataType.ContentId:
    case DataType.FontId:
    case DataType.DefinitionId:
    default:
      return isPopulatedString(value);
  }
  return false;
};
var propertyTypeCoerce = (value, dataType) => {
  if (dataType === DataType.Boolean) {
    if (isBoolean(value))
      return value;
    if (isNumeric(value))
      return !!Number(value);
    return value === "true";
  }
  if (propertyTypeRepresentedAsNumber(dataType))
    return isNumeric(value) ? Number(value) : 0;
  return String(value);
};
var PropertyTweenSuffix = "End";
var PropertiedClass = class {
  constructor(..._args) {
    __publicField(this, "properties", []);
  }
  addProperties(object, ...properties2) {
    this.properties.push(...properties2);
    properties2.forEach((property) => {
      this.propertyTweenSetOrDefault(object, property);
    });
  }
  get propertiesCustom() {
    return this.properties.filter((property) => property.custom);
  }
  propertiesInitialize(object) {
    assertObject(object);
    this.properties.forEach((property) => this.propertyTweenSetOrDefault(object, property));
  }
  propertyFind(name) {
    return this.properties.find((property) => property.name === name);
  }
  propertyName(name) {
    if (!name.endsWith(PropertyTweenSuffix))
      return name;
    return name.slice(0, -PropertyTweenSuffix.length);
  }
  propertySetOrDefault(object, property, name, defaultValue) {
    const value = object[name];
    const definedValue = isUndefined(value) ? defaultValue : value;
    this.setValue(definedValue, name, property);
  }
  propertyTweenSetOrDefault(object, property) {
    const { name, defaultValue, tweenable } = property;
    this.propertySetOrDefault(object, property, name, defaultValue);
    if (tweenable)
      this.propertySetOrDefault(object, property, `${name}${PropertyTweenSuffix}`);
  }
  setValue(value, name, property) {
    if (isUndefined(value)) {
      delete this[name];
      return;
    }
    const propertyName = this.propertyName(name);
    const found = property || this.propertyFind(propertyName);
    assertTrue(found, `${this.constructor.name}.${propertyName} in ${this.properties.map((p) => p.name).join(", ")}`);
    const type2 = found.type;
    if (!propertyTypeValid(value, type2)) {
      if (propertyName !== name) {
        delete this[name];
      }
      return;
    }
    const coerced = propertyTypeCoerce(value, type2);
    this[name] = coerced;
  }
  setValues(object) {
    Object.entries(object).forEach(([name, value]) => {
      this.setValue(value, name);
    });
  }
  toJSON() {
    return Object.fromEntries(this.properties.flatMap((property) => {
      const { name, tweenable } = property;
      const entries = [[name, this.value(name)]];
      if (tweenable) {
        const key = `${name}${PropertyTweenSuffix}`;
        entries.push([key, this.value(key)]);
      }
      return entries;
    }));
  }
  value(key) {
    return this[key];
  }
};
var isPropertied = (value) => value instanceof PropertiedClass;
var isInstanceObject = (value) => {
  return isObject(value) && ("definitionId" in value || "definition" in value);
};
var isInstance = (value) => {
  return isObject(value) && "definitionIds" in value;
};
var isTweenable = (value) => {
  return isInstance(value) && isDefinition(value.definition);
};
function assertTweenable(value) {
  if (!isTweenable(value))
    throw new Error("expected Tweenable");
}
var isTweenableDefinition = (value) => {
  return isDefinition(value);
};
function assertTweenableDefinition(value) {
  if (!isTweenableDefinition(value))
    throw new Error("expected TweenableDefinition");
}
var DefaultContainerId = `${IdPrefix}container${IdSuffix}`;
var TextContainerId = `${IdPrefix}container.text`;
var isContainerObject = (value) => {
  return isObject(value) && "opacity" in value;
};
function assertContainerObject(value) {
  if (!isContainerObject(value))
    throwError(value, "ContainerObject");
}
var isContainerDefinition = (value) => {
  return isTweenableDefinition(value) && isContainerType(value.type);
};
var isContainer = (value) => {
  return isTweenable(value) && isContainerType(value.type);
};
function assertContainer(value) {
  if (!isContainer(value))
    throw new Error("expected Container");
}
var isPoint = (value) => {
  return isObject(value) && isNumber(value.x) && isNumber(value.y);
};
function assertPoint(value, name) {
  if (!isPoint(value))
    throwError(value, "Point", name);
}
var pointsEqual = (point, pointEnd) => {
  if (!isPoint(pointEnd))
    return false;
  return point.x === pointEnd.x && point.y === pointEnd.y;
};
var PointZero = { x: 0, y: 0 };
var pointCopy = (point) => {
  const { x, y } = point;
  return { x, y };
};
var pointRound = (point) => {
  const { x, y } = point;
  return { x: Math.round(x), y: Math.round(y) };
};
var pointString = (point) => {
  const { x, y } = point;
  return `x=${x};y=${y}`;
};
var pointValueString = (point) => {
  const { x, y } = point;
  return `${x},${y}`;
};
var pointNegate = (point) => {
  const { x, y } = point;
  return { x: -x, y: -y };
};
var isSize = (value) => {
  return isObject(value) && isNumber(value.width) && isNumber(value.height);
};
function assertSize(value, name) {
  if (!isSize(value))
    throwError(value, "Size", name);
}
var sizesEqual = (size, sizeEnd) => {
  if (!isSize(sizeEnd))
    return false;
  return size.width === sizeEnd.width && size.height === sizeEnd.height;
};
var SizeZero = { width: 0, height: 0 };
var sizedEven = (number) => {
  return 2 * Math.max(1, Math.ceil(number / 2));
};
var sizeEven = (size) => {
  const { width: width2, height: height2 } = size;
  return {
    width: sizedEven(width2),
    height: sizedEven(height2)
  };
};
var sizeRound = (point) => {
  const { width: width2, height: height2 } = point;
  return { width: Math.round(width2), height: Math.round(height2) };
};
var sizeCeil = (size) => {
  const { width: width2, height: height2 } = size;
  return {
    width: Math.max(2, Math.ceil(width2)),
    height: Math.max(2, Math.ceil(height2))
  };
};
var sizeFloor = (size) => {
  const { width: width2, height: height2 } = size;
  return {
    width: Math.max(2, Math.floor(width2)),
    height: Math.max(2, Math.floor(height2))
  };
};
var sizeScale = (size, horizontally, vertically) => {
  const { width: width2, height: height2 } = size;
  return { width: width2 * horizontally, height: height2 * vertically };
};
var sizeCover = (inSize, outSize, contain = false) => {
  assertSizeAboveZero(inSize, "sizeCover");
  assertSize(outSize);
  const { width: inWidth, height: inHeight } = inSize;
  const { width: width2, height: height2 } = outSize;
  const scaleWidth = width2 / inWidth;
  const scaleHeight = height2 / inHeight;
  const useWidth = contain ? scaleWidth < scaleHeight : scaleWidth > scaleHeight;
  if (useWidth) {
    return sizeCeil({ ...outSize, height: inHeight * scaleWidth });
  }
  return sizeCeil({ ...outSize, width: inWidth * scaleHeight });
};
var sizeAboveZero = (size) => {
  if (!isSize(size))
    return false;
  const { width: width2, height: height2 } = size;
  return isAboveZero(width2) && isAboveZero(height2);
};
function assertSizeAboveZero(size, name) {
  if (!sizeAboveZero(size))
    throwError(size, "SizeAboveZero", name);
}
var SizeOutput = { width: 1920, height: 1080 };
var SizePreview = sizeScale(SizeOutput, 0.25, 0.25);
var SizeIcon = sizeScale(SizePreview, 0.5, 0.5);
var sizeCopy = (size) => {
  const { width: width2, height: height2 } = size;
  return { width: width2, height: height2 };
};
var sizeLock = (lockSize, lock) => {
  const copy = sizeCopy(lockSize);
  switch (lock) {
    case Orientation.H:
      copy.width = copy.height;
      break;
    case Orientation.V:
      copy.height = copy.width;
      break;
  }
  return copy;
};
var sizeString = (size) => {
  const { width: width2, height: height2 } = size;
  return `width=${width2};height=${height2}`;
};
var sizeLockNegative = (size, lock) => {
  assertSizeAboveZero(size, "sizeLockNegative");
  const locked = sizeCopy(size);
  if (lock) {
    if (lock === Orientation.V)
      locked.height = -1;
    else
      locked.width = -1;
  }
  return locked;
};
var sizeFromElement = (element) => {
  const size = {
    width: Number(element.getAttribute("width")),
    height: Number(element.getAttribute("height"))
  };
  assertSizeAboveZero(size, "sizeFromElement");
  return size;
};
var isRect = (value) => {
  return isSize(value) && isPoint(value);
};
function assertRect(value, name) {
  if (!isRect(value))
    throwError(value, "Rect", name);
}
var rectsEqual = (rect, rectEnd) => {
  if (!isRect(rectEnd))
    return false;
  return pointsEqual(rect, rectEnd) && sizesEqual(rect, rectEnd);
};
var RectZero = { ...PointZero, ...SizeZero };
var rectFromSize = (size, point) => {
  const definedPoint = point || PointZero;
  const { width: width2, height: height2 } = size;
  return {
    x: definedPoint.x,
    y: definedPoint.y,
    width: width2,
    height: height2
  };
};
var rectsFromSizes = (sizes, points) => {
  const definedPoints = points || [PointZero, PointZero];
  const [size, sizeEnd] = sizes;
  const [point, pointEnd] = definedPoints;
  return [rectFromSize(size, point), rectFromSize(sizeEnd, pointEnd)];
};
var rectCopy = (rect) => {
  return { ...pointCopy(rect), ...sizeCopy(rect) };
};
var rectRound = (rect) => {
  return { ...sizeRound(rect), ...pointRound(rect) };
};
var centerPoint = (size, inSize) => {
  return {
    x: Math.round((size.width - inSize.width) / 2),
    y: Math.round((size.height - inSize.height) / 2)
  };
};
var rectString = (dimensions) => {
  const bits = [];
  if (isSize(dimensions))
    bits.push(sizeString(dimensions));
  if (isPoint(dimensions))
    bits.push(pointString(dimensions));
  return bits.join(";");
};
var arrayLast = (array) => array[array.length - 1];
var arraySet = (array, items) => {
  array.splice(0, array.length, ...items);
  return array;
};
var arrayReversed = (array) => {
  return [...array].reverse();
};
var arrayUnique = (array) => {
  return [...new Set(array)];
};
var DataGroup;
(function(DataGroup2) {
  DataGroup2["Point"] = "point";
  DataGroup2["Size"] = "size";
  DataGroup2["Opacity"] = "opacity";
  DataGroup2["Color"] = "color";
  DataGroup2["Effects"] = "effects";
  DataGroup2["Timing"] = "timing";
  DataGroup2["Sizing"] = "sizing";
})(DataGroup || (DataGroup = {}));
var DataGroups = Object.values(DataGroup);
var isDataGroup = (value) => {
  return DataGroups.includes(value);
};
function assertDataGroup(value, name) {
  if (!isDataGroup(value))
    throwError(value, "DataGroup", name);
}
var isProperty = (value) => {
  return isObject(value) && "type" in value && isDataType(value.type);
};
function assertProperty(value, name) {
  if (!isProperty(value))
    throwError(value, "Property", name);
}
var propertyType = (type2, value) => {
  if (isUndefined(type2)) {
    if (isBoolean(value))
      return DataType.Boolean;
    if (isNumber(value))
      return DataType.Number;
    return DataType.String;
  }
  assertDataType(type2);
  return type2;
};
var propertyValue = (type2, value) => {
  if (isUndefined(value))
    return propertyTypeDefault(type2);
  return value;
};
var propertyInstance = (object) => {
  const { type: type2, name, defaultValue, ...rest } = object;
  const dataType = propertyType(type2, defaultValue);
  const dataValue = propertyValue(dataType, defaultValue);
  const dataName = isPopulatedString(name) ? name : dataType;
  const property = {
    type: dataType,
    defaultValue: dataValue,
    name: dataName,
    ...rest
  };
  switch (type2) {
    case DataType.Percent: {
      if (isUndefined(property.max))
        property.max = 1;
      if (isUndefined(property.min))
        property.min = 0;
      if (isUndefined(property.step))
        property.step = 0.01;
      break;
    }
  }
  return property;
};
var $invalid = "Invalid";
var $unknown = "Unknown";
var $expected = "Expected";
var $invalidArgument = `${$invalid} argument `;
var $invalidProperty = `${$invalid} property `;
var $invalidDefinitionProperty = `${$invalid} definition property`;
var $internal = "Internal Error ";
var Errors = {
  eval: {
    sourceRect: `${$invalid} evaluation of source rect `,
    outputSize: `${$invalid} evaluation of output size `,
    inputSize: `${$invalid} evaluation of input size `,
    conditionTruth: `${$expected} at least one condition to evaluate to true `,
    conditionValue: `${$expected} condition to have a value `,
    number: `${$expected} evaluated number for `,
    get: `${$expected} to get evaluated value `,
    string: `${$invalid} evaluation string `
  },
  composition: { mashUndefined: `${$internal}composition.mash undefined` },
  audibleContext: `${$expected} AudioContext`,
  mash: `${$expected} mash`,
  action: `${$expected} Action`,
  actions: `${$expected} Actions`,
  internal: $internal,
  argument: `${$invalidArgument}`,
  invalid: {
    canvas: `${$invalidProperty}canvas `,
    context: `${$invalidProperty}context `,
    duration: `${$invalid} duration`,
    definition: {
      audio: `${$invalidDefinitionProperty} audio|url`,
      url: `${$invalidDefinitionProperty} url`,
      source: `${$invalidDefinitionProperty} source`,
      id: `${$invalidDefinitionProperty} id `,
      object: `${$invalidProperty}definition`,
      type: `${$invalidDefinitionProperty} type `
    },
    size: `${$invalid} size `,
    track: `${$invalid} track `,
    trackType: `${$invalidProperty}trackType `,
    action: `${$invalid} action `,
    name: `${$invalidProperty}name `,
    value: `${$invalidProperty}value `,
    type: `${$invalidProperty}type `,
    url: `${$invalidProperty}url `,
    user: "Unauthenticated",
    property: $invalidProperty,
    argument: $invalidArgument,
    object: `${$invalidArgument}object `,
    factory: `${$invalid} factory `,
    volume: `${$invalidArgument}volume`
  },
  type: `${$unknown} type `,
  selection: `${$invalid} selection `,
  unknown: {
    type: `${$unknown} type `,
    merger: `${$unknown} merger `,
    effect: `${$unknown} effect `,
    filter: `${$unknown} filter `,
    font: `${$unknown} font `,
    scaler: `${$unknown} scalar `,
    definition: `${$unknown} definition `
  },
  uncached: "Uncached URL ",
  object: `${$invalidArgument}object `,
  array: `${$invalidArgument}array `,
  media: `${$invalidArgument}media `,
  id: `${$invalidArgument}id `,
  frame: `${$invalidArgument}frame `,
  frames: `${$invalidProperty}frames `,
  fps: `${$invalidArgument}fps `,
  seconds: `${$invalidArgument}seconds `,
  url: `${$invalidArgument}url `,
  time: `${$invalidArgument}Time`,
  timeRange: `${$invalidArgument}TimeRange`,
  mainTrackOverlap: `${$internal}: main track clips overlap without transition`,
  unknownMash: `${$unknown} Mash property `,
  unimplemented: `${$expected} method to be overridden `,
  property: `${$invalidArgument}property `,
  wrongClass: `${$expected} instance of `
};
var Parameter = class {
  constructor({ name, value, dataType, values }) {
    __publicField(this, "dataType", DataType.String);
    __publicField(this, "name");
    __publicField(this, "value");
    __publicField(this, "values");
    var _a;
    if (!name)
      throw Errors.invalid.name;
    this.values = values;
    this.name = name;
    if (isUndefined(value)) {
      if ((_a = this.values) == null ? void 0 : _a.length)
        this.value = this.values[0];
      else
        throw Errors.invalid.value;
    } else
      this.value = value;
    if (dataType && DataTypes.map(String).includes(dataType)) {
      this.dataType = dataType;
    } else {
      let numeric = false;
      if (Array.isArray(this.value)) {
        numeric = this.value.every((condition) => isNumeric(condition.value));
      } else
        numeric = isNumeric(this.value);
      if (numeric)
        this.dataType = DataType.Number;
    }
  }
  toJSON() {
    return { name: this.name, value: this.value };
  }
};
var Id = {
  count: 0,
  prefix: "",
  countsByPrefix: {}
};
var idGenerateString = () => {
  const components = [];
  if (Id.prefix)
    components.push(Id.prefix);
  components.push(Date.now().toString(36));
  components.push(Math.random().toString(36).slice(2));
  return components.join("-");
};
var idPrefixSet = (prefix) => {
  Id.prefix = prefix;
};
var idTemporary = () => {
  var _a;
  const { prefix } = Id;
  const components = [];
  if (prefix) {
    components.push(prefix);
    (_a = Id.countsByPrefix)[prefix] || (_a[prefix] = 0);
    components.push(String(Id.countsByPrefix[prefix]++));
  } else
    components.push(String(Id.count++));
  return components.join("");
};
var idGenerate = (prefix = Id.prefix) => {
  var _a;
  const components = [];
  if (prefix) {
    components.push(prefix);
    (_a = Id.countsByPrefix)[prefix] || (_a[prefix] = 0);
    components.push(String(Id.countsByPrefix[prefix]++));
  } else
    components.push(String(Id.count++));
  return components.join("");
};
var idIsTemporary = (id2) => {
  if (!isPopulatedString(Id.prefix))
    return false;
  return id2.startsWith(Id.prefix);
};
var InstanceBase = class extends PropertiedClass {
  constructor(...args) {
    super(...args);
    __publicField(this, "definition");
    __publicField(this, "_id");
    __publicField(this, "_label", "");
    const [object] = args;
    assertPopulatedObject(object);
    const { definition } = object;
    assertDefinition(definition);
    this.definition = definition;
    this.properties.push(...this.definition.properties);
    this.propertiesInitialize(object);
  }
  copy() {
    return this.definition.instanceFromObject(this.toJSON());
  }
  get definitionId() {
    return this.definition.id;
  }
  definitionIds() {
    return [this.definitionId];
  }
  get id() {
    return this._id || (this._id = idGenerateString());
  }
  get label() {
    return this._label;
  }
  //|| this.definition.label || this.id
  set label(value) {
    this._label = value;
  }
  get propertyNames() {
    return this.properties.map((property) => property.name);
  }
  toJSON() {
    const json = super.toJSON();
    const { definitionId, type: type2, label: label2 } = this;
    if (label2)
      json.label = label2;
    json.type = type2;
    json.definitionId = definitionId;
    return json;
  }
  get type() {
    return this.definition.type;
  }
};
var svgId = (id2) => {
  return `#${id2}`;
};
var svgUrl = (id2) => {
  return `url(${svgId(id2)})`;
};
var svgGroupElement = (dimensions, id2 = "") => {
  const element = globalThis.document.createElementNS(NamespaceSvg, "g");
  svgSet(element, id2);
  svgSetDimensions(element, dimensions);
  return element;
};
var svgSetDimensions = (element, dimensions) => {
  if (isSize(dimensions)) {
    const { width: width2, height: height2 } = dimensions;
    if (isPositive(width2))
      svgSet(element, String(width2), "width");
    if (isPositive(height2))
      svgSet(element, String(height2), "height");
  }
  if (isPoint(dimensions)) {
    const { x, y } = dimensions;
    svgSet(element, String(x), "x");
    svgSet(element, String(y), "y");
  }
};
var svgSetTransformPoint = (element, point) => {
  assertPoint(point);
  const { x, y } = point;
  if (!(x || y))
    return;
  svgSetTransform(element, `translate(${x}, ${y})`);
};
var svgRectPoints = (dimensions) => {
  const { width: width2, height: height2, x = 0, y = 0 } = dimensions;
  const startEndPoint = { x, y };
  const points = [];
  points.push(startEndPoint);
  points.push({ x: x + width2, y });
  points.push({ x: x + width2, y: y + height2 });
  points.push({ x, y: y + height2 });
  points.push(startEndPoint);
  return points;
};
var svgPolygonElement = (dimensions, className, fill = "", id2) => {
  const element = globalThis.document.createElementNS(NamespaceSvg, "polygon");
  const rectPoints = svgRectPoints(dimensions);
  const points = rectPoints.map((point) => [point.x, point.y].join(",")).join(" ");
  svgSet(element, points, "points");
  svgSet(element, fill, "fill");
  svgAddClass(element, className);
  svgSet(element, id2);
  return element;
};
var svgSetBox = (element, boxSize) => {
  assertSizeAboveZero(boxSize, "svgSetBox");
  const justSize = sizeCopy(boxSize);
  const { width: width2, height: height2 } = justSize;
  svgSetDimensions(element, justSize);
  const viewBox = `0 0 ${width2} ${height2}`;
  svgSet(element, viewBox, "viewBox");
};
var svgElement = (size, svgItems) => {
  const element = globalThis.document.createElementNS(NamespaceSvg, "svg");
  svgSet(element, "1.1", "version");
  svgSet(element, NamespaceSvg, "xmlns");
  svgAppend(element, svgItems);
  if (!sizeAboveZero(size))
    return element;
  svgSetBox(element, size);
  return element;
};
var svgSetDimensionsLock = (element, dimensions, lock) => {
  assertSizeAboveZero(dimensions);
  if (!lock)
    svgSet(element, "none", "preserveAspectRatio");
  const rect = {
    ...sizeLockNegative(dimensions, lock),
    ...pointCopy(dimensions)
  };
  svgSetDimensions(element, rect);
};
var svgImageElement = () => {
  const element = globalThis.document.createElementNS(NamespaceSvg, "image");
  svgSet(element, "none", "preserveAspectRatio");
  return element;
};
var svgPathElement = (path2, fill = "currentColor") => {
  const element = globalThis.document.createElementNS(NamespaceSvg, "path");
  svgSet(element, path2, "d");
  svgSet(element, fill, "fill");
  return element;
};
var svgMaskElement = (size, contentItem, luminance) => {
  const maskId = idGenerateString();
  const maskElement = globalThis.document.createElementNS(NamespaceSvg, "mask");
  svgSet(maskElement, maskId);
  if (sizeAboveZero(size)) {
    const color2 = luminance ? "black" : "none";
    svgAppend(maskElement, svgPolygonElement(size, "", color2));
  }
  if (contentItem) {
    svgSet(contentItem, svgUrl(maskId), "mask");
    if (luminance)
      svgSet(contentItem, "luminance", "mask-mode");
  }
  return maskElement;
};
var svgFilter = (values, dimensions) => {
  const { filter, ...rest } = values;
  assertPopulatedString(filter);
  const element = globalThis.document.createElementNS(NamespaceSvg, filter);
  svgSetDimensions(element, dimensions);
  Object.entries(rest).forEach(([key, value]) => {
    svgSet(element, String(value), key);
  });
  return element;
};
var svgAppend = (element, items) => {
  if (!items)
    return;
  const kids = isArray(items) ? items : [items];
  kids.forEach((kid) => element.appendChild(kid));
};
var svgPatternElement = (dimensions, id2, items) => {
  const element = globalThis.document.createElementNS(NamespaceSvg, "pattern");
  svgSet(element, id2);
  svgSetBox(element, dimensions);
  svgSet(element, "userSpaceOnUse", "patternUnits");
  svgAppend(element, items);
  return element;
};
var svgDefsElement = (svgItems) => {
  const element = globalThis.document.createElementNS(NamespaceSvg, "defs");
  svgAppend(element, svgItems);
  return element;
};
var svgFeImageElement = (id2, result) => {
  const element = globalThis.document.createElementNS(NamespaceSvg, "feImage");
  if (isPopulatedString(id2))
    svgSet(element, svgId(id2), "href");
  svgSet(element, result, "result");
  return element;
};
var svgFilterElement = (filters2, filtered, rect, units = "userSpaceOnUse") => {
  const filterElement = globalThis.document.createElementNS(NamespaceSvg, "filter");
  if (units)
    svgSet(filterElement, units, "filterUnits");
  svgSet(filterElement, "sRGB", "color-interpolation-filters");
  svgAppend(filterElement, filters2);
  if (filtered) {
    const filterId = idGenerateString();
    svgSet(filterElement, filterId);
    if (filtered) {
      const array = isArray(filtered) ? filtered : [filtered];
      array.forEach((filtered2) => {
        svgSet(filtered2, svgUrl(filterId), "filter");
        svgAddClass(filtered2, "filtered");
      });
    }
  }
  svgSetDimensions(filterElement, rect);
  return filterElement;
};
var svgDifferenceDefs = (overlayId, filtered) => {
  const filterObject = { filter: "feBlend" };
  const resultId = idGenerateString();
  const differenceFilter = svgFilter({ ...filterObject, mode: "difference" });
  svgSet(differenceFilter, resultId, "in");
  svgSet(differenceFilter, "SourceGraphic", "in2");
  const image = svgFeImageElement(overlayId, resultId);
  const filter = svgFilterElement([image, differenceFilter], filtered, PointZero);
  svgSet(filter, "100%", "width");
  svgSet(filter, "100%", "height");
  return filter;
};
var svgSet = (element, value, name = "id") => {
  if (isPopulatedString(value))
    element.setAttribute(name, value);
};
var svgAddClass = (element, className) => {
  if (!className)
    return;
  const array = isArray(className) ? className : className.split(" ");
  element.classList.add(...array);
};
var svgUseElement = (href, className, id2) => {
  const element = globalThis.document.createElementNS(NamespaceSvg, "use");
  if (isPopulatedString(href))
    svgSet(element, svgId(href), "href");
  svgSet(element, id2);
  svgAddClass(element, className);
  return element;
};
var svgSetTransform = (element, transform, origin = "top left") => {
  svgSet(element, transform, "transform");
  svgSet(element, origin, "transform-origin");
};
var svgTransform = (dimensions, rect) => {
  assertSizeAboveZero(dimensions, "svgTransform.dimensions");
  assertSizeAboveZero(rect, "svgTransform.rect");
  const { width: inWidth, height: inHeight } = dimensions;
  const { width: outWidth, height: outHeight, x: outX, y: outY } = rect;
  const scaleWidth = outWidth / inWidth;
  const scaleHeight = outHeight / inHeight;
  const words = [];
  if (!(outX === 0 && outY === 0))
    words.push(`translate(${outX},${outY})`);
  if (!(scaleWidth === 1 && scaleHeight === 1)) {
    words.push(`scale(${scaleWidth},${scaleHeight})`);
  }
  if (isPoint(dimensions)) {
    const { x: inX, y: inY } = dimensions;
    if (!(inX === 0 && inY === 0))
      words.push(`translate(${inX},${inY})`);
  }
  return words.join(" ");
};
var svgSetTransformRects = (element, dimensions, rect) => {
  svgSetTransform(element, svgTransform(dimensions, rect));
};
var svgFunc = (type2, values) => {
  const element = globalThis.document.createElementNS(NamespaceSvg, type2);
  svgSet(element, values, "tableValues");
  svgSet(element, "discrete", "type");
  return element;
};
var svgSetChildren = (element, svgItems) => {
  if (!element.hasChildNodes())
    return svgAppend(element, svgItems);
  const { childNodes } = element;
  const nodes = [];
  childNodes.forEach((node) => {
    if (!svgItems.includes(node))
      nodes.push(node);
  });
  nodes.forEach((node) => {
    element.removeChild(node);
  });
  svgItems.forEach((node) => element.appendChild(node));
};
var isLoadedVideo = (value) => {
  return value instanceof HTMLVideoElement;
};
var isLoadedImage = (value) => {
  return value instanceof HTMLImageElement;
};
var isLoadedAudio = (value) => {
  return value instanceof AudioBuffer;
};
var isLoaderType = (value) => {
  return isLoadType(value) || isGraphFileType(value);
};
function assertLoaderType(value, name) {
  if (!isLoaderType(value))
    throwError(value, "LoaderType", name);
}
var isLoaderPath = (value) => {
  return isPopulatedString(value) && value.includes(":");
};
function assertLoaderPath(value, name) {
  if (!isLoaderPath(value))
    throwError(value, "LoaderPath", name);
}
var urlEndpoint = (endpoint = {}) => {
  const { baseURI } = globalThis.document;
  const url = new URL(baseURI);
  const { protocol: withColon, host: hostWithPort, pathname: prefix, port } = url;
  const host = hostWithPort.split(":").shift();
  const protocol = withColon.slice(0, -1);
  const result = { protocol, host, prefix, ...endpoint };
  if (isNumeric(port))
    result.port = Number(port);
  return result;
};
var urlIsObject = (url) => url.startsWith("object:/");
var urlIsHttp = (url) => url.startsWith("http");
var urlHasProtocol = (url) => url.includes(":");
var urlCombine = (url, path2) => {
  const urlStripped = url.endsWith("/") ? url.slice(0, -1) : url;
  const pathStripped = path2.startsWith("/") ? path2.slice(1) : path2;
  return urlStripped + "/" + pathStripped;
};
var urlFromEndpoint = (endpoint) => {
  const mergedEndpoint = urlEndpoint(endpoint);
  const { port, prefix, host, protocol } = mergedEndpoint;
  assertPopulatedString(host);
  assertPopulatedString(protocol);
  const bits = [];
  bits.push(protocol, "://", host);
  if (isNumeric(port))
    bits.push(":", String(port));
  const url = bits.join("");
  const combined = prefix ? urlCombine(url, prefix) : url;
  return combined;
};
var urlForEndpoint = (endpoint, suffix = "") => {
  if (suffix && urlHasProtocol(suffix))
    return suffix;
  const base = urlFromEndpoint(endpoint);
  const slashed = base.endsWith("/") ? base : base + "/";
  if (!urlHasProtocol(slashed))
    return slashed + suffix;
  const url = new URL(suffix, slashed);
  const { href } = url;
  return href;
};
var urlIsRootProtocol = (protocol) => {
  return protocol === "object" || urlIsHttp(protocol) || !isLoaderType(protocol);
};
var urlProtocol = (string) => {
  const colonIndex = string.indexOf(":");
  if (isAboveZero(colonIndex))
    return string.slice(0, colonIndex);
  return "";
};
var urlParse = (string) => {
  const colonIndex = string.indexOf(":");
  const slashIndex = string.indexOf("/");
  if (!(isPositive(colonIndex) && isPositive(slashIndex)))
    return [];
  const protocol = string.slice(0, colonIndex);
  const options2 = string.slice(colonIndex + 1, slashIndex);
  const rest = string.slice(slashIndex + 1);
  return [protocol, options2, rest];
};
var urlsParsed = (string) => {
  if (!string)
    return [];
  const urls = [urlParse(string)];
  let lastPath = "";
  while (lastPath = arrayLast(arrayLast(urls))) {
    const parsed = urlParse(lastPath);
    if (!parsed.length)
      break;
    const [protocol, _, path2] = parsed;
    if (protocol === "object" || urlIsHttp(protocol))
      break;
    urls.push(parsed);
    if (urlIsRootProtocol(urlProtocol(path2)))
      break;
  }
  return urls;
};
var urlsAbsolute = (string, endpoint) => {
  if (!string || urlIsRootProtocol(urlProtocol(string)))
    return [];
  const urls = urlsParsed(string);
  const lastUrl = arrayLast(urls);
  if (!lastUrl)
    return urls;
  const path2 = arrayLast(lastUrl);
  if (urlIsObject(path2) || urlIsHttp(path2))
    return urls;
  let absolute = urlForEndpoint(endpoint, path2);
  const { length: length2 } = urls;
  for (let i = length2 - 1; i > -1; i--) {
    const url = urls[i];
    const [protocol, options2] = url;
    url[2] = absolute;
    absolute = `${protocol}:${options2}/${absolute}`;
  }
  return urls;
};
var urlOptionsObject = (options2) => {
  if (!isPopulatedString(options2))
    return;
  const pairs = options2.split(";");
  const entries = pairs.map((pair) => {
    const [key, string] = pair.split("=");
    const value = isNumeric(string) ? Number(string) : string;
    return [key, value];
  });
  return Object.fromEntries(entries);
};
var urlOptions = (options2) => {
  if (!options2)
    return "";
  return Object.entries(options2).map((entry) => entry.join("=")).join(";");
};
var urlPrependProtocol = (protocol, url, options2) => {
  if (url.startsWith(protocol) && !options2)
    return url;
  return `${protocol}:${urlOptions(options2)}/${url}`;
};
var DefinitionBase = class {
  constructor(...args) {
    __publicField(this, "icon");
    __publicField(this, "id");
    __publicField(this, "label", "");
    __publicField(this, "properties", []);
    __publicField(this, "type");
    const [object] = args;
    const { id: id2, label: label2, icon } = object;
    assertPopulatedString(id2, "id");
    this.id = id2;
    if (isPopulatedString(label2))
      this.label = label2;
    if (isPopulatedString(icon))
      this.icon = icon;
  }
  definitionIcon(loader, size) {
    const { icon } = this;
    if (!icon) {
      return;
    }
    return this.urlIcon(icon, loader, size);
  }
  instanceFromObject(object = {}) {
    return new InstanceBase(this.instanceArgs(object));
  }
  instanceArgs(object = {}) {
    const defaults = Object.fromEntries(this.properties.map((property) => [property.name, property.defaultValue]));
    return { ...defaults, ...object, definition: this };
  }
  get propertiesModular() {
    return this.properties.filter((property) => isDefinitionType(property.type));
  }
  toJSON() {
    const object = { id: this.id, type: this.type };
    if (this.icon)
      object.icon = this.icon;
    if (this.label !== this.id)
      object.label = this.label;
    return object;
  }
  toString() {
    return this.label;
  }
  urlIcon(url, loader, size) {
    const imageUrl = urlPrependProtocol("image", url);
    return loader.loadPromise(imageUrl).then((image) => {
      const { width: width2, height: height2 } = image;
      const inSize = { width: width2, height: height2 };
      const coverSize = sizeCover(inSize, size, true);
      const outRect = { ...coverSize, ...centerPoint(size, coverSize) };
      const svgUrl2 = urlPrependProtocol("svg", imageUrl, outRect);
      return loader.loadPromise(svgUrl2).then((svgImage) => {
        return svgElement(size, svgImage);
      });
    });
  }
  static fromObject(object) {
    const { id: id2, type: type2 } = object;
    assertDefinitionType(type2);
    assertPopulatedString(id2, "id");
    return Factory[type2].definition(object);
  }
};
var FilterClass = class extends InstanceBase {
  constructor(...args) {
    super(...args);
    __publicField(this, "parameters", []);
    __publicField(this, "_parametersDefined");
    const [object] = args;
    if (!isPopulatedObject(object))
      throw Errors.invalid.object + "filter";
    const { parameters } = object;
    if (parameters == null ? void 0 : parameters.length)
      this.parameters.push(...parameters.map((parameter) => {
        const { name, dataType } = parameter;
        if (!dataType) {
          const existing = this.definition.parameters.find((p) => p.name === name);
          if (existing)
            parameter.dataType = existing.dataType;
        }
        return new Parameter(parameter);
      }));
  }
  commandFilters(args) {
    return this.definition.commandFilters({ ...args, filter: this });
  }
  get parametersDefined() {
    if (this._parametersDefined)
      return this._parametersDefined;
    const parameters = [...this.parameters];
    parameters.push(...this.definition.parameters.filter((parameter) => !parameters.find((p) => p.name === parameter.name)));
    return this._parametersDefined = parameters;
  }
  filterSvg(args = {}) {
    return this.definition.filterDefinitionSvg({ ...args, filter: this });
  }
  filterSvgFilter() {
    const valueObject = this.scalarObject();
    return this.definition.filterDefinitionSvgFilter(valueObject);
  }
  scalarObject(tweening = false) {
    const object = {};
    const { parametersDefined } = this;
    parametersDefined.forEach((parameter) => {
      const { name, value } = parameter;
      if (isPopulatedString(value)) {
        const property = this.properties.find((property2) => value === property2.name);
        if (property)
          return;
      }
      if (isNumber(value) || isString(value))
        object[name] = value;
    });
    this.properties.forEach((property) => {
      const { tweenable, name } = property;
      if (isDefined(object[name]))
        return;
      object[name] = this.value(name);
      if (!(tweening && tweenable))
        return;
      const key = `${name}${PropertyTweenSuffix}`;
      object[key] = this.value(key);
    });
    return object;
  }
  toJSON() {
    const object = { id: this.definitionId };
    if (this.parameters.length)
      object.parameters = this.parameters;
    return object;
  }
  toString() {
    return `[Filter ${this.label}]`;
  }
};
var FilterDefinitionClass = class extends DefinitionBase {
  constructor() {
    super(...arguments);
    __publicField(this, "_ffmpegFilter");
    __publicField(this, "parameters", []);
    __publicField(this, "type", DefinitionType.Filter);
  }
  commandFilters(args) {
    const { filter, duration, filterInput } = args;
    assertPopulatedString(filterInput);
    const commandFilters = [];
    const options2 = filter.scalarObject(!!duration);
    assertValueObject(options2);
    const { ffmpegFilter } = this;
    const commandFilter = {
      inputs: [filterInput],
      ffmpegFilter,
      options: options2,
      outputs: [idGenerate(ffmpegFilter)]
    };
    commandFilters.push(commandFilter);
    return commandFilters;
  }
  commandFilter(options2 = {}) {
    const { ffmpegFilter } = this;
    const commandFilter = {
      ffmpegFilter,
      options: options2,
      inputs: [],
      outputs: [idGenerate(ffmpegFilter)]
    };
    return commandFilter;
  }
  get ffmpegFilter() {
    return this._ffmpegFilter || (this._ffmpegFilter = this.id.split(".").pop() || this.id);
  }
  filterDefinitionSvg(args) {
    throw new Error(Errors.unimplemented + "initialSvgContent");
  }
  instanceFromObject(object = {}) {
    return new FilterClass(this.instanceArgs(object));
  }
  populateParametersFromProperties() {
    this.parameters = this.properties.map((property) => {
      const { name } = property;
      return new Parameter({ name, value: name, dataType: DataType.String });
    });
  }
  filterDefinitionSvgFilter(valueObject) {
    throw Errors.unimplemented;
  }
  colorCommandFilter(dimensions, videoRate2 = 0, duration = 0, color2 = colorWhiteTransparent) {
    const { width: width2, height: height2 } = dimensions;
    const transparentFilter = "color";
    const transparentId = idGenerate(transparentFilter);
    const object = { color: color2, size: `${width2}x${height2}` };
    if (videoRate2)
      object.rate = videoRate2;
    if (duration)
      object.duration = duration;
    const commandFilter = {
      inputs: [],
      ffmpegFilter: transparentFilter,
      options: object,
      outputs: [transparentId]
    };
    return commandFilter;
  }
};
var ChromaKeyFilter = class extends FilterDefinitionClass {
  constructor(...args) {
    super(...args);
    this.properties.push(propertyInstance({
      custom: true,
      name: "color",
      type: DataType.String,
      defaultValue: colorGreen
    }));
    this.properties.push(propertyInstance({
      custom: true,
      name: "similarity",
      type: DataType.Percent,
      defaultValue: 0.9,
      min: 0.1,
      step: 0.01,
      max: 1
    }));
    this.properties.push(propertyInstance({
      custom: true,
      name: "blend",
      type: DataType.Percent,
      defaultValue: 0,
      step: 0.01,
      max: 1
    }));
    this.populateParametersFromProperties();
  }
  filterDefinitionSvgFilter(object) {
    const { similarity, color: color2, blend } = object;
    assertNumber(similarity);
    assertNumber(blend);
    assertPopulatedString(color2);
    const max = 255;
    const range = max * max * (1 - blend);
    const rgb = colorToRgb(color2);
    const r = 1 - similarity * (rgb.r / max);
    const g2 = 1 - similarity * (rgb.g / max);
    const b = 1 - similarity * (rgb.b / max);
    const values = `1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 ${r} ${g2} ${b} -${range} ${range}`;
    const svgFilters = [];
    const colorMatrix = {
      filter: "feColorMatrix",
      type: "matrix",
      values
    };
    svgFilters.push(svgFilter(colorMatrix));
    return svgFilters;
  }
};
var roundMethod = (rounding = "") => {
  switch (rounding) {
    case "ceil":
      return Math.ceil;
    case "floor":
      return Math.floor;
    default:
      return Math.round;
  }
};
var roundWithMethod = (number, method = "") => {
  const func = roundMethod(method);
  return func(number);
};
var pixelFromPoint = (pt, width2) => pt.y * width2 + pt.x;
var pixelToPoint = (index, width2) => ({ x: index % width2, y: Math.floor(index / width2) });
var pixelToIndex = (pixel) => pixel * 4;
var pixelRgbaAtIndex = (index, pixels) => ({
  r: pixels[index],
  g: pixels[index + 1],
  b: pixels[index + 2],
  a: pixels[index + 3]
});
var pixelRgba = (pixel, data) => pixelRgbaAtIndex(pixelToIndex(pixel), data);
var pixelSafe = (pixel, offsetPoint, size) => {
  const { x, y } = offsetPoint;
  const { width: width2, height: height2 } = size;
  const pt = pixelToPoint(pixel, width2);
  pt.x = Math.max(0, Math.min(width2 - 1, pt.x + x));
  pt.y = Math.max(0, Math.min(height2 - 1, pt.y + y));
  return pixelFromPoint(pt, width2);
};
var pixelNeighboringPixels = (pixel, size) => {
  const depth = 3;
  const pixels = [];
  const halfSize = Math.floor(depth / 2);
  for (let y = 0; y < depth; y += 1) {
    for (let x = 0; x < depth; x += 1) {
      const offsetPoint = { x: x - halfSize, y: y - halfSize };
      pixels.push(pixelSafe(pixel, offsetPoint, size));
    }
  }
  return pixels;
};
var pixelNeighboringRgbas = (pixel, data, size) => pixelNeighboringPixels(pixel, size).map((p) => pixelRgba(p, data));
var pixelColor = (value) => {
  const string = String(value);
  if (string.slice(0, 2) === "0x")
    return `#${string.slice(2)}`;
  return string;
};
var pixelPerFrame = (frames, width2, zoom = 1) => {
  if (!(frames && width2))
    return 0;
  const widthFrames = width2 / frames;
  const min = Math.min(1, widthFrames);
  const max = Math.max(1, widthFrames);
  if (zoom === 1)
    return max;
  if (!zoom)
    return min;
  return min + (max - min) * zoom;
};
var pixelFromFrame = (frame, perFrame, rounding = "ceil") => {
  if (!(frame && perFrame))
    return 0;
  const pixels = frame * perFrame;
  return roundWithMethod(pixels, rounding);
};
var pixelToFrame = (pixels, perFrame, rounding = "round") => {
  if (!(pixels && perFrame))
    return 0;
  return roundWithMethod(pixels / perFrame, rounding);
};
function pixelsMixRbga(fromRgba, toRgba, amountToMix = 1) {
  return Object.fromEntries(colorRgbaKeys.map((key) => {
    return [key, Math.round(fromRgba[key] * amountToMix + toRgba[key] * (1 - amountToMix))];
  }));
}
function pixelsMixRbg(fromRgb, toRgb, amountToMix = 1) {
  return Object.fromEntries(colorRgbKeys.map((key) => {
    return [key, Math.round(fromRgb[key] * (1 - amountToMix) + toRgb[key] * amountToMix)];
  }));
}
var pixelsRemoveRgba = (pixels, size, rgb, similarity = 0, blend = 0, accurate = false) => {
  pixelsReplaceRgba(pixels, size, rgb, colorRgbaTransparent, similarity, blend);
};
var pixelsReplaceRgba = (pixels, size, find, replace, similarity = 0, blend = 0, accurate = false) => {
  const yuv = colorRgbToYuv(find);
  let index = pixels.length / 4;
  while (index--) {
    const pixels_offset = index * 4;
    const rgbaAtIndex = pixelRgbaAtIndex(pixels_offset, pixels);
    if (isPositive(rgbaAtIndex.a)) {
      const rgbaAsYuv = colorRgbToYuv(rgbaAtIndex);
      const difference = accurate ? colorYuvBlend(yuvsFromPixelsAccurate(pixels, index, size), yuv, similarity, blend) : colorYuvDifference(rgbaAsYuv, yuv, similarity, blend);
      const mixed = pixelsMixRbga(rgbaAtIndex, replace, difference);
      pixels[pixels_offset + 3] = mixed.a;
      if (mixed.a) {
        pixels[pixels_offset] = mixed.r;
        pixels[pixels_offset + 1] = mixed.g;
        pixels[pixels_offset + 2] = mixed.b;
      }
    }
  }
};
var yuvsFromPixelsAccurate = (pixels, index, size) => {
  return pixelNeighboringRgbas(index * 4, pixels, size).map((rgb) => colorRgbToYuv(rgb));
};
var tweenPad = (outputDistance, scaledDistance, scale, offE = false, offW = false) => {
  assertPositive(scale);
  assertPositive(scaledDistance);
  const baseDistance = outputDistance - scaledDistance;
  const east = offE ? scaledDistance : 0;
  const west = offW ? scaledDistance : 0;
  const distance = baseDistance + east + west;
  const scaled = distance * scale;
  const x = scaled - east;
  return x;
};
var tweenNumberStep = (number, numberEnd, frame, frames) => {
  const unit = (numberEnd - number) / frames;
  return number + unit * frame;
};
var tweenColorStep = (value, valueEnd, frame, frames) => {
  assertString(value);
  assertString(valueEnd);
  const offset2 = frame / frames;
  assertTrue(colorValidHex(value), "hex color");
  if (value.length === 7 || value.length === 4) {
    const result = colorRgbToHex(pixelsMixRbg(colorToRgb(value), colorToRgb(valueEnd), offset2));
    return result;
  }
  return colorRgbaToHex(pixelsMixRbga(colorToRgba(value), colorToRgba(valueEnd), offset2));
};
var tweenRectStep = (rect, rectEnd, frame, frames) => {
  return {
    x: tweenNumberStep(rect.x, rectEnd.x, frame, frames),
    y: tweenNumberStep(rect.y, rectEnd.y, frame, frames),
    width: tweenNumberStep(rect.width, rectEnd.width, frame, frames),
    height: tweenNumberStep(rect.height, rectEnd.height, frame, frames)
  };
};
var tweenColors = (color2, colorEnd, frames) => {
  assertPopulatedString(color2);
  const colors = [color2];
  if (isPopulatedString(colorEnd) && frames > 1) {
    for (let frame = 1; frame < frames; frame++) {
      colors.push(tweenColorStep(color2, colorEnd, frame, frames));
    }
  }
  return colors;
};
var tweenRects = (rect, rectEnd, frames) => {
  const rects = [rect];
  if (rectEnd && frames > 1) {
    for (let frame = 1; frame < frames; frame++) {
      rects.push(tweenRectStep(rect, rectEnd, frame, frames));
    }
  }
  return rects;
};
var tweenMaxSize = (size, sizeEnd) => {
  const { width: width2, height: height2 } = size;
  if (!isSize(sizeEnd) || sizesEqual(size, sizeEnd))
    return { width: width2, height: height2 };
  return {
    width: Math.max(width2, sizeEnd.width),
    height: Math.max(height2, sizeEnd.height)
  };
};
var tweenMinSize = (size, sizeEnd) => {
  const { width: width2, height: height2 } = size;
  if (!isSize(sizeEnd) || sizesEqual(size, sizeEnd))
    return { width: width2, height: height2 };
  return {
    width: Math.min(width2, sizeEnd.width),
    height: Math.min(height2, sizeEnd.height)
  };
};
var tweenOption = (optionStart, optionEnd, pos, round) => {
  assertNumber(optionStart);
  const start = round ? Math.round(optionStart) : optionStart;
  if (!isNumber(optionEnd))
    return start;
  const end = round ? Math.round(optionEnd) : optionEnd;
  if (start === end)
    return start;
  pos.includes("n") ? "n" : "N";
  return `(${start}+(${end - start}*${pos}))`;
};
var tweenableRects = (rect, rectEnd) => {
  if (!isRect(rectEnd))
    return false;
  if (rect.x !== rectEnd.x)
    return true;
  if (rect.y !== rectEnd.y)
    return true;
  if (rect.width !== rectEnd.width)
    return true;
  if (rect.height !== rectEnd.height)
    return true;
  return false;
};
var tweenPosition = (videoRate2, duration, frame = "n") => `(${frame}/${videoRate2 * duration})`;
var tweenNumberObject = (object) => {
  if (!isObject(object))
    return {};
  const entries = Object.entries(object).filter(([_, value]) => isNumber(value));
  return Object.fromEntries(entries);
};
var tweenOverRect = (rect, rectEnd) => {
  return { ...rect, ...tweenNumberObject(rectEnd) };
};
var tweenOverPoint = (point, pointEnd) => {
  return { ...point, ...tweenNumberObject(pointEnd) };
};
var tweenOverSize = (point, pointEnd) => {
  if (!isDefined(pointEnd))
    return point;
  return { ...point, ...tweenNumberObject(pointEnd) };
};
var tweenScaleSizeToRect = (size, rect, offDirections = {}) => {
  assertSize(size);
  assertRect(rect);
  const { width: outWidth, height: outHeight } = size;
  const { x, y, width: width2, height: height2 } = rect;
  assertPositive(x);
  assertPositive(y);
  assertPositive(width2);
  assertPositive(height2);
  const scaledSize = sizeScale(size, width2, height2);
  const evenSize = sizeCeil(scaledSize);
  const result = {
    ...evenSize,
    x: Math.round(tweenPad(outWidth, evenSize.width, x, offDirections.E, offDirections.W)),
    y: Math.round(tweenPad(outHeight, evenSize.height, y, offDirections.N, offDirections.S))
  };
  return result;
};
var tweenCoverSizes = (inSize, outSize, scales) => {
  const outSizes = isArray(outSize) ? outSize : [outSize, outSize];
  const [rect, rectEnd] = outSizes;
  const unscaledSize = sizeCover(inSize, rect);
  const unscaledSizeEnd = sizeCover(inSize, rectEnd);
  const [scale, scaleEnd] = scales;
  const { width: width2, height: height2 } = scale;
  const { width: widthEnd, height: heightEnd } = scaleEnd;
  const scaledSize = sizeScale(unscaledSize, width2, height2);
  const scaledSizeEnd = sizeScale(unscaledSizeEnd, widthEnd, heightEnd);
  const coverSize = sizeCeil(scaledSize);
  const coverSizeEnd = sizeCeil(scaledSizeEnd);
  const coverRects = [coverSize, coverSizeEnd];
  return coverRects;
};
var tweenCoverPoints = (scaledSizes, outSize, scales) => {
  const outSizes = isArray(outSize) ? outSize : [outSize, outSize];
  const [coverSize, coverSizeEnd] = scaledSizes;
  const [rect, rectEnd] = outSizes;
  const [scale, scaleEnd] = scales;
  const { x, y } = scale;
  const { x: xEnd, y: yEnd } = scaleEnd;
  const point = {
    x: x * (coverSize.width - rect.width),
    y: y * (coverSize.height - rect.height)
  };
  const pointEnd = {
    x: xEnd * (coverSizeEnd.width - rectEnd.width),
    y: yEnd * (coverSizeEnd.height - rectEnd.height)
  };
  return [point, pointEnd];
};
var tweenRectLock = (rect, lock) => ({
  ...rect,
  ...sizeLock(rect, lock)
});
var tweenRectsLock = (rects, lock) => {
  return rects.map((rect) => tweenRectLock(rect, lock));
};
var tweenScaleSizeRatioLock = (scale, outputSize, inRatio, lock) => {
  if (!lock)
    return scale;
  const { width: outWidth, height: outHeight } = outputSize;
  const forcedScale = { ...scale };
  switch (lock) {
    case Orientation.H:
      forcedScale.width = outHeight * forcedScale.height * inRatio / outWidth;
      break;
    case Orientation.V:
      forcedScale.height = outWidth * forcedScale.width / inRatio / outHeight;
      break;
  }
  return forcedScale;
};
var tweeningPoints = (tweenable) => {
  assertTweenable(tweenable);
  const { clip } = tweenable;
  const { track } = clip;
  const { mash } = track;
  const { quantize } = mash;
  const timeRange = clip.timeRange(quantize);
  const tweenPoints = tweenable.tweenPoints(timeRange, timeRange);
  return !pointsEqual(...tweenPoints);
};
var tweenMinMax = (value, min, max) => {
  return Math.min(max, Math.max(min, value));
};
var tweenInputTime = (timeRange, onEdge, nearStart, endDefined, endSelected) => {
  if (!endDefined)
    return;
  if (!onEdge)
    return nearStart ? timeRange.startTime : timeRange.lastTime;
  if (endSelected) {
    if (nearStart)
      return timeRange.lastTime;
  } else if (!nearStart)
    return timeRange.startTime;
};
var ColorizeFilter = class extends FilterDefinitionClass {
  constructor(...args) {
    super(...args);
    __publicField(this, "_ffmpegFilter", "geq");
    this.properties.push(propertyInstance({
      tweenable: true,
      custom: true,
      name: "color",
      type: DataType.String
    }));
    this.populateParametersFromProperties();
  }
  commandFilters(args) {
    const commandFilters = [];
    const { filter, videoRate: videoRate2, duration, filterInput: input } = args;
    assertNumber(duration, "duration");
    assertNumber(videoRate2, "videoRate");
    const color2 = filter.value("color");
    assertPopulatedString(color2, "color");
    let filterInput = input;
    assertPopulatedString(filterInput, "filterInput");
    const formatFilter = "format";
    const formatId = idGenerate(formatFilter);
    const formatCommandFilter = {
      inputs: [filterInput],
      ffmpegFilter: formatFilter,
      options: { pix_fmts: "rgba" },
      outputs: [formatId]
    };
    commandFilters.push(formatCommandFilter);
    filterInput = formatId;
    const colorEnd = filter.value(`color${PropertyTweenSuffix}`) || color2;
    assertPopulatedString(colorEnd);
    const alpha = color2.length > 7;
    const fromColor = alpha ? colorToRgba(color2) : colorToRgb(color2);
    const toColor = alpha ? colorToRgba(colorEnd) : colorToRgb(colorEnd);
    const keys = alpha ? colorRgbaKeys : colorRgbKeys;
    const options2 = {};
    const position = duration ? tweenPosition(videoRate2, duration, "N") : 0;
    keys.forEach((key) => {
      const from = fromColor[key];
      const to = toColor[key];
      if (from === to)
        options2[key] = from;
      else
        options2[key] = `${from}+(${to - from}*${position})`;
    });
    if (!alpha)
      options2.a = "alpha(X,Y)";
    const geqFilter = "geq";
    const geqFilterId = idGenerate(geqFilter);
    const geqCommandFilter = {
      inputs: [filterInput],
      ffmpegFilter: geqFilter,
      options: options2,
      outputs: [geqFilterId]
    };
    commandFilters.push(geqCommandFilter);
    return commandFilters;
  }
};
var ColorFilter = class extends ColorizeFilter {
  constructor(...args) {
    super(...args);
    __publicField(this, "_ffmpegFilter", "color");
    this.properties.push(propertyInstance({
      tweenable: true,
      name: "color",
      type: DataType.String
    }));
    const keys = ["width", "height"];
    keys.forEach((name) => {
      this.properties.push(propertyInstance({
        tweenable: true,
        name,
        type: DataType.Number
      }));
    });
    this.populateParametersFromProperties();
  }
  commandFilters(args) {
    const commandFilters = [];
    const { filter, videoRate: videoRate2, duration } = args;
    assertAboveZero(videoRate2, "videoRate");
    const { ffmpegFilter } = this;
    let filterInput = idGenerate(ffmpegFilter);
    const color2 = filter.value("color");
    assertPopulatedString(color2);
    const colorEnd = duration ? filter.value(`color${PropertyTweenSuffix}`) : void 0;
    const tweeningColor = isPopulatedString(colorEnd) && color2 !== colorEnd;
    const scalars = filter.scalarObject(!!duration);
    assertSize(scalars);
    const { width: width2, height: height2 } = scalars;
    let tweeningSize = false;
    const startSize = { width: width2, height: height2 };
    const endSize = { width: width2, height: height2 };
    if (duration) {
      const { [`width${PropertyTweenSuffix}`]: widthEnd = width2, [`height${PropertyTweenSuffix}`]: heightEnd = height2 } = scalars;
      assertNumber(widthEnd);
      assertNumber(heightEnd);
      tweeningSize = !(width2 === widthEnd && height2 === heightEnd);
      if (tweeningSize) {
        endSize.width = widthEnd;
        endSize.height = heightEnd;
      }
    }
    const maxSize = tweeningSize ? tweenMaxSize(startSize, endSize) : startSize;
    const colorCommandFilter = {
      inputs: [],
      ffmpegFilter,
      options: {
        color: color2,
        rate: videoRate2,
        size: Object.values(maxSize).join("x")
      },
      outputs: [filterInput]
    };
    if (isAboveZero(duration))
      colorCommandFilter.options.duration = duration;
    commandFilters.push(colorCommandFilter);
    if (tweeningColor) {
      const fadeFilter = "fade";
      const fadeFilterId = idGenerate(fadeFilter);
      const fadeCommandFilter = {
        inputs: [filterInput],
        ffmpegFilter: fadeFilter,
        options: {
          type: "out",
          color: colorEnd,
          duration
        },
        outputs: [fadeFilterId]
      };
      commandFilters.push(fadeCommandFilter);
      filterInput = fadeFilterId;
    }
    if (tweeningSize) {
      const scaleFilter = "scale";
      const scaleFilterId = idGenerate(scaleFilter);
      const position = tweenPosition(videoRate2, duration);
      const scaleCommandFilter = {
        inputs: [filterInput],
        ffmpegFilter: scaleFilter,
        options: {
          eval: "frame",
          width: tweenOption(startSize.width, endSize.width, position),
          height: tweenOption(startSize.height, endSize.height, position)
        },
        outputs: [scaleFilterId]
      };
      commandFilters.push(scaleCommandFilter);
    }
    return commandFilters;
  }
  filterDefinitionSvg(args) {
    const { filter } = args;
    const valueObject = filter.scalarObject(false);
    const { width: width2, height: height2, color: color2 } = valueObject;
    assertPopulatedString(color2);
    const rectElement = globalThis.document.createElementNS(NamespaceSvg, "rect");
    rectElement.setAttribute("width", String(width2));
    rectElement.setAttribute("height", String(height2));
    rectElement.setAttribute("fill", pixelColor(color2));
    return rectElement;
  }
};
var ColorChannelMixerFilterKeys = colorRgbaKeys.flatMap((c) => colorRgbaKeys.map((d) => `${c}${d}`));
var ColorChannelMixerFilter = class extends FilterDefinitionClass {
  constructor(...args) {
    super(...args);
    ColorChannelMixerFilterKeys.forEach((name) => {
      this.properties.push(propertyInstance({
        custom: true,
        name,
        type: DataType.Number,
        defaultValue: name[0] === name[1] ? 1 : 0,
        min: 0,
        max: 1
      }));
    });
    this.populateParametersFromProperties();
  }
  filterDefinitionSvgFilter(object) {
    const bits = colorRgbaKeys.flatMap((c) => [...colorRgbaKeys.map((d) => Number(object[`${c}${d}`])), 0]);
    const options2 = {
      filter: "feColorMatrix",
      type: "matrix",
      values: bits.join(" ")
    };
    return [svgFilter(options2)];
  }
};
var ActivityType;
(function(ActivityType2) {
  ActivityType2["Analyze"] = "analyze";
  ActivityType2["Complete"] = "complete";
  ActivityType2["Error"] = "error";
  ActivityType2["Load"] = "load";
  ActivityType2["Render"] = "render";
})(ActivityType || (ActivityType = {}));
var commandFilesInputIndex = (commandFiles, id2) => {
  const inputCommandFiles = commandFiles.filter((commandFile) => commandFile.input);
  const inputIndex = inputCommandFiles.findIndex((commandFile) => commandFile.inputId === id2);
  if (!isPositive(inputIndex))
    console.log("commandFilesInputIndex", id2, inputCommandFiles);
  assertPositive(inputIndex, "commandFilesInputIndex");
  return inputIndex;
};
var commandFilesInput = (commandFiles, id2, visible) => [commandFilesInputIndex(commandFiles, id2), visible ? "v" : "a"].join(":");
var eventStop = (event) => {
  event.preventDefault();
  event.stopPropagation();
};
var fetchCallback = (apiCallback) => {
  var _a;
  const { endpoint, request } = apiCallback;
  const init = request || {};
  const typeKey = "Content-Type";
  const jsonType = "application/json";
  const formType = "multipart/form-data";
  init.method || (init.method = "POST");
  init.headers || (init.headers = {});
  (_a = init.headers)[typeKey] || (_a[typeKey] = jsonType);
  switch (init.headers[typeKey]) {
    case jsonType: {
      init.body = JSON.stringify(init.body);
      break;
    }
    case formType: {
      const formData = new FormData();
      Object.entries(init.body).forEach(([key, value]) => {
        if (isUndefined(value))
          return;
        formData.set(key, value instanceof Blob ? value : String(value));
      });
      init.body = formData;
      delete init.headers[typeKey];
      break;
    }
  }
  const url = urlForEndpoint(endpoint);
  return fetch(url, init).then((response) => response.json());
};
var isSelectedProperty = (value) => {
  return isObject(value) && "changeHandler" in value;
};
var selectedPropertyObject = (properties2, group, selectType) => {
  const filtered = properties2.filter((prop) => {
    if (!isSelectedProperty(prop))
      return false;
    return prop.property.group === group && prop.selectType === selectType;
  });
  const byName = Object.fromEntries(filtered.map((selected) => {
    const { name: nameOveride, property } = selected;
    const { name } = property;
    return [nameOveride || name, selected];
  }));
  return byName;
};
var selectedPropertiesScalarObject = (byName) => {
  return Object.fromEntries(Object.entries(byName).map((entry) => {
    return [entry[0], entry[1].value];
  }));
};
var sortByFrame = (a, b) => a.frame - b.frame;
var sortByIndex = (a, b) => a.index - b.index;
var sortByTrack = (a, b) => a.trackNumber - b.trackNumber;
var sortByLabel = (a, b) => {
  if (a.label < b.label)
    return -1;
  if (a.label > b.label)
    return 1;
  return 0;
};
var stringSeconds = (seconds, fps = 0, lengthSeconds = 0) => {
  const bits = [];
  let pad = 2;
  let time = 60 * 60;
  let do_rest = false;
  const duration = lengthSeconds || seconds;
  if (duration >= time) {
    if (seconds >= time) {
      bits.push(String(Math.floor(seconds / time)).padStart(pad, "0"));
      do_rest = true;
      seconds = seconds % time;
    } else
      bits.push("00:");
  }
  time = 60;
  if (do_rest || duration >= time) {
    if (do_rest)
      bits.push(":");
    if (seconds >= time) {
      bits.push(String(Math.floor(seconds / time)).padStart(pad, "0"));
      do_rest = true;
      seconds = seconds % time;
    } else
      bits.push("00:");
  }
  time = 1;
  if (do_rest || duration >= time) {
    if (do_rest)
      bits.push(":");
    if (seconds >= time) {
      bits.push(String(Math.floor(seconds / time)).padStart(pad, "0"));
      do_rest = true;
      seconds = seconds % time;
    } else {
      bits.push("00");
    }
  } else {
    bits.push("00");
  }
  if (fps > 1) {
    if (fps === 10)
      pad = 1;
    bits.push(".");
    if (seconds) {
      if (pad === 1)
        seconds = Math.round(seconds * 10) / 10;
      else
        seconds = Math.round(100 * seconds) / 100;
      seconds = Number(String(seconds).slice(2));
      bits.push(String(seconds).padEnd(pad, "0"));
    } else {
      bits.push("0".padStart(pad, "0"));
    }
  }
  return bits.join("");
};
var stringFamilySizeRect = (string, family, size) => {
  if (!(isPopulatedString(string) && isAboveZero(size)))
    return RectZero;
  const { document: document2 } = globalThis;
  const canvas = document2.createElement("canvas");
  const ctx = canvas.getContext("2d");
  assertObject(ctx);
  ctx.font = `${size}px ${family}`;
  const metrics = ctx.measureText(string);
  const { actualBoundingBoxAscent, actualBoundingBoxDescent, actualBoundingBoxLeft, actualBoundingBoxRight, width: width2 } = metrics;
  return {
    x: actualBoundingBoxLeft,
    y: actualBoundingBoxAscent,
    width: actualBoundingBoxLeft + actualBoundingBoxRight,
    height: actualBoundingBoxAscent + actualBoundingBoxDescent
  };
};
var stringPluralize = (count, value, suffix = "s") => {
  if (!isPopulatedString(value))
    return value;
  return `${count} ${value}${count === 1 ? "" : suffix}`;
};
var ConvolutionFilter = class extends FilterDefinitionClass {
  constructor(...args) {
    super(...args);
    this.properties.push(propertyInstance({
      custom: true,
      name: "bias",
      defaultValue: 0,
      min: 0,
      max: 100,
      step: 0.01
    }));
    this.properties.push(propertyInstance({
      custom: true,
      name: "matrix",
      defaultValue: "0 0 0 0 1 0 0 0 0"
    }));
    this.properties.push(propertyInstance({
      custom: true,
      name: "multiplier",
      defaultValue: 1,
      min: 0,
      max: 100,
      step: 0.01
    }));
    this.populateParametersFromProperties();
  }
  commandFilters(args) {
    const { filterInput, filter, duration } = args;
    assertPopulatedString(filterInput, "filterInput");
    const commandFilters = [];
    const values = filter.scalarObject(!!duration);
    assertConvolutionServerFilter(values);
    const { ffmpegFilter } = this;
    const commandFilter = {
      inputs: [filterInput],
      ffmpegFilter,
      options: optionsFromObject(parse(values)),
      outputs: [idGenerate(ffmpegFilter)]
    };
    commandFilters.push(commandFilter);
    return commandFilters;
  }
  filterDefinitionSvgFilter(valueObject) {
    assertConvolutionServerFilter(valueObject);
    const { matrix, bias, multiplier } = valueObject;
    const object = {
      filter: "feConvolveMatrix",
      kernelMatrix: String(matrix),
      bias: String(bias)
    };
    if (isAboveZero(multiplier))
      object.divisor = String(multiplier);
    return [svgFilter(object)];
  }
};
var isConvolutionServerFilter = (value) => {
  return isObject(value) && "matrix" in value && "bias" in value && "multiplier" in value;
};
function assertConvolutionServerFilter(value) {
  if (!isConvolutionServerFilter(value))
    throw new Error("expected ConvolutionServerFilter");
}
var matrixFromString = (string) => {
  const definedString = string || "0 0 0 0 1 0 0 0 0";
  return definedString.split(",").map((component) => parseInt(component.trim()));
};
var biasFromString = (string) => {
  if (!(string == null ? void 0 : string.length))
    return 0;
  return parseFloat(string.trim());
};
var multiplierFromString = (string) => {
  if (!(string == null ? void 0 : string.length))
    return 1;
  if (string.includes("/")) {
    const components = string.split("/").map((component) => parseFloat(component.trim()));
    const [a, b] = components;
    return a / b;
  }
  return parseFloat(string.trim());
};
var fromCombined = (combined) => {
  return { combined, r: combined, g: combined, b: combined, a: combined };
};
var numbersFromCombined = (combined) => {
  return { combined, r: combined, g: combined, b: combined, a: combined };
};
var numberFromCombined = (combined) => {
  return { combined, r: combined, g: combined, b: combined, a: combined };
};
var convolutionStringObject = (combined) => {
  return fromCombined(String(combined));
};
var convolutionMatrixObject = (stringObject) => {
  const { combined } = stringObject;
  return numbersFromCombined(matrixFromString(String(combined)));
};
var convolutionBiasObject = (stringObject) => {
  const { combined } = stringObject;
  return numberFromCombined(biasFromString(String(combined)));
};
var convolutionMultiplierObject = (stringObject) => {
  const { combined } = stringObject;
  return numberFromCombined(multiplierFromString(String(combined)));
};
var parse = (convolutionObject) => {
  const matrixObject = convolutionStringObject(convolutionObject.matrix);
  const multiplierObject = convolutionStringObject(convolutionObject.multiplier);
  const matrix = convolutionMatrixObject(matrixObject);
  const multiplier = convolutionMultiplierObject(multiplierObject);
  const bias = matrixObject.combined ? numberFromCombined(0) : convolutionBiasObject(convolutionStringObject(convolutionObject.bias));
  const result = { multiplier, matrix, bias };
  return result;
};
var optionsFromObject = (convolutionObject) => {
  const valueObject = {};
  colorRgbaKeys.map((c) => c).forEach((channel, index) => {
    const multiplier = convolutionObject.multiplier[channel];
    const matrix = convolutionObject.matrix[channel];
    valueObject[`${index}m`] = matrix.join(" ");
    valueObject[`${index}rdiv`] = multiplier;
    valueObject[`${index}bias`] = convolutionObject.bias[channel];
  });
  return valueObject;
};
var CropFilter = class extends FilterDefinitionClass {
  constructor(...args) {
    super(...args);
    this.properties.push(propertyInstance({
      custom: true,
      name: "width",
      type: DataType.String
    }));
    this.properties.push(propertyInstance({
      custom: true,
      name: "height",
      type: DataType.String
    }));
    this.properties.push(propertyInstance({
      tweenable: true,
      custom: true,
      name: "x",
      type: DataType.Number,
      defaultValue: 0,
      min: 0,
      step: 1
    }));
    this.properties.push(propertyInstance({
      tweenable: true,
      custom: true,
      name: "y",
      type: DataType.Number,
      defaultValue: 0,
      min: 0,
      step: 1
    }));
    this.populateParametersFromProperties();
  }
  commandFilters(args) {
    const { filter, filterInput, duration, videoRate: videoRate2 } = args;
    assertPopulatedString(filterInput);
    const commandFilters = [];
    const scalars = filter.scalarObject(!!duration);
    const options2 = { exact: 1 };
    const position = tweenPosition(videoRate2, duration);
    options2.x = tweenOption(scalars.x, scalars[`x${PropertyTweenSuffix}`], position, true);
    options2.y = tweenOption(scalars.y, scalars[`y${PropertyTweenSuffix}`], position, true);
    const { width: width2, height: height2 } = scalars;
    if (isTrueValue(width2))
      options2.w = width2;
    if (isTrueValue(height2))
      options2.h = height2;
    const { ffmpegFilter } = this;
    const commandFilter = {
      inputs: [filterInput],
      ffmpegFilter,
      options: options2,
      outputs: [idGenerate(ffmpegFilter)]
    };
    commandFilters.push(commandFilter);
    return commandFilters;
  }
};
var OverlayFilter = class extends FilterDefinitionClass {
  constructor(...args) {
    super(...args);
    this.properties.push(propertyInstance({
      tweenable: true,
      custom: true,
      name: "x",
      type: DataType.Percent,
      defaultValue: 0.5
    }));
    this.properties.push(propertyInstance({
      tweenable: true,
      custom: true,
      name: "y",
      type: DataType.Percent,
      defaultValue: 0.5
    }));
    this.properties.push(propertyInstance({
      custom: true,
      name: "format",
      type: DataType.String,
      defaultValue: "yuv420"
      // yuv420p10
    }));
    this.properties.push(propertyInstance({
      custom: true,
      name: "alpha",
      type: DataType.String,
      defaultValue: "straight"
      // premultiplied
    }));
    this.populateParametersFromProperties();
  }
  commandFilters(args) {
    const commandFilters = [];
    const { filter, filterInput, chainInput, duration, videoRate: videoRate2 } = args;
    assertPopulatedString(filterInput, "filterInput");
    assertPopulatedString(chainInput, "chainInput");
    const scalars = filter.scalarObject(!!duration);
    const options2 = {};
    const { format: format2, alpha } = scalars;
    if (isPopulatedString(format2))
      options2.format = format2;
    if (isPopulatedString(alpha))
      options2.alpha = alpha;
    const position = tweenPosition(videoRate2, duration, "(n-1)");
    const x = tweenOption(scalars.x, scalars[`x${PropertyTweenSuffix}`], position, true);
    const y = tweenOption(scalars.y, scalars[`y${PropertyTweenSuffix}`], position, true);
    const xZero = x === 0;
    const yZero = y === 0;
    if (!xZero)
      options2.x = x;
    if (!yZero)
      options2.y = y;
    const ffmpegFilter = "overlay";
    const commandFilter = {
      inputs: [chainInput, filterInput],
      ffmpegFilter,
      options: options2,
      outputs: []
    };
    commandFilters.push(commandFilter);
    return commandFilters;
  }
};
var ScaleFilter = class extends FilterDefinitionClass {
  constructor(...args) {
    super(...args);
    this.properties.push(propertyInstance({
      name: "width",
      type: DataType.Percent,
      defaultValue: 1,
      max: 2
    }));
    this.properties.push(propertyInstance({
      name: "height",
      type: DataType.Percent,
      defaultValue: 1,
      max: 2
    }));
    this.properties.push(propertyInstance({
      name: `width${PropertyTweenSuffix}`,
      type: DataType.Percent,
      defaultValue: 1,
      max: 2
    }));
    this.properties.push(propertyInstance({
      name: `height${PropertyTweenSuffix}`,
      type: DataType.Percent,
      defaultValue: 1,
      max: 2
    }));
    this.populateParametersFromProperties();
  }
  commandFilters(args) {
    const commandFilters = [];
    const { filter, duration, filterInput, videoRate: videoRate2 } = args;
    const values = filter.scalarObject(!!duration);
    const { width: width2, height: height2, [`width${PropertyTweenSuffix}`]: widthEnd, [`height${PropertyTweenSuffix}`]: heightEnd } = values;
    assertPopulatedString(filterInput);
    const { ffmpegFilter } = this;
    const position = tweenPosition(videoRate2, duration);
    const options2 = {
      width: tweenOption(width2, widthEnd, position, true),
      height: tweenOption(height2, heightEnd, position, true)
      // sws_flags: 'accurate_rnd',
    };
    if (!(isNumber(options2.width) && isNumber(options2.height)))
      options2.eval = "frame";
    const commandFilter = {
      inputs: [filterInput],
      ffmpegFilter,
      options: options2,
      outputs: [idGenerate(ffmpegFilter)]
    };
    commandFilters.push(commandFilter);
    return commandFilters;
  }
};
var OpacityFilter = class extends FilterDefinitionClass {
  constructor(...args) {
    super(...args);
    __publicField(this, "_ffmpegFilter", "geq");
    this.properties.push(propertyInstance({
      tweenable: true,
      custom: true,
      name: "opacity",
      type: DataType.Number,
      defaultValue: 1
    }));
    this.populateParametersFromProperties();
  }
  commandFilters(args) {
    const commandFilters = [];
    const { filterInput: input, filter, duration, videoRate: videoRate2 } = args;
    const opacity = filter.value("opacity");
    let filterInput = input;
    assertNumber(opacity);
    assertPopulatedString(filterInput, "filterInput");
    const options2 = {
      lum: "lum(X,Y)",
      cb: "cb(X,Y)",
      cr: "cr(X,Y)",
      a: `alpha(X,Y)*${opacity}`
    };
    if (duration) {
      const opacityEnd = filter.value(`opacity${PropertyTweenSuffix}`);
      if (isNumber(opacityEnd) && opacity != opacityEnd) {
        const position = tweenPosition(videoRate2, duration, "N");
        const toValue = opacityEnd - opacity;
        options2.a = `alpha(X,Y)*(${opacity}+(${toValue}*${position}))`;
      }
    }
    const { ffmpegFilter } = this;
    const commandFilter = {
      inputs: [filterInput],
      ffmpegFilter,
      options: options2,
      outputs: [idGenerate(ffmpegFilter)]
    };
    commandFilters.push(commandFilter);
    return commandFilters;
  }
  filterDefinitionSvgFilter(valueObject) {
    const { opacity } = valueObject;
    assertNumber(opacity);
    const filterElement = globalThis.document.createElementNS(NamespaceSvg, "feColorMatrix");
    filterElement.setAttribute("type", "matrix");
    const values = `1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 ${opacity} 0`;
    svgSet(filterElement, values, "values");
    return [filterElement];
  }
};
var SetsarFilter = class extends FilterDefinitionClass {
  constructor(...args) {
    super(...args);
    this.properties.push(propertyInstance({
      custom: true,
      name: "sar",
      type: DataType.String,
      defaultValue: "0"
    }));
    this.properties.push(propertyInstance({
      custom: true,
      name: "max",
      type: DataType.Number,
      defaultValue: 100
    }));
    this.populateParametersFromProperties();
  }
};
var FpsFilter = class extends FilterDefinitionClass {
  constructor(...args) {
    super(...args);
    this.properties.push(propertyInstance({
      custom: true,
      name: "fps",
      type: DataType.Number
    }));
    this.populateParametersFromProperties();
  }
};
var SetptsFilter = class extends FilterDefinitionClass {
  constructor(...args) {
    super(...args);
    this.properties.push(propertyInstance({
      custom: true,
      name: "expr",
      type: DataType.String,
      defaultValue: "PTS-STARTPTS"
    }));
    this.populateParametersFromProperties();
  }
};
var AlphamergeFilter = class extends FilterDefinitionClass {
  commandFilters(args) {
    const commandFilters = [];
    const { chainInput, filterInput } = args;
    assertPopulatedString(chainInput, "chainInput");
    assertPopulatedString(filterInput, "filterInput");
    const { ffmpegFilter } = this;
    const commandFilter = {
      inputs: [chainInput, filterInput],
      ffmpegFilter,
      options: {},
      outputs: [idGenerate(ffmpegFilter)]
    };
    commandFilters.push(commandFilter);
    return commandFilters;
  }
};
var TrimFilter = class extends FilterDefinitionClass {
  constructor(...args) {
    super(...args);
    this.properties.push(propertyInstance({
      custom: true,
      name: "start",
      type: DataType.Number,
      defaultValue: 0
    }));
    this.populateParametersFromProperties();
  }
};
var TextFilter = class extends ColorizeFilter {
  constructor(...args) {
    super(...args);
    __publicField(this, "_ffmpegFilter", "drawtext");
    this.properties.push(propertyInstance({
      custom: true,
      type: DataType.String,
      name: "fontfile"
    }));
    this.properties.push(propertyInstance({
      custom: true,
      type: DataType.String,
      name: "textfile"
    }));
    this.properties.push(propertyInstance({
      custom: true,
      type: DataType.Boolean,
      name: "stretch"
    }));
    this.properties.push(propertyInstance({
      tweenable: true,
      custom: true,
      type: DataType.Number,
      name: "height"
    }));
    this.properties.push(propertyInstance({
      tweenable: true,
      custom: true,
      type: DataType.Number,
      name: "width"
    }));
    this.properties.push(propertyInstance({
      custom: true,
      type: DataType.Number,
      name: "intrinsicHeight"
    }));
    this.properties.push(propertyInstance({
      custom: true,
      type: DataType.Number,
      name: "intrinsicWidth"
    }));
    this.properties.push(propertyInstance({
      tweenable: true,
      custom: true,
      type: DataType.Number,
      name: "x"
    }));
    this.properties.push(propertyInstance({
      tweenable: true,
      custom: true,
      type: DataType.Number,
      name: "y"
    }));
    this.properties.push(propertyInstance({
      tweenable: true,
      custom: true,
      type: DataType.String,
      name: "color"
    }));
    this.populateParametersFromProperties();
  }
  commandFilters(args) {
    const commandFilters = [];
    const { filter, duration, videoRate: videoRate2, filterInput: contentOutput } = args;
    const color2 = filter.value("color");
    const x = filter.value("x");
    const y = filter.value("y");
    const textfile = filter.value("textfile");
    const fontfile = filter.value("fontfile");
    const height2 = filter.value("height");
    const width2 = filter.value("width");
    const stretch = !!filter.value("stretch");
    const intrinsicWidth = filter.value("intrinsicWidth");
    const intrinsicHeight = filter.value("intrinsicHeight");
    assertPopulatedString(textfile);
    assertPopulatedString(fontfile);
    assertNumber(height2);
    assertNumber(width2);
    assertNumber(intrinsicWidth);
    assertNumber(intrinsicHeight);
    assertNumber(x);
    assertNumber(y);
    assertPopulatedString(color2, "color");
    const xEnd = filter.value(`x${PropertyTweenSuffix}`);
    const yEnd = filter.value(`y${PropertyTweenSuffix}`);
    const colorEnd = duration ? filter.value(`color${PropertyTweenSuffix}`) : void 0;
    const tweeningColor = isPopulatedString(colorEnd) && color2 !== colorEnd;
    const { ffmpegFilter } = this;
    const drawtextId = idGenerate(ffmpegFilter);
    const foreColor = tweeningColor || contentOutput ? colorWhite : color2;
    let backColor = colorBlack;
    if (!contentOutput) {
      backColor = tweeningColor ? colorBlackTransparent : colorWhiteTransparent;
    }
    const size = { width: width2, height: height2 };
    const sizeEnd = { ...size };
    if (duration) {
      const heightEnd = filter.value(`height${PropertyTweenSuffix}`) || 0;
      const widthEnd = filter.value(`width${PropertyTweenSuffix}`) || 0;
      if (isAboveZero(widthEnd))
        sizeEnd.width = widthEnd;
      if (isAboveZero(heightEnd))
        sizeEnd.height = heightEnd;
    }
    const ratio = intrinsicWidth / intrinsicHeight;
    const maxSize = tweenMaxSize(size, sizeEnd);
    const calculatedWidth = Math.round(ratio * maxSize.height);
    if (calculatedWidth > maxSize.width)
      maxSize.width = calculatedWidth;
    let scaling = stretch || !sizesEqual(size, sizeEnd);
    const scaleOptions = {};
    const textOptions = {
      fontsize: maxSize.height,
      fontfile,
      textfile,
      x: Math.ceil(isNumber(xEnd) ? Math.max(x, xEnd) : x),
      y: Math.ceil(isNumber(yEnd) ? Math.max(y, yEnd) : y)
      // fix_bounds: 1,
    };
    const position = tweenPosition(videoRate2, duration);
    if (tweeningColor) {
      const alpha = color2.length > 7;
      const fromColor = alpha ? colorToRgba(color2) : colorToRgb(color2);
      const toColor = alpha ? colorToRgba(colorEnd) : colorToRgb(colorEnd);
      const keys = alpha ? colorRgbaKeys : colorRgbKeys;
      const calcs = keys.map((key) => {
        const from = fromColor[key];
        const to = toColor[key];
        return from === to ? from : `${from}+(${to - from}*${position})`;
      });
      const calls = calcs.map((calc) => ["eif", calc, "x", 2].join(":"));
      const expressions = calls.map((call) => `%{${call}}`);
      textOptions.fontcolor_expr = `#${expressions.join("")}`;
    } else
      textOptions.fontcolor = foreColor;
    const colorCommand = this.colorCommandFilter(maxSize, videoRate2, duration, backColor);
    commandFilters.push(colorCommand);
    let filterInput = arrayLast(colorCommand.outputs);
    if (scaling) {
      scaleOptions.width = stretch ? tweenOption(width2, sizeEnd.width, position, true) : -1;
      scaleOptions.height = tweenOption(height2, sizeEnd.height, position, true);
      if (!(isNumber(scaleOptions.width) && isNumber(scaleOptions.height))) {
        scaleOptions.eval = "frame";
      }
    }
    const drawtextFilter = {
      inputs: [filterInput],
      ffmpegFilter,
      options: textOptions,
      outputs: [drawtextId]
    };
    commandFilters.push(drawtextFilter);
    filterInput = drawtextId;
    if (!contentOutput) {
      const formatFilter = "format";
      const formatId = idGenerate(formatFilter);
      const formatCommandFilter = {
        inputs: [filterInput],
        ffmpegFilter: formatFilter,
        options: { pix_fmts: "yuva420p" },
        outputs: [formatId]
      };
      commandFilters.push(formatCommandFilter);
      filterInput = formatId;
    }
    if (scaling) {
      const scaleFilter = "scale";
      const scaleFilterId = idGenerate(scaleFilter);
      const scaleCommandFilter = {
        inputs: [filterInput],
        ffmpegFilter: scaleFilter,
        options: scaleOptions,
        outputs: [scaleFilterId]
      };
      commandFilters.push(scaleCommandFilter);
      filterInput = scaleFilterId;
    }
    return commandFilters;
  }
};
var FilterIdPrefix = `${IdPrefix}filter.`;
var filterDefaults = [
  new AlphamergeFilter({ id: `${FilterIdPrefix}alphamerge` }),
  new ChromaKeyFilter({ id: `${FilterIdPrefix}chromakey` }),
  new ColorChannelMixerFilter({ id: `${FilterIdPrefix}colorchannelmixer` }),
  new ColorFilter({ id: `${FilterIdPrefix}color` }),
  new ColorizeFilter({ id: `${FilterIdPrefix}colorize` }),
  new ConvolutionFilter({ id: `${FilterIdPrefix}convolution` }),
  new CropFilter({ id: `${FilterIdPrefix}crop` }),
  new FpsFilter({ id: `${FilterIdPrefix}fps` }),
  new OpacityFilter({ id: `${FilterIdPrefix}opacity` }),
  new OverlayFilter({ id: `${FilterIdPrefix}overlay` }),
  new ScaleFilter({ id: `${FilterIdPrefix}scale` }),
  new SetptsFilter({ id: `${FilterIdPrefix}setpts` }),
  new SetsarFilter({ id: `${FilterIdPrefix}setsar` }),
  new TrimFilter({ id: `${FilterIdPrefix}trim` }),
  new TextFilter({ id: `${FilterIdPrefix}text` })
];
var filterDefinition = (object) => {
  const { id: id2 } = object;
  assertPopulatedString(id2);
  return new FilterDefinitionClass(object);
};
var filterDefinitionFromId = (id2) => {
  const qualifiedId = id2.includes(".") ? id2 : `${FilterIdPrefix}${id2}`;
  const definition = filterDefaults.find((definition2) => definition2.id === qualifiedId);
  if (definition)
    return definition;
  return filterDefinition({ id: qualifiedId });
};
var filterInstance = (object) => {
  const { id: id2 } = object;
  if (!id2)
    throw Errors.invalid.definition.id;
  const definition = filterDefinitionFromId(id2);
  return definition.instanceFromObject(object);
};
var filterFromId = (id2) => {
  const definition = filterDefinitionFromId(id2);
  return definition.instanceFromObject({ id: id2 });
};
Factories[DefinitionType.Filter] = {
  definition: filterDefinition,
  definitionFromId: filterDefinitionFromId,
  fromId: filterFromId,
  instance: filterInstance,
  defaults: filterDefaults
};
var DefaultContentId = `${IdPrefix}content${IdSuffix}`;
var isContent = (value) => {
  return isTweenable(value) && isContentType(value.type);
};
function assertContent(value, name) {
  if (!isContent(value))
    throwError(value, "Content", name);
}
var isContentDefinition = (value) => {
  return isTweenableDefinition(value) && isContentType(value.type);
};
var isPreloadableDefinition = (value) => {
  return isContentDefinition(value) && "loadType" in value;
};
function assertPreloadableDefinition(value) {
  if (!isPreloadableDefinition(value))
    throw new Error("expected PreloadableDefinition");
}
var isPreloadable = (value) => {
  return isContent(value) && isPreloadableDefinition(value.definition);
};
function assertPreloadable(value) {
  if (!isPreloadable(value))
    throw new Error("expected Preloadable");
}
var UpdatableSizeDefinitionType = [
  DefinitionType.Image,
  DefinitionType.Video,
  DefinitionType.VideoSequence
];
var isUpdatableSize = (value) => {
  return isPreloadable(value);
};
function assertUpdatableSize(value) {
  if (!isUpdatableSize(value))
    throwError(value, "UpdatableSize");
}
var isUpdatableSizeType = (value) => {
  return isDefinitionType(value) && UpdatableSizeDefinitionType.includes(value);
};
var isUpdatableSizeDefinition = (value) => {
  return isPreloadableDefinition(value);
};
function assertUpdatableSizeDefinition(value) {
  if (!isUpdatableSizeDefinition(value))
    throwError(value, "UpdatableSizeDefinition");
}
function ContainerMixin(Base) {
  return class extends Base {
    constructor(...args) {
      super(...args);
      __publicField(this, "_colorizeFilter");
      __publicField(this, "colorMaximize", false);
      __publicField(this, "_div");
      __publicField(this, "_opacityFilter");
      __publicField(this, "_svgElement");
      const [object] = args;
      const { container } = this;
      if (container) {
        this.addProperties(object, propertyInstance({
          name: "x",
          type: DataType.Percent,
          defaultValue: 0.5,
          group: DataGroup.Point,
          tweenable: true
        }));
        this.addProperties(object, propertyInstance({
          name: "y",
          type: DataType.Percent,
          defaultValue: 0.5,
          group: DataGroup.Point,
          tweenable: true
        }));
        Directions.forEach((direction) => {
          this.addProperties(object, propertyInstance({
            name: `off${direction}`,
            type: DataType.Boolean,
            group: DataGroup.Point
          }));
        });
        this.addProperties(object, propertyInstance({
          tweenable: true,
          name: "opacity",
          type: DataType.Percent,
          defaultValue: 1,
          group: DataGroup.Opacity
        }));
      }
    }
    get colorizeFilter() {
      return this._colorizeFilter || (this._colorizeFilter = filterFromId("colorize"));
    }
    colorizeCommandFilters(args) {
      const { contentColors: colors, videoRate: videoRate2, filterInput, time } = args;
      assertPopulatedArray(colors);
      const duration = isTimeRange(time) ? time.lengthSeconds : 0;
      const { colorizeFilter } = this;
      const filterArgs = {
        videoRate: videoRate2,
        duration,
        filterInput
      };
      const [color2, colorEnd] = colors;
      colorizeFilter.setValue(color2, "color");
      colorizeFilter.setValue(colorEnd, `color${PropertyTweenSuffix}`);
      return colorizeFilter.commandFilters(filterArgs);
    }
    containedVideo(video, containerRect, size, time, range) {
      const x = Math.round(Number(video.getAttribute("x")));
      const y = Math.round(Number(video.getAttribute("y")));
      const containerPoint = pointCopy(containerRect);
      containerPoint.x -= x;
      containerPoint.y -= y;
      const zeroRect = { ...containerPoint, ...sizeCopy(containerRect) };
      const updatableContainer = isUpdatableSize(this);
      const items = [];
      const { div } = this;
      const styles = [];
      styles.push(`left: ${x}px`);
      styles.push(`top: ${y}px`);
      if (updatableContainer) {
        const file = this.intrinsicGraphFile({ size: true, editing: true });
        const { preloader } = this.clip.track.mash;
        const src = preloader.sourceUrl(file);
        styles.push(`mask-image: url(${src})`);
        styles.push("mask-repeat: no-repeat");
        styles.push("mask-mode: luminance");
        styles.push(`mask-size: ${zeroRect.width}px ${zeroRect.height}px`);
        styles.push(`mask-position: ${zeroRect.x}px ${zeroRect.y}px`);
      } else {
        const containerItem = this.pathElement(zeroRect);
        containerItem.setAttribute("fill", colorWhite);
        let clipId = idGenerateString();
        const clipElement = globalThis.document.createElementNS(NamespaceSvg, "clipPath");
        svgSet(clipElement, clipId);
        svgAppend(clipElement, containerItem);
        const svg = svgElement(size);
        svgSetChildren(svg, [svgDefsElement([clipElement])]);
        styles.push(`clip-path:${svgUrl(clipId)}`);
        items.push(svg);
      }
      div.setAttribute("style", styles.join(";") + ";");
      svgSetChildren(div, [video]);
      items.push(div);
      return Promise.resolve(items);
    }
    containedContent(content, containerRect, size, time, range, icon) {
      const updatableContainer = isUpdatableSize(this);
      const updatableContent = isUpdatableSize(content);
      const contentPromise = content.contentPreviewItemPromise(containerRect, time, range, icon);
      const containedPromise = contentPromise.then((contentItem) => {
        assertObject(contentItem);
        if (isLoadedVideo(contentItem)) {
          assertTrue(!icon, "not icon");
          return this.containedVideo(contentItem, containerRect, size, time, range);
        }
        const containerPromise = this.containerPreviewItemPromise(containerRect, time, range, icon);
        return containerPromise.then((containerItem) => {
          const defs = [];
          const luminance = true;
          defs.push(containerItem);
          let containerId2 = idGenerateString();
          if (updatableContainer && !icon) {
            const polygonElement = svgPolygonElement(containerRect, "", "transparent", containerId2);
            polygonElement.setAttribute("vector-effect", "non-scaling-stroke;");
            defs.push(polygonElement);
            containerId2 = idGenerateString();
          }
          containerItem.setAttribute("id", containerId2);
          const group = svgGroupElement();
          svgAppend(group, [svgPolygonElement(containerRect, "", "transparent"), contentItem]);
          const items = [group];
          svgAddClass(group, "contained");
          const maskElement = svgMaskElement(void 0, group, luminance);
          defs.push(maskElement);
          const useContainerInMask = svgUseElement(containerId2);
          maskElement.appendChild(svgPolygonElement(size, "", "black"));
          maskElement.appendChild(useContainerInMask);
          if (!updatableContainer) {
            containerItem.setAttribute("vector-effect", "non-scaling-stroke;");
            useContainerInMask.setAttribute("fill", colorWhite);
          }
          const containerSvgFilter = this.containerSvgFilter(containerItem, size, containerRect, time, range);
          if (containerSvgFilter)
            defs.push(containerSvgFilter);
          else
            containerItem.removeAttribute("filter");
          const contentSvgFilter = content.contentSvgFilter(contentItem, size, containerRect, time, range);
          if (contentSvgFilter)
            defs.push(contentSvgFilter);
          else
            contentItem.removeAttribute("filter");
          const useSvg = (updatableContent || updatableContainer) && !icon;
          const svg = useSvg ? this.svgElement : svgElement();
          svgSetChildren(svg, [svgDefsElement(defs), ...items]);
          svgSetDimensions(svg, size);
          return [svg];
        });
      });
      return containedPromise;
    }
    containerColorCommandFilters(args) {
      const commandFilters = [];
      const { contentColors, containerRects, track } = args;
      const { colorMaximize } = this;
      if (!colorMaximize)
        return super.containerColorCommandFilters(args);
      assertPopulatedArray(contentColors);
      const tweeningSize = !rectsEqual(...containerRects);
      const maxSize = tweeningSize ? tweenMaxSize(...containerRects) : containerRects[0];
      const colorArgs = {
        ...args,
        outputSize: maxSize
      };
      commandFilters.push(...this.colorBackCommandFilters(colorArgs, `content-${track}`));
      return commandFilters;
    }
    containerCommandFilters(args, tweening) {
      const commandFilters = [];
      const { contentColors, filterInput: input } = args;
      let filterInput = input;
      assertPopulatedString(filterInput, "filterInput");
      if (!(contentColors == null ? void 0 : contentColors.length)) {
        commandFilters.push(...this.alphamergeCommandFilters({ ...args, filterInput }));
        filterInput = arrayLast(arrayLast(commandFilters).outputs);
      }
      commandFilters.push(...this.containerFinalCommandFilters({ ...args, filterInput }));
      return commandFilters;
    }
    containerFinalCommandFilters(args) {
      const commandFilters = [];
      const { filterInput: input } = args;
      let filterInput = input;
      assertPopulatedString(filterInput, "filterInput");
      const opacityFilters = this.opacityCommandFilters(args);
      if (opacityFilters.length) {
        commandFilters.push(...opacityFilters);
        filterInput = arrayLast(arrayLast(opacityFilters).outputs);
      }
      commandFilters.push(...this.translateCommandFilters({ ...args, filterInput }));
      return commandFilters;
    }
    containerRects(args, inRect) {
      const { size, time, timeRange } = args;
      const { lock } = this;
      const tweenRects2 = this.tweenRects(time, timeRange);
      const locked = tweenRectsLock(tweenRects2, lock);
      const { width: inWidth, height: inHeight } = inRect;
      const ratio = (inWidth || size.width) / (inHeight || size.height);
      const [scale, scaleEnd] = locked;
      const forcedScale = tweenScaleSizeRatioLock(scale, size, ratio, lock);
      const { directionObject } = this;
      const transformedRect = tweenScaleSizeToRect(size, forcedScale, directionObject);
      const tweening = !rectsEqual(scale, scaleEnd);
      if (!tweening) {
        return [transformedRect, transformedRect];
      }
      const forcedScaleEnd = tweenScaleSizeRatioLock(scaleEnd, size, ratio, lock);
      const tweenRect = tweenOverRect(forcedScale, forcedScaleEnd);
      const tweened = tweenScaleSizeToRect(size, tweenRect, directionObject);
      const tuple = [transformedRect, tweened];
      return tuple;
    }
    containerPreviewItemPromise(containerRect, time, range, icon) {
      return Promise.resolve(this.pathElement(containerRect));
    }
    containerSvgFilter(svgItem, outputSize, containerRect, time, clipTime) {
      const [opacity] = this.tweenValues("opacity", time, clipTime);
      if (!isBelowOne(opacity))
        return;
      const { opacityFilter } = this;
      opacityFilter.setValue(opacity, "opacity");
      return svgFilterElement(opacityFilter.filterSvgFilter(), svgItem);
    }
    get directions() {
      return Anchors;
    }
    get directionObject() {
      return Object.fromEntries(Directions.map((direction) => [direction, !!this.value(`off${direction}`)]));
    }
    get div() {
      return this._div || (this._div = globalThis.document.createElement("div"));
    }
    get isDefault() {
      return this.definitionId === DefaultContainerId;
    }
    opacityCommandFilters(args) {
      const { outputSize, filterInput, clipTime, time, videoRate: videoRate2 } = args;
      assertTimeRange(clipTime);
      const duration = isTimeRange(time) ? time.lengthSeconds : 0;
      const commandFilters = [];
      const filterCommandFilterArgs = {
        dimensions: outputSize,
        filterInput,
        videoRate: videoRate2,
        duration
      };
      const [opacity, opacityEnd] = this.tweenValues("opacity", time, clipTime);
      if (isBelowOne(opacity) || isDefined(opacityEnd) && isBelowOne(opacityEnd)) {
        const { opacityFilter } = this;
        opacityFilter.setValues({ opacity, opacityEnd });
        commandFilters.push(...opacityFilter.commandFilters(filterCommandFilterArgs));
      }
      return commandFilters;
    }
    get opacityFilter() {
      return this._opacityFilter || (this._opacityFilter = filterFromId("opacity"));
    }
    pathElement(rect, forecolor2 = "none") {
      return svgPolygonElement(rect, "", forecolor2);
    }
    get svgElement() {
      return this._svgElement || (this._svgElement = svgElement());
    }
    translateCommandFilters(args) {
      const commandFilters = [];
      const { outputSize, time, containerRects, chainInput, filterInput, videoRate: videoRate2 } = args;
      if (!chainInput)
        return commandFilters;
      assertPopulatedArray(containerRects);
      const [rect, rectEnd] = containerRects;
      const duration = isTimeRange(time) ? time.lengthSeconds : 0;
      const { overlayFilter } = this;
      overlayFilter.setValue(rect.x, "x");
      overlayFilter.setValue(rect.y, "y");
      if (duration) {
        overlayFilter.setValue(rectEnd.x, `x${PropertyTweenSuffix}`);
        overlayFilter.setValue(rectEnd.y, `y${PropertyTweenSuffix}`);
      }
      const filterArgs = {
        dimensions: outputSize,
        filterInput,
        videoRate: videoRate2,
        duration,
        chainInput
      };
      commandFilters.push(...overlayFilter.commandFilters(filterArgs));
      return commandFilters;
    }
  };
}
function ContainerDefinitionMixin(Base) {
  return class extends Base {
    constructor(...args) {
      super(...args);
      __publicField(this, "type", DefinitionType.Container);
      this.properties.push(propertyInstance({
        name: "lock",
        type: DataType.String,
        defaultValue: Orientation.H,
        group: DataGroup.Size
      }));
    }
  };
}
var isShapeContainer = (value) => {
  return isContainer(value) && "path" in value;
};
var timeGreatestCommonDenominator = (fps1, fps2) => {
  let a = fps1;
  let b = fps2;
  let t = 0;
  while (b !== 0) {
    t = b;
    b = a % b;
    a = t;
  }
  return a;
};
var timeLowestCommonMultiplier = (a, b) => a * b / timeGreatestCommonDenominator(a, b);
var timeEqualizeRates = (time1, time2, rounding = "") => {
  if (time1.fps === time2.fps)
    return [time1, time2];
  const gcf = timeLowestCommonMultiplier(time1.fps, time2.fps);
  return [
    time1.scale(gcf, rounding),
    time2.scale(gcf, rounding)
  ];
};
var TimeClass = class _TimeClass {
  constructor(frame = 0, fps = 1) {
    __publicField(this, "fps");
    __publicField(this, "frame");
    __publicField(this, "isRange", false);
    if (!isInteger(frame) || frame < 0) {
      throw Errors.frame + frame;
    }
    if (!isInteger(fps) || fps < 1)
      throw Errors.fps;
    this.frame = frame;
    this.fps = fps;
  }
  add(time) {
    const [time1, time2] = timeEqualizeRates(this, time);
    return new _TimeClass(time1.frame + time2.frame, time1.fps);
  }
  addFrame(frames) {
    const time = this.copy;
    time.frame += frames;
    return time;
  }
  closest(timeRange) {
    const frame = timeRange.frame + Math.round(timeRange.frames / 2);
    const halfTime = new _TimeClass(frame, timeRange.fps);
    const [midTime, editorTime] = timeEqualizeRates(halfTime, this);
    const shouldBeOnLast = midTime.frame < editorTime.frame;
    return shouldBeOnLast ? timeRange.lastTime : timeRange.startTime;
  }
  get copy() {
    return new _TimeClass(this.frame, this.fps);
  }
  get description() {
    return `${this.frame}@${this.fps}`;
  }
  divide(number, rounding = "") {
    assertAboveZero(number);
    if (number === 1)
      return this;
    return this.withFrame(roundWithMethod(this.frame / number, rounding));
  }
  equalsTime(time) {
    const [time1, time2] = timeEqualizeRates(this, time);
    return time1.frame === time2.frame;
  }
  durationFrames(duration, fps = 0) {
    const rate = fps || this.fps;
    const frames = [];
    const framesMax = Math.floor(rate * duration) - 2;
    const startFrame = Math.min(framesMax, this.scale(rate, "floor").frame);
    if (this.isRange) {
      const scaledFrame = this.timeRange.endTime.scale(rate, "ceil").frame;
      const endFrame = Math.min(framesMax + 1, scaledFrame);
      for (let frame = startFrame; frame < endFrame; frame += 1) {
        frames.push(frame);
      }
    } else
      frames.push(startFrame);
    return frames;
  }
  get lengthSeconds() {
    return 0;
  }
  min(time) {
    const [time1, time2] = timeEqualizeRates(this, time);
    return new _TimeClass(Math.min(time1.frame, time2.frame), time1.fps);
  }
  scale(fps, rounding = "") {
    if (this.fps === fps)
      return this;
    const frame = Number(this.frame) / Number(this.fps) * Number(fps);
    return new _TimeClass(roundWithMethod(frame, rounding), fps);
  }
  scaleToFps(fps) {
    return this.scaleToTime(new _TimeClass(0, fps));
  }
  scaleToTime(time) {
    return timeEqualizeRates(this, time)[0];
  }
  get seconds() {
    return Number(this.frame) / Number(this.fps);
  }
  get startTime() {
    return this;
  }
  subtract(time) {
    const [time1, time2] = timeEqualizeRates(this, time);
    let subtracted = time2.frame;
    if (subtracted > time1.frame) {
      subtracted -= subtracted - time1.frame;
    }
    return new _TimeClass(time1.frame - subtracted, time1.fps);
  }
  subtractFrames(frames) {
    const time = this.copy;
    time.frame -= frames;
    return time;
  }
  get timeRange() {
    throw Errors.timeRange;
  }
  toString() {
    return `[${this.description}]`;
  }
  withFrame(frame) {
    const time = this.copy;
    time.frame = frame;
    return time;
  }
};
var TimeRangeClass = class _TimeRangeClass extends TimeClass {
  constructor(frame = 0, fps = 1, frames = 1) {
    super(frame, fps);
    __publicField(this, "frames");
    __publicField(this, "isRange", true);
    if (!(isInteger(frames) && frames >= 0)) {
      console.trace(this.constructor.name);
      throw Errors.timeRange + " frames";
    }
    this.frames = frames;
  }
  addFrames(frames) {
    const time = this.copy;
    time.frames += frames;
    return time;
  }
  get copy() {
    return new _TimeRangeClass(this.frame, this.fps, this.frames);
  }
  get description() {
    return `${this.frame}-${this.frames}@${this.fps}`;
  }
  get end() {
    return this.frame + this.frames;
  }
  get endTime() {
    return new TimeClass(this.end, this.fps);
  }
  equalsTimeRange(timeRange) {
    const [range1, range2] = timeEqualizeRates(this, timeRange);
    return range1.frame === range2.frame && range1.frames === range2.frames;
  }
  get frameTimes() {
    const { frames, frame, fps } = this;
    return Array.from({ length: frames }, (_, i) => new TimeClass(frame, fps));
  }
  includes(frame) {
    return frame >= this.frame && frame <= this.end;
  }
  includesTime(time) {
    const [thisTime, scaledTime] = timeEqualizeRates(this, time);
    const thisRange = thisTime;
    const { frame, end } = thisRange;
    const other = scaledTime.frame;
    return other >= frame && other < end;
  }
  intersects(time) {
    if (!time.isRange)
      return this.includesTime(time);
    const [range1, range2] = timeEqualizeRates(time, this);
    if (range1.frame >= range2.end)
      return false;
    return range1.end > range2.frame;
  }
  get last() {
    return this.frame + this.frames - 1;
  }
  get lastTime() {
    return new TimeClass(this.last, this.fps);
  }
  get lengthSeconds() {
    return Number(this.frames) / Number(this.fps);
  }
  get position() {
    return Number(this.frame) / Number(this.frames);
  }
  positionTime(position, rounding = "") {
    const frame = roundWithMethod((this.frames - this.frame) * position, rounding);
    return new TimeClass(this.frame + frame, this.fps);
  }
  get startTime() {
    return new TimeClass(this.frame, this.fps);
  }
  scale(fps = 1, rounding = "") {
    if (this.fps === fps)
      return this.copy;
    const value = Number(this.frames) / (Number(this.fps) / Number(fps));
    const time = super.scale(fps, rounding);
    const frames = Math.max(1, roundWithMethod(value, rounding));
    return new _TimeRangeClass(time.frame, time.fps, frames);
  }
  get timeRange() {
    return this;
  }
  get times() {
    const array = [this.startTime];
    if (this.frames > 1)
      array.push(this.endTime);
    return array;
  }
  minEndTime(endTime) {
    const [range, time] = timeEqualizeRates(this, endTime);
    range.frames = Math.min(range.frames, time.frame);
    return range;
  }
  withFrame(frame) {
    const range = this.copy;
    range.frame = frame;
    return range;
  }
  withFrames(frames) {
    const range = this.copy;
    range.frames = frames;
    return range;
  }
};
var timeRangeFromArgs = (frame = 0, fps = 1, frames = 1) => {
  return new TimeRangeClass(frame, fps, frames);
};
var timeRangeFromSeconds = (start = 0, duration = 1) => {
  return timeRangeFromArgs(start, 1, duration);
};
var timeRangeFromTime = (time, frames = 1) => {
  return timeRangeFromArgs(time.frame, time.fps, frames);
};
var timeRangeFromTimes = (startTime, endTime) => {
  if (!endTime)
    return timeRangeFromTime(startTime);
  const [time1, time2] = timeEqualizeRates(startTime, endTime);
  if (time2.frame <= time1.frame) {
    console.trace("fromTimes");
    throw Errors.argument + "fromTimes " + time1 + " " + time2;
  }
  const frames = time2.frame - time1.frame;
  return timeRangeFromArgs(time1.frame, time1.fps, frames);
};
var timeFromArgs = (frame = 0, fps = 1) => {
  return new TimeClass(frame, fps);
};
var timeFromSeconds = (seconds = 0, fps = 1, rounding = "") => {
  if (!isNumber(seconds) || seconds < 0)
    throw Errors.seconds;
  if (!isInteger(fps) || fps < 1)
    throw Errors.fps;
  const rounded = roundWithMethod(seconds * fps, rounding);
  return timeFromArgs(rounded, fps);
};
var DefaultEditorArgs = {
  buffer: 10,
  fps: 30,
  loop: true,
  volume: 0.75,
  precision: 3,
  autoplay: false
};
var DefaultMash = {
  label: "Mash",
  quantize: 10,
  color: colorBlack,
  gain: 0.75,
  buffer: 10
};
var DefaultCast = {
  label: "Cast",
  quantize: 10,
  color: colorBlack,
  gain: 0.75,
  buffer: 10
};
var Default = {
  duration: 3,
  label: "Unlabeled",
  editor: DefaultEditorArgs,
  cast: DefaultCast,
  mash: DefaultMash,
  definition: {
    image: { duration: 2 },
    textcontainer: { duration: 3 },
    shape: { duration: 3 },
    visible: { duration: 3 },
    video: { fps: 0 },
    videosequence: { pattern: "%.jpg", fps: 10, increment: 1, begin: 1, padding: 0 },
    videostream: { duration: 10 }
  }
};
function TweenableMixin(Base) {
  return class extends Base {
    constructor(...args) {
      super(...args);
      __publicField(this, "_alphamergeFilter");
      __publicField(this, "_clip");
      __publicField(this, "_colorFilter");
      __publicField(this, "container", false);
      __publicField(this, "_cropFilter");
      __publicField(this, "hasIntrinsicSizing", false);
      __publicField(this, "hasIntrinsicTiming", false);
      __publicField(this, "_overlayFilter");
      __publicField(this, "_scaleFilter");
      __publicField(this, "selectType", SelectType.None);
      const [object] = args;
      const { container } = object;
      if (container)
        this.container = true;
    }
    alphamergeCommandFilters(args) {
      const commandFilters = [];
      const { videoRate: videoRate2, outputSize: rect, track, filterInput } = args;
      assertPopulatedString(filterInput);
      assertAboveZero(videoRate2);
      assertSize(rect);
      const chainInput = `content-${track}`;
      const filterArgs = {
        videoRate: 0,
        duration: 0,
        filterInput,
        chainInput
      };
      const { alphamergeFilter } = this;
      commandFilters.push(...alphamergeFilter.commandFilters(filterArgs));
      return commandFilters;
    }
    get alphamergeFilter() {
      return this._alphamergeFilter || (this._alphamergeFilter = filterFromId("alphamerge"));
    }
    amixCommandFilters(args) {
      const { chainInput, filterInput } = args;
      assertPopulatedString(chainInput);
      assertPopulatedString(filterInput);
      const amixFilter = "amix";
      const commandFilters = [];
      const commandFilter = {
        inputs: [chainInput, filterInput],
        ffmpegFilter: amixFilter,
        options: { normalize: 0 },
        outputs: []
      };
      commandFilters.push(commandFilter);
      return commandFilters;
    }
    canColor(args) {
      return false;
    }
    canColorTween(args) {
      return false;
    }
    get clip() {
      return this._clip;
    }
    set clip(value) {
      this._clip = value;
    }
    get clipped() {
      return !!this._clip;
    }
    colorBackCommandFilters(args, output) {
      const { contentColors = [], videoRate: videoRate2, outputSize, duration } = args;
      assertSize(outputSize);
      const evenSize = sizeEven(outputSize);
      const [color2 = colorBlackOpaque, colorEnd = colorBlackOpaque] = contentColors;
      const outputString = output || idGenerate(colorName(color2) || "back");
      const { colorFilter } = this;
      const colorArgs = { videoRate: videoRate2, duration };
      colorFilter.setValue(color2, "color");
      colorFilter.setValue(colorEnd, `color${PropertyTweenSuffix}`);
      colorFilter.setValue(evenSize.width, "width");
      colorFilter.setValue(evenSize.height, "height");
      colorFilter.setValue(evenSize.width, `width${PropertyTweenSuffix}`);
      colorFilter.setValue(evenSize.height, `height${PropertyTweenSuffix}`);
      const commandFilters = colorFilter.commandFilters(colorArgs);
      if (sizesEqual(evenSize, outputSize)) {
        arrayLast(commandFilters).outputs = [outputString];
      } else {
        const filterInput = arrayLast(arrayLast(commandFilters).outputs);
        assertPopulatedString(filterInput, "crop input");
        const cropFilter = "crop";
        const cropCommandFilter = {
          inputs: [filterInput],
          ffmpegFilter: cropFilter,
          options: { w: outputSize.width, h: outputSize.height, exact: 1 },
          outputs: [outputString]
        };
        commandFilters.push(cropCommandFilter);
      }
      return commandFilters;
    }
    get colorFilter() {
      return this._colorFilter || (this._colorFilter = filterFromId("color"));
    }
    commandFilters(args, tweening, container = false) {
      const commandFilters = [];
      const { filterInput: input = "" } = args;
      let filterInput = input;
      const initialFilters = this.initialCommandFilters(args, tweening, container);
      if (initialFilters.length) {
        commandFilters.push(...initialFilters);
        filterInput = arrayLast(arrayLast(initialFilters).outputs);
      }
      if (container)
        commandFilters.push(...this.containerCommandFilters({ ...args, filterInput }, tweening));
      else
        commandFilters.push(...this.contentCommandFilters({ ...args, filterInput }, tweening));
      return commandFilters;
    }
    containerColorCommandFilters(args) {
      const commandFilters = [];
      const { contentColors: colors = [], containerRects, videoRate: videoRate2, duration } = args;
      assertArray(containerRects, "containerRects");
      const [rect, rectEnd] = containerRects;
      const colorArgs = { videoRate: videoRate2, duration };
      const { colorFilter } = this;
      const [color2, colorEnd] = colors;
      colorFilter.setValue(color2 || colorWhite, "color");
      colorFilter.setValue(colorEnd, `color${PropertyTweenSuffix}`);
      colorFilter.setValue(rect.width, "width");
      colorFilter.setValue(rect.height, "height");
      colorFilter.setValue(rectEnd.width, `width${PropertyTweenSuffix}`);
      colorFilter.setValue(rectEnd.height, `height${PropertyTweenSuffix}`);
      commandFilters.push(...colorFilter.commandFilters(colorArgs));
      return commandFilters;
    }
    containerCommandFilters(args, tweening) {
      return [];
    }
    containerFinalCommandFilters(args) {
      return [];
    }
    contentCommandFilters(args, tweening) {
      return [];
    }
    copyCommandFilter(input, track, prefix = "content") {
      const contentOutput = `${prefix}-${track}`;
      const commandFilter = {
        inputs: [input],
        ffmpegFilter: "copy",
        options: {},
        outputs: [contentOutput]
      };
      return commandFilter;
    }
    get cropFilter() {
      return this._cropFilter || (this._cropFilter = filterFromId("crop"));
    }
    definitionTime(time, clipTime) {
      const { fps: quantize } = clipTime;
      const scaledTime = time.scaleToFps(quantize);
      const { startTime, endTime } = clipTime;
      const frame = Math.max(Math.min(scaledTime.frame, endTime.frame), startTime.frame);
      return scaledTime.withFrame(frame - startTime.frame);
    }
    frames(quantize) {
      return timeFromArgs(Default.duration, quantize).frame;
    }
    fileCommandFiles(graphFileArgs) {
      const commandFiles = [];
      const files = this.fileUrls(graphFileArgs);
      let inputCount = 0;
      commandFiles.push(...files.map((graphFile, index) => {
        const { input } = graphFile;
        const inputId = index && input ? `${this.id}-${inputCount}` : this.id;
        const commandFile = { ...graphFile, inputId };
        if (input)
          inputCount++;
        return commandFile;
      }));
      return commandFiles;
    }
    fileUrls(args) {
      return [];
    }
    initialCommandFilters(args, tweening, container = false) {
      throw new Error(Errors.unimplemented);
    }
    intrinsicRect(editing = false) {
      throw new Error(Errors.unimplemented);
    }
    intrinsicsKnown(options2) {
      return true;
    }
    intrinsicGraphFile(options2) {
      const { editing, size, duration } = options2;
      const clipTime = timeRangeFromArgs();
      const graphFileArgs = {
        editing,
        time: clipTime.startTime,
        clipTime,
        quantize: clipTime.fps,
        visible: size,
        audible: duration
      };
      const [graphFile] = this.fileUrls(graphFileArgs);
      assertObject(graphFile);
      return graphFile;
    }
    get isDefault() {
      return false;
    }
    mutable() {
      return false;
    }
    overlayCommandFilters(bottomInput, topInput, alpha) {
      assertPopulatedString(bottomInput, "bottomInput");
      assertPopulatedString(topInput, "topInput");
      const commandFilters = [];
      const overlayArgs = {
        filterInput: topInput,
        chainInput: bottomInput,
        videoRate: 0,
        duration: 0
      };
      const { overlayFilter } = this;
      if (alpha)
        overlayFilter.setValue("yuv420p10", "format");
      overlayFilter.setValue(0, "x");
      overlayFilter.setValue(0, "y");
      commandFilters.push(...overlayFilter.commandFilters(overlayArgs));
      const commandFilter = arrayLast(commandFilters);
      commandFilter.outputs = [idGenerate(topInput)];
      return commandFilters;
    }
    get overlayFilter() {
      return this._overlayFilter || (this._overlayFilter = filterFromId("overlay"));
    }
    scaleCommandFilters(args) {
      const { time, containerRects, filterInput: input, videoRate: videoRate2 } = args;
      let filterInput = input;
      assertPopulatedString(filterInput, "filterInput");
      assertArray(containerRects, "containerRects");
      const [rect, rectEnd] = containerRects;
      assertRect(rect);
      assertRect(rectEnd);
      const duration = isTimeRange(time) ? time.lengthSeconds : 0;
      const commandFilters = [];
      const { scaleFilter } = this;
      const filterCommandFilterArgs = {
        duration,
        videoRate: videoRate2,
        filterInput
      };
      scaleFilter.setValue(rect.width, "width");
      scaleFilter.setValue(rect.height, "height");
      scaleFilter.setValue(rectEnd.width, `width${PropertyTweenSuffix}`);
      scaleFilter.setValue(rectEnd.height, `height${PropertyTweenSuffix}`);
      commandFilters.push(...scaleFilter.commandFilters(filterCommandFilterArgs));
      return commandFilters;
    }
    get scaleFilter() {
      return this._scaleFilter || (this._scaleFilter = filterFromId("scale"));
    }
    selectables() {
      return [this, ...this.clip.selectables()];
    }
    selectedItems(actions) {
      const selectedItems = [];
      const { container, clip, selectType, definition } = this;
      const { id: undoValue } = definition;
      const { timing, sizing } = clip;
      const dataType = container ? DataType.ContainerId : DataType.ContentId;
      const property = clip.properties.find((property2) => property2.type === dataType);
      assertProperty(property);
      const { name } = property;
      const undoValues = { timing, sizing, [name]: undoValue };
      const values = { ...undoValues };
      const relevantTiming = container ? Timing.Container : Timing.Content;
      const relevantSizing = container ? Sizing.Container : Sizing.Content;
      const timingBound = timing === relevantTiming;
      const sizingBound = sizing === relevantSizing;
      selectedItems.push({
        selectType,
        property,
        value: undoValue,
        changeHandler: (property2, redoValue) => {
          assertPopulatedString(redoValue);
          const redoValues = { ...values, [name]: redoValue };
          if (timingBound || sizingBound) {
            const newDefinition = Defined.fromId(redoValue);
            const { type: type2 } = newDefinition;
            if (timingBound && !isTimingDefinitionType(type2)) {
              redoValues.timing = Timing.Custom;
            }
            if (sizingBound && !isSizingDefinitionType(type2)) {
              redoValues.sizing = container ? Sizing.Content : Sizing.Container;
            }
          }
          const actionObject = {
            type: ActionType.ChangeMultiple,
            property: property2,
            target: clip,
            redoValues,
            undoValues
          };
          actions.create(actionObject);
        }
      });
      const { properties: properties2 } = this;
      const props = properties2.filter((property2) => this.selectedProperty(property2));
      props.forEach((property2) => {
        selectedItems.push(...this.selectedProperties(actions, property2));
      });
      return selectedItems;
    }
    selectedProperties(actions, property) {
      const properties2 = [];
      const { name, tweenable, type: dataType } = property;
      const { selectType } = this;
      const undoValue = this.value(name);
      const target = this;
      const type2 = dataType === DataType.Frame ? ActionType.ChangeFrame : ActionType.Change;
      const selectedProperty = {
        selectType,
        property,
        value: undoValue,
        changeHandler: (property2, redoValue) => {
          assertPopulatedString(property2);
          actions.create({ type: type2, property: property2, target, redoValue, undoValue });
        }
      };
      properties2.push(selectedProperty);
      if (tweenable) {
        const tweenName = [name, PropertyTweenSuffix].join("");
        const target2 = this;
        const undoValue2 = this.value(tweenName);
        const selectedPropertEnd = {
          selectType,
          property,
          value: undoValue2,
          name: tweenName,
          changeHandler: (property2, redoValue) => {
            actions.create({ property: property2, target: target2, redoValue, undoValue: undoValue2 });
          }
        };
        properties2.push(selectedPropertEnd);
      }
      return properties2;
    }
    selectedProperty(property) {
      const { name } = property;
      switch (name) {
        case "muted":
          return this.mutable();
        case "opacity":
          return this.container;
      }
      return true;
    }
    tween(keyPrefix, time, range) {
      const value = this.value(keyPrefix);
      const valueEnd = this.value(`${keyPrefix}${PropertyTweenSuffix}`);
      if (isUndefined(valueEnd))
        return value;
      const { frame: rangeFrame, frames } = range;
      const { frame: timeFrame } = time;
      const frame = timeFrame - rangeFrame;
      if (isNumber(value)) {
        assertNumber(valueEnd);
        return tweenNumberStep(value, valueEnd, frame, frames);
      }
      assertPopulatedString(value);
      assertPopulatedString(valueEnd);
      return tweenColorStep(value, valueEnd, frame, frames);
    }
    tweenPoints(time, range) {
      const [x, xEndOrNot] = this.tweenValues("x", time, range);
      const [y, yEndOrNot] = this.tweenValues("y", time, range);
      assertNumber(x);
      assertNumber(y);
      const point = { x, y };
      const tweenPoint = { x: xEndOrNot, y: yEndOrNot };
      return [point, tweenOverPoint(point, tweenPoint)];
    }
    tweenRects(time, range) {
      const [size, sizeEnd] = this.tweenSizes(time, range);
      const [point, pointEnd] = this.tweenPoints(time, range);
      return [{ ...point, ...size }, { ...pointEnd, ...sizeEnd }];
    }
    tweenSizes(time, range) {
      const [width2, widthEndOrNot] = this.tweenValues("width", time, range);
      const [height2, heightEndOrNot] = this.tweenValues("height", time, range);
      assertNumber(width2);
      assertNumber(height2);
      const size = { width: width2, height: height2 };
      const tweenSize = { width: widthEndOrNot, height: heightEndOrNot };
      return [size, tweenOverSize(size, tweenSize)];
    }
    tweenValues(key, time, range) {
      const values = [];
      const isRange = isTimeRange(time);
      values.push(this.tween(key, isRange ? time.startTime : time, range));
      if (isRange)
        values.push(this.tween(key, time.endTime, range));
      return values;
    }
    visibleCommandFiles(args) {
      const graphFileArgs = {
        ...args,
        audible: false,
        visible: true
      };
      const files = this.fileCommandFiles(graphFileArgs);
      return files;
    }
  };
}
var ShapeContainerWithTweenable = TweenableMixin(InstanceBase);
var ShapeContainerWithContainer = ContainerMixin(ShapeContainerWithTweenable);
var ShapeContainerClass = class extends ShapeContainerWithContainer {
  constructor(...args) {
    super(...args);
    __publicField(this, "hasIntrinsicSizing", true);
    const [object] = args;
    this.addProperties(object, propertyInstance({
      tweenable: true,
      name: "width",
      type: DataType.Percent,
      group: DataGroup.Size,
      defaultValue: 1,
      max: 2
    }));
    this.addProperties(object, propertyInstance({
      tweenable: true,
      name: "height",
      type: DataType.Percent,
      group: DataGroup.Size,
      defaultValue: 1,
      max: 2
    }));
  }
  canColor(args) {
    const { isDefault } = this;
    if (isDefault)
      return false;
    return !this.isTweeningColor(args);
  }
  containerColorCommandFilters(args) {
    const commandFilters = [];
    const { colorFilter, isDefault } = this;
    const { contentColors, containerRects, videoRate: videoRate2, duration } = args;
    assertPopulatedArray(contentColors, "contentColors");
    const [rect, rectEnd] = containerRects;
    const [color2, colorEnd] = contentColors;
    const maxSize = isDefault ? rect : tweenMaxSize(...containerRects);
    const colorArgs = { videoRate: videoRate2, duration };
    colorFilter.setValue(color2 || colorWhite, "color");
    colorFilter.setValue(colorEnd, `color${PropertyTweenSuffix}`);
    colorFilter.setValue(maxSize.width, "width");
    colorFilter.setValue(maxSize.height, "height");
    const tweenSize = isDefault;
    colorFilter.setValue(tweenSize ? rectEnd.width : void 0, `width${PropertyTweenSuffix}`);
    colorFilter.setValue(tweenSize ? rectEnd.height : void 0, `height${PropertyTweenSuffix}`);
    commandFilters.push(...colorFilter.commandFilters(colorArgs));
    return commandFilters;
  }
  containerCommandFilters(args, tweening) {
    const commandFilters = [];
    const { contentColors: colors, commandFiles, filterInput: input } = args;
    let filterInput = input;
    const noContentFilters = isPopulatedArray(colors);
    const alpha = this.requiresAlpha(args, !!tweening.size);
    if (alpha) {
      assertPopulatedString(filterInput, "container input");
      const { contentColors: _, ...argsWithoutColors } = args;
      const superArgs = {
        ...argsWithoutColors,
        filterInput
      };
      commandFilters.push(...super.containerCommandFilters(superArgs, tweening));
    } else if (this.isDefault || noContentFilters) {
      const { id: id2 } = this;
      filterInput || (filterInput = commandFilesInput(commandFiles, id2, true));
      assertPopulatedString(filterInput, "final input");
      commandFilters.push(...this.containerFinalCommandFilters({ ...args, filterInput }));
    }
    return commandFilters;
  }
  initialCommandFilters(args, tweening, container = false) {
    const commandFilters = [];
    const { contentColors, ...argsWithoutColors } = args;
    const { commandFiles, upload, track, filterInput: input, containerRects, videoRate: videoRate2 } = argsWithoutColors;
    if (upload)
      return commandFilters;
    let filterInput = input;
    const alpha = this.requiresAlpha(args, !!tweening.size);
    const { isDefault } = this;
    const tweeningSize = tweening.size;
    const maxSize = tweeningSize ? tweenMaxSize(...containerRects) : containerRects[0];
    const evenSize = sizeEven(maxSize);
    const contentInput = `content-${track}`;
    const containerInput = `container-${track}`;
    if (!tweening.canColor) {
      if (isPopulatedString(filterInput) && !isDefault) {
        if (alpha) {
          const formatFilter = "format";
          const formatFilterId = idGenerate(formatFilter);
          const formatCommandFilter = {
            inputs: [filterInput],
            ffmpegFilter: formatFilter,
            options: { pix_fmts: "yuv420p" },
            outputs: [formatFilterId]
          };
          commandFilters.push(formatCommandFilter);
          filterInput = formatFilterId;
        } else if (!sizesEqual(evenSize, maxSize)) {
          const colorArgs = {
            ...args,
            contentColors: [colorBlackOpaque, colorBlackOpaque],
            outputSize: evenSize
          };
          commandFilters.push(...this.colorBackCommandFilters(colorArgs, `${contentInput}-back`));
          const colorInput = arrayLast(arrayLast(commandFilters).outputs);
          assertPopulatedString(filterInput, "overlay input");
          commandFilters.push(...this.overlayCommandFilters(colorInput, filterInput));
          filterInput = arrayLast(arrayLast(commandFilters).outputs);
        }
      }
    }
    if (commandFilters.length)
      arrayLast(commandFilters).outputs = [contentInput];
    else if (isPopulatedString(filterInput) && contentInput !== filterInput) {
      commandFilters.push(this.copyCommandFilter(filterInput, track));
    }
    if (alpha) {
      const { id: id2 } = this;
      const fileInput = commandFilesInput(commandFiles, id2, true);
      assertPopulatedString(fileInput, "scale input");
      const colorArgs = {
        ...args,
        contentColors: [colorBlackOpaque, colorBlackOpaque],
        outputSize: maxSize
      };
      commandFilters.push(...this.colorBackCommandFilters(colorArgs, `${containerInput}-back`));
      const colorInput = arrayLast(arrayLast(commandFilters).outputs);
      commandFilters.push(...this.scaleCommandFilters({ ...args, filterInput: fileInput }));
      filterInput = arrayLast(arrayLast(commandFilters).outputs);
      assertPopulatedString(filterInput, "overlay input");
      commandFilters.push(...this.overlayCommandFilters(colorInput, filterInput));
      filterInput = arrayLast(arrayLast(commandFilters).outputs);
      const cropArgs = { duration: 0, videoRate: videoRate2 };
      assertPopulatedString(filterInput, "crop input");
      const { cropFilter } = this;
      cropFilter.setValue(maxSize.width, "width");
      cropFilter.setValue(maxSize.height, "height");
      cropFilter.setValue(0, "x");
      cropFilter.setValue(0, "y");
      commandFilters.push(...cropFilter.commandFilters({ ...cropArgs, filterInput }));
      filterInput = arrayLast(arrayLast(commandFilters).outputs);
      assertPopulatedString(filterInput, "format input");
      const formatFilter = "format";
      const formatCommandFilter = {
        inputs: [filterInput],
        ffmpegFilter: formatFilter,
        options: { pix_fmts: alpha ? "yuv420p" : "yuva420p" },
        outputs: [containerInput]
      };
      commandFilters.push(formatCommandFilter);
    }
    return commandFilters;
  }
  intrinsicRect(editing = false) {
    const { pathHeight: height2, pathWidth: width2 } = this.definition;
    return { width: width2, height: height2, ...PointZero };
  }
  isTweeningColor(args) {
    const { contentColors } = args;
    if (!isPopulatedArray(contentColors))
      return false;
    let [forecolor2, forecolorEnd] = contentColors;
    return forecolor2 !== forecolorEnd;
  }
  isTweeningSize(args) {
    const { containerRects } = args;
    if (!isPopulatedArray(containerRects)) {
      return false;
    }
    const equal = rectsEqual(...containerRects);
    return !equal;
  }
  pathElement(rect, forecolor2 = "") {
    const { definition } = this;
    const inRect = this.intrinsicRect(true);
    if (!sizeAboveZero(inRect)) {
      const polygonElement = svgPolygonElement(rect, "", forecolor2);
      return polygonElement;
    }
    const { path: path2 } = definition;
    const pathElement = svgPathElement(path2, "");
    svgSetTransformRects(pathElement, inRect, rect);
    return pathElement;
  }
  requiresAlpha(args, tweeningSize) {
    const { contentColors } = args;
    const colorContent = isPopulatedArray(contentColors);
    if (this.isDefault) {
      if (colorContent)
        return false;
      if (isBoolean(tweeningSize))
        return tweeningSize;
      return this.isTweeningSize(args);
    }
    if (!colorContent)
      return true;
    return this.isTweeningColor(args);
  }
  visibleCommandFiles(args) {
    const { isDefault, id: id2 } = this;
    const alpha = this.requiresAlpha(args);
    const tweeningColor = this.isTweeningColor(args);
    if (isDefault && !alpha) {
      return [];
    }
    const { definition } = this;
    const { path: path2 } = definition;
    const { contentColors: colors = [], containerRects, time, videoRate: videoRate2 } = args;
    assertPopulatedArray(containerRects, "containerRects");
    const duration = isTimeRange(time) ? time.lengthSeconds : 0;
    const [rect, rectEnd] = containerRects;
    const maxSize = { ...PointZero, ...tweenMaxSize(rect, rectEnd) };
    const { width: maxWidth, height: maxHeight } = maxSize;
    let [forecolor2] = colors;
    if (alpha)
      forecolor2 = colorWhite;
    else if (tweeningColor)
      forecolor2 = colorBlack;
    let fill = "none";
    if (isDefault)
      fill = colorWhite;
    else if (alpha)
      fill = colorBlack;
    const intrinsicRect = isDefault ? maxSize : this.intrinsicRect();
    const { width: inWidth, height: inHeight } = intrinsicRect;
    const dimensionsString = `width="${inWidth}" height="${inHeight}"`;
    const transformAttribute = svgTransform(intrinsicRect, maxSize);
    const tags = [];
    tags.push(`<svg viewBox="0 0 ${maxWidth} ${maxHeight}" xmlns="${NamespaceSvg}">`);
    tags.push(`<g ${dimensionsString} transform="${transformAttribute}" >`);
    tags.push(`<rect ${dimensionsString} fill="${fill}"/>`);
    if (!isDefault)
      tags.push(`<path d="${path2}" fill="${forecolor2}"/>`);
    tags.push("</g>");
    tags.push("</svg>");
    const svgTag = tags.join("");
    const options2 = {};
    if (duration) {
      options2.loop = 1;
      options2.framerate = videoRate2;
      options2.t = duration;
    }
    const commandFile = {
      type: GraphFileType.Svg,
      file: id2,
      content: svgTag,
      input: true,
      inputId: id2,
      definition,
      options: options2
    };
    return [commandFile];
  }
};
function TweenableDefinitionMixin(Base) {
  return class extends Base {
    constructor(...args) {
      super(...args);
      this.properties.push(propertyInstance({
        name: "muted",
        type: DataType.Boolean
      }));
    }
  };
}
var ShapeContainerDefinitionWithTweenable = TweenableDefinitionMixin(DefinitionBase);
var ShapeContainerDefinitionWithContainer = ContainerDefinitionMixin(ShapeContainerDefinitionWithTweenable);
var ShapeContainerDefinitionClass = class extends ShapeContainerDefinitionWithContainer {
  constructor(...args) {
    super(...args);
    __publicField(this, "path", "");
    __publicField(this, "pathHeight", 0);
    __publicField(this, "pathWidth", 0);
    const [object] = args;
    const { path: path2, pathHeight: pathHeight2, pathWidth: pathWidth2 } = object;
    if (path2)
      this.path = path2;
    if (isAboveZero(pathWidth2))
      this.pathWidth = pathWidth2;
    if (isAboveZero(pathHeight2))
      this.pathHeight = pathHeight2;
  }
  definitionIcon(loader, size) {
    const superElement = super.definitionIcon(loader, size);
    if (superElement)
      return superElement;
    const { id: id2, pathHeight: height2, pathWidth: width2, path: path2 } = this;
    if (id2 === DefaultContainerId) {
      return Promise.resolve(svgElement(size, svgPolygonElement(size, "", "currentColor")));
    }
    const inSize = { width: width2, height: height2 };
    if (!(sizeAboveZero(inSize) && isPopulatedString(path2)))
      return;
    const coverSize = sizeCover(inSize, size, true);
    const outRect = { ...coverSize, ...centerPoint(size, coverSize) };
    const pathElement = svgPathElement(path2);
    svgSetTransformRects(pathElement, inSize, outRect);
    return Promise.resolve(svgElement(size, pathElement));
  }
  instanceFromObject(object = {}) {
    return new ShapeContainerClass(this.instanceArgs(object));
  }
  toJSON() {
    const object = super.toJSON();
    if (this.path)
      object.path = this.path;
    if (isAboveZero(this.pathHeight))
      object.pathHeight = this.pathHeight;
    if (isAboveZero(this.pathWidth))
      object.pathWidth = this.pathWidth;
    return object;
  }
};
var isTextContainer = (value) => {
  return isContainer(value) && "fontId" in value;
};
function assertTextContainer(value) {
  if (!isTextContainer(value))
    throw new Error("expected TextContainer");
}
var TextContainerWithTweenable = TweenableMixin(InstanceBase);
var TextContainerWithContainer = ContainerMixin(TextContainerWithTweenable);
var TextContainerClass = class extends TextContainerWithContainer {
  constructor(...args) {
    const [object] = args;
    object.lock || (object.lock = "");
    super(...args);
    __publicField(this, "_colorFilter");
    __publicField(this, "_font");
    __publicField(this, "hasIntrinsicSizing", true);
    __publicField(this, "_intrinsicRect");
    __publicField(this, "_textFilter");
    const { intrinsic } = object;
    if (isRect(intrinsic))
      this._intrinsicRect = intrinsic;
  }
  canColor(args) {
    return true;
  }
  canColorTween(args) {
    return true;
  }
  get colorFilter() {
    return this._colorFilter || (this._colorFilter = filterFromId("color"));
  }
  definitionIds() {
    return [...super.definitionIds(), this.fontId];
  }
  get font() {
    return this._font || (this._font = Defined.fromId(this.fontId));
  }
  fileUrls(args) {
    return this.font.fileUrls(args);
  }
  initialCommandFilters(args, tweening) {
    const commandFilters = [];
    const { contentColors: colors = [], outputSize, track, filterInput: input, containerRects, videoRate: videoRate2, commandFiles, duration } = args;
    let filterInput = input;
    if (filterInput) {
      commandFilters.push(this.copyCommandFilter(filterInput, track));
    }
    const [rect, rectEnd] = containerRects;
    const { height: height2, width: width2 } = rect;
    const maxSize = tweenMaxSize(...containerRects);
    let colorInput = "";
    const merging = !!filterInput || tweening.size;
    if (merging) {
      const backColor = filterInput ? colorBlack : colorBlackTransparent;
      const colorArgs = {
        ...args,
        contentColors: [backColor, backColor],
        outputSize: maxSize
      };
      commandFilters.push(...this.colorBackCommandFilters(colorArgs));
      colorInput = arrayLast(arrayLast(commandFilters).outputs);
    }
    const textFile = commandFiles.find((commandFile) => commandFile.inputId === this.id && commandFile.type === GraphFileType.Txt);
    assertTrue(textFile, "text file");
    const { resolved: textfile } = textFile;
    assertPopulatedString(textfile, "textfile");
    const fontFile = commandFiles.find((commandFile) => commandFile.inputId === this.id && commandFile.type === LoadType.Font);
    assertTrue(fontFile, "font file");
    const { resolved: fontfile } = fontFile;
    assertPopulatedString(fontfile, "fontfile");
    const { textFilter, lock } = this;
    const intrinsicRect = this.intrinsicRect();
    const x = intrinsicRect.x * (rect.width / intrinsicRect.width);
    const y = 0;
    const [color2 = colorWhite, colorEnd] = colors;
    assertPopulatedString(color2);
    const xEnd = intrinsicRect.x * (rectEnd.width / intrinsicRect.width);
    const yEnd = 0;
    const intrinsicRatio = 1e3 / intrinsicRect.height;
    const textSize = Math.round(height2 * intrinsicRatio);
    const textSizeEnd = Math.round(rectEnd.height * intrinsicRatio);
    const options2 = {
      x,
      y,
      width: width2,
      height: textSize,
      color: color2,
      textfile,
      fontfile,
      stretch: !isOrientation(lock),
      intrinsicHeight: intrinsicRect.height,
      intrinsicWidth: intrinsicRect.width,
      [`x${PropertyTweenSuffix}`]: xEnd,
      [`y${PropertyTweenSuffix}`]: yEnd,
      [`color${PropertyTweenSuffix}`]: colorEnd,
      [`height${PropertyTweenSuffix}`]: textSizeEnd,
      [`width${PropertyTweenSuffix}`]: rectEnd.width
    };
    textFilter.setValues(options2);
    const textArgs = {
      dimensions: outputSize,
      videoRate: videoRate2,
      duration,
      filterInput
    };
    commandFilters.push(...textFilter.commandFilters(textArgs));
    if (merging) {
      filterInput = arrayLast(arrayLast(commandFilters).outputs);
      assertPopulatedString(filterInput, "overlay filterInput");
      commandFilters.push(...this.overlayCommandFilters(colorInput, filterInput));
      filterInput = arrayLast(arrayLast(commandFilters).outputs);
      assertPopulatedString(filterInput, "crop filterInput");
      const cropArgs = {
        duration: 0,
        videoRate: videoRate2,
        filterInput
      };
      const { cropFilter } = this;
      cropFilter.setValue(maxSize.width, "width");
      cropFilter.setValue(maxSize.height, "height");
      cropFilter.setValue(0, "x");
      cropFilter.setValue(0, "y");
      commandFilters.push(...cropFilter.commandFilters(cropArgs));
    }
    return commandFilters;
  }
  intrinsicRect(_ = false) {
    return this._intrinsicRect || (this._intrinsicRect = this.intrinsicRectInitialize());
  }
  intrinsicRectInitialize() {
    const { family } = this.font;
    assertPopulatedString(family);
    const clipString = this.string;
    const height2 = 1e3;
    const dimensions = { width: 0, height: height2, ...PointZero };
    if (!clipString)
      return dimensions;
    const rect = stringFamilySizeRect(clipString, family, height2);
    return rect;
  }
  intrinsicsKnown(options2) {
    var _a;
    const { size } = options2;
    if (!size)
      return true;
    return isRect(this._intrinsicRect) || !!((_a = this.font) == null ? void 0 : _a.family);
  }
  pathElement(rect) {
    const { string, font } = this;
    const { family } = font;
    const svgItem = globalThis.document.createElementNS(NamespaceSvg, "text");
    svgItem.setAttribute("font-family", family);
    svgItem.setAttribute("font-size", String(1e3));
    svgItem.append(string);
    svgSetTransformRects(svgItem, this.intrinsicRect(true), rect);
    return svgItem;
  }
  setValue(value, name, property) {
    super.setValue(value, name, property);
    if (property)
      return;
    switch (name) {
      case "fontId":
        delete this._font;
        delete this._intrinsicRect;
        break;
      case "string":
        delete this._intrinsicRect;
        break;
    }
  }
  get textFilter() {
    return this._textFilter || (this._textFilter = filterFromId("text"));
  }
  toJSON() {
    const json = super.toJSON();
    json.intrinsic = this.intrinsicRect(true);
    return json;
  }
  visibleCommandFiles(args) {
    const files = super.visibleCommandFiles(args);
    const { string } = this;
    const textGraphFile = {
      definition: this.font,
      type: GraphFileType.Txt,
      file: this.id,
      content: string,
      inputId: this.id
    };
    files.push(textGraphFile);
    return files;
  }
};
var FontClass = class extends InstanceBase {
  fileUrls(args) {
    return this.definition.fileUrls(args);
  }
};
var FontDefinitionClass = class extends DefinitionBase {
  constructor(...args) {
    super(...args);
    __publicField(this, "family", "");
    __publicField(this, "loadType", LoadType.Font);
    __publicField(this, "source", "");
    __publicField(this, "type", DefinitionType.Font);
    __publicField(this, "url", "");
    const [object] = args;
    const { source: source2, url } = object;
    const sourceOrUrl = source2 || url || "";
    this.source = source2 || sourceOrUrl;
    this.url = url || sourceOrUrl;
  }
  fileUrls(args) {
    const { visible, editing } = args;
    if (!visible)
      return [];
    const { url, source: source2 } = this;
    const file = editing ? url : source2;
    const graphFile = {
      type: LoadType.Font,
      file,
      definition: this
    };
    return [graphFile];
  }
  instanceFromObject(object = {}) {
    return new FontClass(this.instanceArgs(object));
  }
  toJSON() {
    const json = super.toJSON();
    const { url, source: source2 } = this;
    json.url = url;
    json.source = source2;
    return json;
  }
};
var label$r = "Butcherman";
var id$q = "com.moviemasher.font.butcherman";
var type$q = "font";
var source$9 = "https://fonts.googleapis.com/css2?family=Butcherman";
var fontButchermanJson = {
  label: label$r,
  id: id$q,
  type: type$q,
  source: source$9
};
var label$q = "Croissant One";
var id$p = "com.moviemasher.font.croissant-one";
var type$p = "font";
var source$8 = "https://fonts.googleapis.com/css2?family=Croissant+One";
var fontCroissantOneJson = {
  label: label$q,
  id: id$p,
  type: type$p,
  source: source$8
};
var label$p = "League Spartan";
var id$o = "com.moviemasher.font.default";
var type$o = "font";
var source$7 = "https://fonts.googleapis.com/css2?family=League+Spartan";
var fontDefaultJson = {
  label: label$p,
  id: id$o,
  type: type$o,
  source: source$7
};
var label$o = "Germania One";
var id$n = "com.moviemasher.font.germania-one";
var type$n = "font";
var source$6 = "https://fonts.googleapis.com/css2?family=Germania+One";
var fontGermaniaOneJson = {
  label: label$o,
  id: id$n,
  type: type$n,
  source: source$6
};
var label$n = "Kenia";
var id$m = "com.moviemasher.font.kenia";
var type$m = "font";
var source$5 = "https://fonts.googleapis.com/css2?family=Kenia";
var fontKeniaJson = {
  label: label$n,
  id: id$m,
  type: type$m,
  source: source$5
};
var label$m = "Luckiest Guy";
var id$l = "com.moviemasher.font.luckiest-guy";
var type$l = "font";
var source$4 = "https://fonts.googleapis.com/css2?family=Luckiest+Guy";
var fontLuckiestGuyJson = {
  label: label$m,
  id: id$l,
  type: type$l,
  source: source$4
};
var label$l = "Monoton";
var id$k = "com.moviemasher.font.monoton";
var type$k = "font";
var source$3 = "https://fonts.googleapis.com/css2?family=Monoton";
var fontMonotonJson = {
  label: label$l,
  id: id$k,
  type: type$k,
  source: source$3
};
var label$k = "Oleo Script";
var id$j = "com.moviemasher.font.oleo-script";
var type$j = "font";
var source$2 = "https://fonts.googleapis.com/css2?family=Oleo+Script";
var fontOleoScriptJson = {
  label: label$k,
  id: id$j,
  type: type$j,
  source: source$2
};
var label$j = "Shojumaru";
var id$i = "com.moviemasher.font.shojumaru";
var type$i = "font";
var source$1 = "https://fonts.googleapis.com/css2?family=Shojumaru";
var fontShojumaruJson = {
  label: label$j,
  id: id$i,
  type: type$i,
  source: source$1
};
var label$i = "Rubik+Dirt";
var id$h = "com.moviemasher.font.rubik-dirt";
var type$h = "font";
var source = "https://fonts.googleapis.com/css2?family=Rubik+Dirt";
var fontRubikDirtJson = {
  label: label$i,
  id: id$h,
  type: type$h,
  source
};
var fontDefaultId = fontDefaultJson.id;
var fontDefinition = (object) => {
  const { id: idString } = object;
  const id2 = idString && isPopulatedString(idString) ? idString : fontDefaultId;
  return new FontDefinitionClass({ ...object, type: DefinitionType.Font, id: id2 });
};
var fontDefault = fontDefinition(fontDefaultJson);
var fontDefaults = [
  fontDefault,
  fontDefinition(fontButchermanJson),
  fontDefinition(fontCroissantOneJson),
  fontDefinition(fontKeniaJson),
  fontDefinition(fontGermaniaOneJson),
  fontDefinition(fontLuckiestGuyJson),
  fontDefinition(fontMonotonJson),
  fontDefinition(fontOleoScriptJson),
  fontDefinition(fontShojumaruJson),
  fontDefinition(fontRubikDirtJson)
];
var fontDefinitionFromId = (id2) => {
  const definition = fontDefaults.find((definition2) => definition2.id === id2);
  if (definition)
    return definition;
  return fontDefinition({ id: id2 });
};
var fontInstance = (object) => {
  const { definitionId = "" } = object;
  const definition = fontDefinitionFromId(definitionId);
  return definition.instanceFromObject(object);
};
var fontFromId = (definitionId) => {
  const definition = fontDefinitionFromId(definitionId);
  return definition.instanceFromObject();
};
Factories[DefinitionType.Font] = {
  definition: fontDefinition,
  definitionFromId: fontDefinitionFromId,
  fromId: fontFromId,
  instance: fontInstance,
  defaults: fontDefaults
};
var TextContainerDefinitionWithTweenable = TweenableDefinitionMixin(DefinitionBase);
var TextContainerDefinitionWithContainer = ContainerDefinitionMixin(TextContainerDefinitionWithTweenable);
var TextContainerDefinitionIcon = "M2.5 4v3h5v12h3V7h5V4h-13zm19 5h-9v3h3v7h3v-7h3V9z";
var TextContainerDefinitionClass = class extends TextContainerDefinitionWithContainer {
  constructor(...args) {
    super(...args);
    this.properties.push(propertyInstance({
      name: "string",
      custom: true,
      type: DataType.String,
      defaultValue: "Text"
    }));
    this.properties.push(propertyInstance({
      name: "fontId",
      custom: true,
      type: DataType.FontId,
      defaultValue: fontDefault.id
    }));
    this.properties.push(propertyInstance({
      name: "height",
      tweenable: true,
      custom: true,
      type: DataType.Percent,
      defaultValue: 0.3,
      max: 2,
      group: DataGroup.Size
    }));
    this.properties.push(propertyInstance({
      name: "width",
      tweenable: true,
      custom: true,
      type: DataType.Percent,
      defaultValue: 0.8,
      max: 2,
      group: DataGroup.Size
    }));
  }
  definitionIcon(loader, size) {
    const superElement = super.definitionIcon(loader, size);
    if (superElement)
      return superElement;
    const inSize = { width: 24, height: 24 };
    const coverSize = sizeCover(inSize, size, true);
    const outRect = { ...coverSize, ...centerPoint(size, coverSize) };
    const pathElement = svgPathElement(TextContainerDefinitionIcon);
    svgSetTransformRects(pathElement, inSize, outRect);
    return Promise.resolve(svgElement(size, pathElement));
  }
  instanceArgs(object) {
    const textObject = object || {};
    if (isUndefined(textObject.lock))
      textObject.lock = Orientation.V;
    return super.instanceArgs(textObject);
  }
  instanceFromObject(object = {}) {
    return new TextContainerClass(this.instanceArgs(object));
  }
};
var label$h = "Rectangle";
var type$g = "container";
var defaultContainer = {
  label: label$h,
  type: type$g
};
var label$g = "Heart: Remix Icons";
var type$f = "container";
var id$g = "com.remixicon.container.heart";
var pathWidth$7 = 24;
var pathHeight$7 = 24;
var path$7 = "M16.5 3C19.538 3 22 5.5 22 9c0 7-7.5 11-10 12.5C9.5 20 2 16 2 9c0-3.5 2.5-6 5.5-6C9.36 3 11 4 12 5c1-1 2.64-2 4.5-2z";
var heartContainer = {
  label: label$g,
  type: type$f,
  id: id$g,
  pathWidth: pathWidth$7,
  pathHeight: pathHeight$7,
  path: path$7
};
var label$f = "Cloud: Ant Design";
var id$f = "design.ant.container.cloud";
var pathWidth$6 = 1024;
var pathHeight$6 = 1024;
var path$6 = "M811.4 418.7C765.6 297.9 648.9 212 512.2 212S258.8 297.8 213 418.6C127.3 441.1 64 519.1 64 612c0 110.5 89.5 200 199.9 200h496.2C870.5 812 960 722.5 960 612c0-92.7-63.1-170.7-148.6-193.3z";
var cloudContainer = {
  label: label$f,
  id: id$f,
  pathWidth: pathWidth$6,
  pathHeight: pathHeight$6,
  path: path$6
};
var label$e = "Apple: Dev Icons";
var type$e = "container";
var id$e = "devicons.container.apple";
var pathWidth$5 = 32;
var pathHeight$5 = 32;
var path$5 = "M23.023 17.093c-0.033-3.259 2.657-4.822 2.777-4.901-1.512-2.211-3.867-2.514-4.705-2.548-2.002-0.204-3.91 1.18-4.926 1.18-1.014 0-2.583-1.15-4.244-1.121-2.185 0.033-4.199 1.271-5.323 3.227-2.269 3.936-0.58 9.769 1.631 12.963 1.081 1.561 2.37 3.318 4.061 3.254 1.63-0.064 2.245-1.055 4.215-1.055s2.524 1.055 4.248 1.021c1.753-0.032 2.864-1.591 3.936-3.159 1.24-1.814 1.751-3.57 1.782-3.659-0.038-0.017-3.416-1.312-3.451-5.202zM19.783 7.53c0.897-1.089 1.504-2.602 1.34-4.108-1.294 0.053-2.861 0.86-3.79 1.948-0.832 0.965-1.561 2.502-1.365 3.981 1.444 0.112 2.916-0.734 3.816-1.821z";
var appleContainer = {
  label: label$e,
  type: type$e,
  id: id$e,
  pathWidth: pathWidth$5,
  pathHeight: pathHeight$5,
  path: path$5
};
var label$d = "Starburst: Typicons";
var type$d = "container";
var id$d = "com.s-ings.container.starburst";
var pathWidth$4 = 24;
var pathHeight$4 = 24;
var path$4 = "M19.064 10.109l1.179-2.387c.074-.149.068-.327-.015-.471-.083-.145-.234-.238-.401-.249l-2.656-.172-.172-2.656c-.011-.167-.104-.317-.249-.401-.145-.084-.322-.09-.472-.015l-2.385 1.18-1.477-2.215c-.186-.278-.646-.278-.832 0l-1.477 2.215-2.385-1.18c-.151-.075-.327-.069-.472.015-.145.083-.238.234-.249.401l-.171 2.656-2.657.171c-.167.011-.318.104-.401.249-.084.145-.089.322-.015.472l1.179 2.386-2.214 1.477c-.139.093-.223.249-.223.416s.083.323.223.416l2.215 1.477-1.18 2.386c-.074.15-.068.327.015.472.083.144.234.238.401.248l2.656.171.171 2.657c.011.167.104.317.249.401.144.083.32.088.472.015l2.386-1.179 1.477 2.214c.093.139.249.223.416.223s.323-.083.416-.223l1.477-2.214 2.386 1.179c.15.073.327.068.472-.015s.238-.234.249-.401l.171-2.656 2.656-.172c.167-.011.317-.104.401-.249.083-.145.089-.322.015-.472l-1.179-2.385 2.214-1.478c.139-.093.223-.249.223-.416s-.083-.323-.223-.416l-2.214-1.475z";
var starburstContainer = {
  label: label$d,
  type: type$d,
  id: id$d,
  pathWidth: pathWidth$4,
  pathHeight: pathHeight$4,
  path: path$4
};
var label$c = "Rounded Rect";
var type$c = "container";
var id$c = "com.moviemasher.container.rounded-rect";
var pathWidth$3 = 1920;
var pathHeight$3 = 1080;
var path$3 = "M 358.00 980.00 C 215.51 980.00 100.00 864.49 100.00 722.00 L 100.00 358.00 C 100.00 215.51 215.51 100.00 358.00 100.00 L 1562.00 100.00 C 1704.49 100.00 1820.00 215.51 1820.00 358.00 L 1820.00 722.00 C 1820.00 864.49 1704.49 980.00 1562.00 980.00 Z M 358.00 980.00";
var roundedRectContainer = {
  label: label$c,
  type: type$c,
  id: id$c,
  pathWidth: pathWidth$3,
  pathHeight: pathHeight$3,
  path: path$3
};
var label$b = "Text";
var type$b = "text";
var id$b = "com.moviemasher.container.text";
var fontId = "com.moviemasher.font.default";
var textContainer = {
  label: label$b,
  type: type$b,
  id: id$b,
  fontId
};
var label$a = "Fire: Ant Design";
var type$a = "container";
var id$a = "design.ant.container.fire";
var pathWidth$2 = 1024;
var pathHeight$2 = 1024;
var path$2 = "M834.1 469.2A347.49 347.49 0 0 0 751.2 354l-29.1-26.7a8.09 8.09 0 0 0-13 3.3l-13 37.3c-8.1 23.4-23 47.3-44.1 70.8-1.4 1.5-3 1.9-4.1 2-1.1.1-2.8-.1-4.3-1.5-1.4-1.2-2.1-3-2-4.8 3.7-60.2-14.3-128.1-53.7-202C555.3 171 510 123.1 453.4 89.7l-41.3-24.3c-5.4-3.2-12.3 1-12 7.3l2.2 48c1.5 32.8-2.3 61.8-11.3 85.9-11 29.5-26.8 56.9-47 81.5a295.64 295.64 0 0 1-47.5 46.1 352.6 352.6 0 0 0-100.3 121.5A347.75 347.75 0 0 0 160 610c0 47.2 9.3 92.9 27.7 136a349.4 349.4 0 0 0 75.5 110.9c32.4 32 70 57.2 111.9 74.7C418.5 949.8 464.5 959 512 959s93.5-9.2 136.9-27.3A348.6 348.6 0 0 0 760.8 857c32.4-32 57.8-69.4 75.5-110.9a344.2 344.2 0 0 0 27.7-136c0-48.8-10-96.2-29.9-140.9z";
var fireContainer = {
  label: label$a,
  type: type$a,
  id: id$a,
  pathWidth: pathWidth$2,
  pathHeight: pathHeight$2,
  path: path$2
};
var label$9 = "Flag: Ant Design";
var type$9 = "container";
var id$9 = "design.ant.container.flag";
var pathWidth$1 = 1024;
var pathHeight$1 = 1024;
var path$1 = "M880 305H624V192c0-17.7-14.3-32-32-32H184v-40c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v784c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V640h248v113c0 17.7 14.3 32 32 32h416c17.7 0 32-14.3 32-32V337c0-17.7-14.3-32-32-32z";
var flagContainer = {
  label: label$9,
  type: type$9,
  id: id$9,
  pathWidth: pathWidth$1,
  pathHeight: pathHeight$1,
  path: path$1
};
var label$8 = "Oval";
var type$8 = "container";
var id$8 = "com.moviemasher.container.oval";
var pathWidth = 24;
var pathHeight = 24;
var path = "M0,12 a12,12 0 1,0 24,0 a12,12 0 1,0 -24,0";
var ovalContainer = {
  label: label$8,
  type: type$8,
  id: id$8,
  pathWidth,
  pathHeight,
  path
};
var containerDefaults = [
  new TextContainerDefinitionClass(textContainer),
  new ShapeContainerDefinitionClass({ id: DefaultContainerId, ...defaultContainer }),
  new ShapeContainerDefinitionClass(roundedRectContainer),
  new ShapeContainerDefinitionClass(ovalContainer),
  new ShapeContainerDefinitionClass(starburstContainer),
  new ShapeContainerDefinitionClass(heartContainer),
  new ShapeContainerDefinitionClass(cloudContainer),
  new ShapeContainerDefinitionClass(fireContainer),
  new ShapeContainerDefinitionClass(flagContainer),
  new ShapeContainerDefinitionClass(appleContainer)
];
var containerDefinition = (object) => {
  const { id: id2 } = object;
  assertPopulatedString(id2, "containerDefinition id");
  return new ShapeContainerDefinitionClass({ ...object, type: DefinitionType.Container });
};
var containerDefinitionFromId = (id2) => {
  const definition = containerDefaults.find((definition2) => definition2.id === id2);
  if (definition)
    return definition;
  return containerDefinition({ id: id2 });
};
var containerInstance = (object) => {
  const { definitionId } = object;
  if (!definitionId)
    throw Errors.id;
  const definition = containerDefinitionFromId(definitionId);
  const instance = definition.instanceFromObject(object);
  return instance;
};
var containerFromId = (id2) => {
  const definition = containerDefinitionFromId(id2);
  const instance = definition.instanceFromObject({ definitionId: id2 });
  return instance;
};
Factories[DefinitionType.Container] = {
  definition: containerDefinition,
  definitionFromId: containerDefinitionFromId,
  fromId: containerFromId,
  instance: containerInstance,
  defaults: containerDefaults
};
function ContentDefinitionMixin(Base) {
  return class extends Base {
    constructor() {
      super(...arguments);
      __publicField(this, "type", DefinitionType.Content);
    }
  };
}
function ModularMixin(Base) {
  return class extends Base {
    commandFilters(args) {
      const commandFilters = [];
      const { videoRate: videoRate2, filterInput, time } = args;
      assertPopulatedString(filterInput);
      const duration = isTimeRange(time) ? time.lengthSeconds : 0;
      const { filters: filters2 } = this.definition;
      const filterArgs = {
        videoRate: videoRate2,
        duration,
        filterInput
      };
      commandFilters.push(...filters2.flatMap((filter) => {
        this.setFilterValues(filter);
        const filters3 = filter.commandFilters(filterArgs);
        if (filters3.length) {
          filterArgs.filterInput = arrayLast(arrayLast(filters3).outputs);
        }
        return filters3;
      }));
      return commandFilters;
    }
    setFilterValues(filter) {
      const filterNames = filter.properties.map((property) => property.name);
      const propertyNames = this.properties.map((property) => property.name);
      const shared = propertyNames.filter((name) => filterNames.includes(name));
      shared.forEach((name) => {
        const property = this.properties.find((property2) => property2.name === name);
        assertProperty(property);
        const { tweenable } = property;
        filter.setValue(this.value(name), name);
        if (tweenable) {
          const tweenName = `${name}${PropertyTweenSuffix}`;
          filter.setValue(this.value(tweenName), tweenName);
        }
      });
    }
    svgFilters(previewSize, containerRect, time, range) {
      const svgFilters = [];
      const { filters: filters2 } = this.definition;
      svgFilters.push(...filters2.flatMap((filter) => {
        this.setFilterValues(filter);
        return filter.filterSvgFilter();
      }));
      return svgFilters;
    }
  };
}
var EffectWithModular = ModularMixin(InstanceBase);
var EffectClass = class extends EffectWithModular {
  constructor() {
    super(...arguments);
    __publicField(this, "_tweenable");
    __publicField(this, "selectType", SelectType.None);
  }
  get tweenable() {
    return this._tweenable;
  }
  set tweenable(value) {
    this._tweenable = value;
  }
  selectables() {
    return [this, ...this.tweenable.selectables()];
  }
  selectedItems(actions) {
    return this.properties.map((property) => {
      const undoValue = this.value(property.name);
      const target = this;
      return {
        value: undoValue,
        selectType: SelectType.None,
        property,
        changeHandler: (property2, redoValue) => {
          assertPopulatedString(property2);
          const options2 = { target, property: property2, redoValue, undoValue };
          actions.create(options2);
        }
      };
    });
  }
};
function ModularDefinitionMixin(Base) {
  return class extends Base {
    constructor(...args) {
      super(...args);
      __publicField(this, "filters", []);
      __publicField(this, "finalizeFilter");
      __publicField(this, "initializeFilter");
      const [object] = args;
      const { properties: properties2, filters: filters2, initializeFilter, finalizeFilter } = object;
      if (properties2 == null ? void 0 : properties2.length)
        this.properties.push(...properties2.map((property) => propertyInstance({ ...property, custom: true })));
      if (initializeFilter)
        this.initializeFilter = filterInstance(initializeFilter);
      if (finalizeFilter)
        this.finalizeFilter = filterInstance(finalizeFilter);
      if (filters2)
        this.filters.push(...filters2.map((filter) => filterInstance(filter)));
    }
    toJSON() {
      const object = super.toJSON();
      const custom = this.properties.filter((property) => property.custom);
      if (custom.length)
        object.properties = custom;
      if (this.filters.length)
        object.filters = this.filters;
      return object;
    }
  };
}
var EffectDefinitionWithModular = ModularDefinitionMixin(DefinitionBase);
var EffectDefinitionClass = class extends EffectDefinitionWithModular {
  constructor(...args) {
    super(...args);
    __publicField(this, "type", DefinitionType.Effect);
    this.properties.push(propertyInstance({ name: "label", defaultValue: "" }));
  }
  instanceArgs(object) {
    const args = super.instanceArgs(object);
    args.label || (args.label = this.label);
    return args;
  }
  instanceFromObject(object = {}) {
    return new EffectClass(this.instanceArgs(object));
  }
};
var label$7 = "Blur";
var type$7 = "effect";
var id$7 = "com.moviemasher.effect.blur";
var filters$5 = [
  {
    id: "com.moviemasher.filter.convolution",
    parameters: [
      {
        name: "matrix",
        value: "1,1,1,1,1,1,1,1,1"
      },
      {
        name: "multiplier",
        value: "0.11"
      }
    ]
  }
];
var effectBlurJson = {
  label: label$7,
  type: type$7,
  id: id$7,
  filters: filters$5
};
var label$6 = "Chromakey";
var type$6 = "effect";
var id$6 = "com.moviemasher.effect.chromakey";
var properties$2 = [
  {
    name: "blend",
    defaultValue: 0,
    step: 0.01,
    min: 0,
    max: 1
  },
  {
    name: "similarity",
    defaultValue: 0.9,
    step: 0.01,
    min: 0,
    max: 1
  },
  {
    name: "color",
    type: "rgb",
    defaultValue: "#00FF00"
  }
];
var filters$4 = [
  {
    id: "com.moviemasher.filter.chromakey",
    parameters: [
      {
        name: "color",
        value: "color",
        dataType: "string"
      },
      {
        name: "blend",
        value: "blend",
        dataType: "string"
      },
      {
        name: "similarity",
        value: "similarity",
        dataType: "string"
      }
    ]
  }
];
var effectChromaKeyJson = {
  label: label$6,
  type: type$6,
  id: id$6,
  properties: properties$2,
  filters: filters$4
};
var label$5 = "Emboss";
var type$5 = "effect";
var id$5 = "com.moviemasher.effect.emboss";
var properties$1 = [];
var filters$3 = [
  {
    id: "com.moviemasher.filter.convolution",
    parameters: [
      {
        name: "matrix",
        value: "-2,-1,0,-1,1,1,0,1,2"
      }
    ]
  }
];
var effectEmbossJson = {
  label: label$5,
  type: type$5,
  id: id$5,
  properties: properties$1,
  filters: filters$3
};
var label$4 = "Grayscale";
var type$4 = "effect";
var id$4 = "com.moviemasher.effect.grayscale";
var filters$2 = [
  {
    id: "com.moviemasher.filter.colorchannelmixer",
    parameters: [
      {
        name: "rr",
        value: 0.3
      },
      {
        name: "rg",
        value: 0.4
      },
      {
        name: "rb",
        value: 0.3
      },
      {
        name: "ra",
        value: 0
      },
      {
        name: "gr",
        value: 0.3
      },
      {
        name: "gg",
        value: 0.4
      },
      {
        name: "gb",
        value: 0.3
      },
      {
        name: "ga",
        value: 0
      },
      {
        name: "br",
        value: 0.3
      },
      {
        name: "bg",
        value: 0.4
      },
      {
        name: "bb",
        value: 0.3
      },
      {
        name: "ba",
        value: 0
      },
      {
        name: "ar",
        value: 0
      },
      {
        name: "ag",
        value: 0
      },
      {
        name: "ab",
        value: 0
      },
      {
        name: "aa",
        value: 1
      }
    ]
  }
];
var effectGrayscaleJson = {
  label: label$4,
  type: type$4,
  id: id$4,
  filters: filters$2
};
var label$3 = "Sepia";
var type$3 = "effect";
var id$3 = "com.moviemasher.effect.sepia";
var filters$1 = [
  {
    id: "com.moviemasher.filter.colorchannelmixer",
    parameters: [
      {
        name: "rr",
        value: 0.393
      },
      {
        name: "rg",
        value: 0.769
      },
      {
        name: "rb",
        value: 0.189
      },
      {
        name: "gr",
        value: 0.349
      },
      {
        name: "gg",
        value: 0.686
      },
      {
        name: "gb",
        value: 0.168
      },
      {
        name: "br",
        value: 0.272
      },
      {
        name: "bg",
        value: 0.534
      },
      {
        name: "bb",
        value: 0.131
      }
    ]
  }
];
var effectSepiaJson = {
  label: label$3,
  type: type$3,
  id: id$3,
  filters: filters$1
};
var label$2 = "Sharpen";
var type$2 = "effect";
var id$2 = "com.moviemasher.effect.sharpen";
var properties = [];
var filters = [
  {
    id: "com.moviemasher.filter.convolution",
    parameters: [
      {
        name: "matrix",
        value: "0,-1,0,-1,5,-1,0,-1,0"
      }
    ]
  }
];
var effectSharpenJson = {
  label: label$2,
  type: type$2,
  id: id$2,
  properties,
  filters
};
var effectDefinition = (object) => {
  const { id: id2 } = object;
  assertPopulatedString(id2);
  return new EffectDefinitionClass({ ...object, type: DefinitionType.Effect });
};
var effectDefaults = [
  effectDefinition(effectBlurJson),
  effectDefinition(effectChromaKeyJson),
  effectDefinition(effectEmbossJson),
  effectDefinition(effectGrayscaleJson),
  effectDefinition(effectSepiaJson),
  effectDefinition(effectSharpenJson)
  // effectDefinition(effectTextJson),
];
var effectDefinitionFromId = (id2) => {
  const definition = effectDefaults.find((definition2) => definition2.id === id2);
  if (definition)
    return definition;
  return effectDefinition({ id: id2 });
};
var effectInstance = (object) => {
  const { definitionId = "" } = object;
  const definition = effectDefinitionFromId(definitionId);
  return definition.instanceFromObject(object);
};
var effectFromId = (definitionId) => {
  const definition = effectDefinitionFromId(definitionId);
  return definition.instanceFromObject();
};
Factories[DefinitionType.Effect] = {
  definition: effectDefinition,
  definitionFromId: effectDefinitionFromId,
  fromId: effectFromId,
  instance: effectInstance,
  defaults: effectDefaults
};
var isAudio = (value) => {
  return isContent(value) && isAudioDefinition(value.definition);
};
var isAudioDefinition = (value) => {
  return isDefinition(value) && value.type === DefinitionType.Audio;
};
function ContentMixin(Base) {
  return class extends Base {
    constructor(...args) {
      super(...args);
      __publicField(this, "effects", []);
      const [object] = args;
      const { isDefaultOrAudio, container } = this;
      if (!(isDefaultOrAudio || container)) {
        this.addProperties(object, propertyInstance({
          name: "x",
          type: DataType.Percent,
          defaultValue: 0.5,
          group: DataGroup.Point,
          tweenable: true
        }));
        this.addProperties(object, propertyInstance({
          name: "y",
          type: DataType.Percent,
          defaultValue: 0.5,
          group: DataGroup.Point,
          tweenable: true
        }));
        this.addProperties(object, propertyInstance({
          name: "lock",
          type: DataType.String,
          defaultValue: Orientation.H,
          group: DataGroup.Size
        }));
      }
      const { effects } = object;
      if (effects)
        this.effects.push(...effects.map((effectObject) => {
          const instance = effectInstance(effectObject);
          instance.tweenable = this;
          return instance;
        }));
    }
    audibleCommandFiles(args) {
      const graphFileArgs = {
        ...args,
        audible: true,
        visible: false
      };
      return this.fileCommandFiles(graphFileArgs);
    }
    audibleCommandFilters(args) {
      const commandFilters = [];
      const { time, quantize, commandFiles, clipTime } = args;
      const timeDuration = time.isRange ? time.lengthSeconds : 0;
      const duration = timeDuration ? Math.min(timeDuration, clipTime.lengthSeconds) : 0;
      const { id: id2 } = this;
      let filterInput = commandFilesInput(commandFiles, id2, false);
      const trimFilter = "atrim";
      const trimId = idGenerate(trimFilter);
      const trimOptions = {};
      const { frame } = this.definitionTime(time, clipTime);
      if (duration)
        trimOptions.duration = duration;
      if (frame)
        trimOptions.start = timeFromArgs(frame, quantize).seconds;
      const commandFilter = {
        inputs: [filterInput],
        ffmpegFilter: trimFilter,
        options: trimOptions,
        outputs: [trimId]
      };
      commandFilters.push(commandFilter);
      filterInput = trimId;
      const delays = (clipTime.seconds - time.seconds) * 1e3;
      if (delays) {
        const adelayFilter = "adelay";
        const adelayId = idGenerate(adelayFilter);
        const adelayCommandFilter = {
          ffmpegFilter: adelayFilter,
          options: { delays, all: 1 },
          inputs: [filterInput],
          outputs: [adelayId]
        };
        commandFilters.push(adelayCommandFilter);
        filterInput = adelayId;
      }
      commandFilters.push(...this.amixCommandFilters({ ...args, filterInput }));
      return commandFilters;
    }
    contentCommandFilters(args, tweening) {
      return this.effectsCommandFilters(args);
    }
    contentPreviewItemPromise(containerRect, time, timeRange, icon) {
      return this.itemPromise(containerRect, time, timeRange, icon);
    }
    contentRects(args) {
      const { containerRects: rects, time, timeRange, loading, editing } = args;
      const tuple = isArray(rects) ? rects : [rects, rects];
      if (loading && !this.intrinsicsKnown({ editing, size: true })) {
        return tuple;
      }
      const intrinsicRect = this.intrinsicRect(editing);
      if (!sizeAboveZero(intrinsicRect))
        return tuple;
      const { lock } = this;
      const tweenRects2 = this.tweenRects(time, timeRange);
      const locked = tweenRectsLock(tweenRects2, lock);
      const coverSizes = tweenCoverSizes(intrinsicRect, rects, locked);
      const [size, sizeEnd] = coverSizes;
      const coverPoints = tweenCoverPoints(coverSizes, rects, locked);
      const [point, pointEnd] = coverPoints;
      const rect = rectFromSize(size, point);
      const rectEnd = rectFromSize(sizeEnd, pointEnd);
      return [rect, rectEnd];
    }
    contentSvgFilter(contentItem, outputSize, containerRect, time, clipTime) {
      const { effects, isDefaultOrAudio } = this;
      if (isDefaultOrAudio || !effects.length)
        return;
      const svgFilters = this.effects.flatMap((effect) => effect.svgFilters(outputSize, containerRect, time, clipTime));
      const filter = svgFilterElement(svgFilters, contentItem);
      svgSet(filter, "200%", "width");
      svgSet(filter, "200%", "height");
      return filter;
    }
    definitionIds() {
      return [
        ...super.definitionIds(),
        ...this.effects.flatMap((effect) => effect.definitionIds())
      ];
    }
    effectsCommandFilters(args) {
      const commandFilters = [];
      const { filterInput: input } = args;
      let filterInput = input;
      assertPopulatedString(filterInput);
      const { effects, isDefaultOrAudio } = this;
      if (isDefaultOrAudio)
        return commandFilters;
      commandFilters.push(...effects.flatMap((effect) => {
        const filters2 = effect.commandFilters({ ...args, filterInput });
        if (filters2.length)
          filterInput = arrayLast(arrayLast(filters2).outputs);
        return filters2;
      }));
      return commandFilters;
    }
    intrinsicRect(_ = false) {
      return RectZero;
    }
    get isDefault() {
      return this.definitionId === "com.moviemasher.content.default";
    }
    get isDefaultOrAudio() {
      return this.isDefault || isAudio(this);
    }
    itemPromise(containerRect, time, range, icon) {
      throw new Error(Errors.unimplemented);
    }
    selectedItems(actions) {
      const selectedItems = super.selectedItems(actions);
      if (this.isDefaultOrAudio || this.container)
        return selectedItems;
      const { effects, selectType } = this;
      const undoEffects = [...effects];
      const effectable = this;
      const selectedEffects = {
        selectType,
        value: this.effects,
        removeHandler: (effect) => {
          const options2 = {
            redoSelection: { ...actions.selection, effect: void 0 },
            effects,
            undoEffects,
            redoEffects: effects.filter((other) => other !== effect),
            type: ActionType.MoveEffect
          };
          actions.create(options2);
        },
        moveHandler: (effect, index = 0) => {
          assertPositive(index, "index");
          const redoEffects = undoEffects.filter((e) => e !== effect);
          const currentIndex = undoEffects.indexOf(effect);
          const insertIndex = currentIndex < index ? index - 1 : index;
          redoEffects.splice(insertIndex, 0, effect);
          const options2 = {
            effects,
            undoEffects,
            redoEffects,
            type: ActionType.MoveEffect,
            effectable
          };
          actions.create(options2);
        },
        addHandler: (effect, insertIndex = 0) => {
          assertPositive(insertIndex, "index");
          const redoEffects = [...effects];
          redoEffects.splice(insertIndex, 0, effect);
          effect.tweenable = this;
          const options2 = {
            effects,
            undoEffects,
            redoEffects,
            redoSelection: { ...actions.selection, effect },
            type: ActionType.MoveEffect
          };
          actions.create(options2);
        }
      };
      selectedItems.push(selectedEffects);
      return selectedItems;
    }
    selectedProperty(property) {
      const { name } = property;
      switch (name) {
        case "effects":
        case "lock":
        case "width":
        case "height":
        case "x":
        case "y":
          return !this.isDefaultOrAudio;
      }
      return super.selectedProperty(property);
    }
    toJSON() {
      const json = super.toJSON();
      json.effects = this.effects;
      return json;
    }
  };
}
var isColorContent = (value) => {
  return isContent(value) && "color" in value;
};
var ColorContentWithTweenable = TweenableMixin(InstanceBase);
var ColorContentWithContent = ContentMixin(ColorContentWithTweenable);
var ColorContentClass = class extends ColorContentWithContent {
  constructor(...args) {
    super(...args);
    __publicField(this, "_colorFilter");
    const [object] = args;
    this.addProperties(object, propertyInstance({
      tweenable: true,
      name: "color",
      type: DataType.Rgb,
      defaultValue: this.definition.color,
      group: DataGroup.Color
    }));
  }
  get colorFilter() {
    return this._colorFilter || (this._colorFilter = filterFromId("color"));
  }
  contentColors(time, range) {
    const [color2, colorEndOrNot] = this.tweenValues("color", time, range);
    assertPopulatedString(color2);
    const colorEnd = isPopulatedString(colorEndOrNot) ? colorEndOrNot : color2;
    return [color2, colorEnd];
  }
  contentPreviewItemPromise(containerRect, time, range, icon) {
    const { colorFilter } = this;
    const [color2] = this.tweenValues("color", time, range);
    const { x, y, width: width2, height: height2 } = containerRect;
    colorFilter.setValues({ width: width2, height: height2, color: color2 });
    const svg = colorFilter.filterSvg();
    svg.setAttribute("x", String(x));
    svg.setAttribute("y", String(y));
    return Promise.resolve(svg);
  }
};
var ColorContentDefinitionWithTweenable = TweenableDefinitionMixin(DefinitionBase);
var ColorContentDefinitionWithContent = ContentDefinitionMixin(ColorContentDefinitionWithTweenable);
var ColorContentDefinitionClass = class extends ColorContentDefinitionWithContent {
  constructor(...args) {
    super(...args);
    __publicField(this, "color", colorBlack);
    const [object] = args;
    const { color: color2 } = object;
    if (isPopulatedString(color2))
      this.color = color2;
  }
  instanceFromObject(object = {}) {
    return new ColorContentClass(this.instanceArgs(object));
  }
};
var label$1 = "Color";
var type$1 = "content";
var id$1 = "com.moviemasher.content.default";
var color = "#FFFFFF";
var defaultContent = {
  label: label$1,
  type: type$1,
  id: id$1,
  color
};
var contentDefaults = [
  new ColorContentDefinitionClass({ ...defaultContent, id: DefaultContentId })
];
var contentDefinition = (object) => {
  const { id: id2 } = object;
  assertPopulatedString(id2, "contentDefinition id");
  throw "contentDefinition";
};
var contentDefinitionFromId = (id2) => {
  const definition = contentDefaults.find((definition2) => definition2.id === id2);
  if (definition)
    return definition;
  return contentDefinition({ id: id2 });
};
var contentInstance = (object) => {
  const { definitionId } = object;
  if (!definitionId)
    throw Errors.id;
  const definition = contentDefinitionFromId(definitionId);
  const instance = definition.instanceFromObject(object);
  return instance;
};
var contentFromId = (id2) => {
  const definition = contentDefinitionFromId(id2);
  const instance = definition.instanceFromObject({ definitionId: id2 });
  return instance;
};
Factories[DefinitionType.Content] = {
  definition: contentDefinition,
  definitionFromId: contentDefinitionFromId,
  fromId: contentFromId,
  instance: contentInstance,
  defaults: contentDefaults
};
var AudibleSampleRate = 44100;
var AudibleChannels = 2;
var AudibleContext = class {
  constructor() {
    __publicField(this, "_context");
    __publicField(this, "sourcesById", /* @__PURE__ */ new Map());
  }
  addSource(id2, source2) {
    this.sourcesById.set(id2, source2);
  }
  get context() {
    if (!this._context) {
      const Klass = AudioContext || window.webkitAudioContext;
      if (!Klass)
        throw Errors.audibleContext;
      this._context = new Klass();
    }
    return this._context;
  }
  createBuffer(seconds) {
    const length2 = AudibleSampleRate * seconds;
    return this.context.createBuffer(AudibleChannels, length2, AudibleSampleRate);
  }
  createBufferSource(buffer) {
    const sourceNode = this.context.createBufferSource();
    if (buffer)
      sourceNode.buffer = buffer;
    return sourceNode;
  }
  createGain() {
    return this.context.createGain();
  }
  get currentTime() {
    return this.context.currentTime;
  }
  decode(buffer) {
    return new Promise((resolve, reject) => this.context.decodeAudioData(buffer, (audioData) => resolve(audioData), (error) => reject(error)));
  }
  deleteSource(id2) {
    const source2 = this.getSource(id2);
    if (!source2)
      return;
    this.sourcesById.delete(id2);
    const { gainSource, gainNode } = source2;
    gainNode.disconnect(this.destination);
    gainSource.disconnect(gainNode);
    gainSource.stop();
  }
  get destination() {
    return this.context.destination;
  }
  getSource(id2) {
    return this.sourcesById.get(id2);
  }
  hasSource(id2) {
    return this.sourcesById.has(id2);
  }
  startAt(id2, source2, start, duration, offset2, loops = false) {
    const gainNode = this.createGain();
    source2.loop = loops;
    source2.connect(gainNode);
    gainNode.connect(this.destination);
    source2.start(this.currentTime + start, offset2, duration);
    this.addSource(id2, { gainSource: source2, gainNode });
  }
};
var AudibleContextInstance = new AudibleContext();
var createContextAudible = () => {
  return new AudibleContext();
};
var ContextFactory = {
  audible: createContextAudible
};
var isMashAndDefinitionsObject = (value) => {
  return isObject(value) && "mashObject" in value && "definitionObjects" in value;
};
var isMash = (value) => {
  return isObject(value) && "composition" in value;
};
function assertMash(value, name) {
  if (!isMash(value))
    throwError(value, "Mash", name);
}
var EditedClass = class extends PropertiedClass {
  constructor(args) {
    super();
    __publicField(this, "createdAt", "");
    __publicField(this, "data", {});
    __publicField(this, "_editor");
    __publicField(this, "_emitter");
    __publicField(this, "icon", "");
    __publicField(this, "_id", "");
    __publicField(this, "_imageSize", { ...SizeZero });
    __publicField(this, "_preloader");
    __publicField(this, "quantize", Default.mash.quantize);
    __publicField(this, "selectType", SelectType.None);
    const { createdAt, id: id2, icon, preloader, quantize } = args;
    if (preloader)
      this._preloader = preloader;
    if (isPopulatedString(id2))
      this._id = id2;
    if (isPopulatedString(icon))
      this.icon = icon;
    if (isPopulatedString(createdAt))
      this.createdAt = createdAt;
    if (isAboveZero(quantize))
      this.quantize = quantize;
    this.properties.push(propertyInstance({
      name: "label",
      type: DataType.String,
      defaultValue: ""
    }));
    this.properties.push(propertyInstance({
      name: "color",
      type: DataType.Rgb,
      defaultValue: colorBlack
    }));
    this.propertiesInitialize(args);
  }
  get buffer() {
    throw new Error(Errors.unimplemented + "get buffer");
  }
  set buffer(value) {
    throw new Error(Errors.unimplemented + "set buffer");
  }
  dataPopulate(rest) {
    const propertyNames = this.properties.map((property) => property.name);
    Object.entries(rest).forEach(([key, value]) => {
      if (propertyNames.find((name) => name === key))
        return;
      this.data[key] = value;
    });
  }
  destroy() {
  }
  get editor() {
    return this._editor;
  }
  set editor(value) {
    this._editor = value;
  }
  get emitter() {
    return this._emitter;
  }
  set emitter(value) {
    this._emitter = value;
    this.emitterChanged();
  }
  emitterChanged() {
  }
  editedGraphFiles(args) {
    return [];
  }
  get id() {
    return this._id || (this._id = idTemporary());
  }
  set id(value) {
    var _a;
    this._id = value;
    (_a = this.emitter) == null ? void 0 : _a.emit(EventType.Save);
  }
  get imageSize() {
    return this._imageSize;
  }
  set imageSize(value) {
    assertSizeAboveZero(value, "imageSize");
    this._imageSize = value;
  }
  loadPromise(args) {
    throw Errors.unimplemented;
  }
  get loading() {
    return false;
  }
  get mashes() {
    throw Errors.unimplemented;
  }
  get preloader() {
    return this._preloader;
  }
  putPromise() {
    throw new Error(Errors.unimplemented);
  }
  reload() {
    return;
  }
  selectables() {
    return [];
  }
  selectedItems(actions) {
    return [];
  }
  previewItems(options2) {
    throw Errors.unimplemented;
  }
  toJSON() {
    const json = super.toJSON();
    json.createdAt = this.createdAt;
    json.quantize = this.quantize;
    json.id = this.id;
    if (this.icon)
      json.icon = this.icon;
    Object.entries(this.data).forEach(([key, value]) => {
      if (isUndefined(json[key]))
        json[key] = value;
    });
    return json;
  }
};
var isClipObject = (value) => {
  return isInstanceObject(value);
};
var isClip = (value) => {
  return isInstance(value) && "contentId" in value;
};
function assertClip(value, name) {
  if (!isClip(value))
    throwError(value, "Clip", name);
}
var isTrack = (value) => {
  return isObject(value) && "frameForClipNearFrame" in value;
};
function assertTrack(value, name) {
  if (!isTrack(value))
    throwError(value, "Track", name);
}
function PreloadableDefinitionMixin(Base) {
  return class extends Base {
    constructor(...args) {
      super(...args);
      __publicField(this, "bytes", 0);
      __publicField(this, "loadType");
      __publicField(this, "mimeType", "");
      __publicField(this, "source");
      __publicField(this, "url");
      const [object] = args;
      const { source: source2, url, bytes, mimeType } = object;
      const sourceOrUrl = source2 || url || "";
      this.source = source2 || sourceOrUrl;
      this.url = url || sourceOrUrl;
      if (bytes)
        this.bytes = bytes;
      if (mimeType)
        this.mimeType = mimeType;
    }
    toJSON() {
      const json = super.toJSON();
      if (this.url)
        json.url = this.url;
      if (this.source)
        json.source = this.source;
      if (this.bytes)
        json.bytes = this.bytes;
      if (this.mimeType)
        json.mimeType = this.mimeType;
      return json;
    }
  };
}
function PreloadableMixin(Base) {
  return class extends Base {
  };
}
function UpdatableSizeMixin(Base) {
  return class extends Base {
    constructor(...args) {
      super(...args);
      __publicField(this, "colorMaximize", true);
      __publicField(this, "_setsarFilter");
      __publicField(this, "hasIntrinsicSizing", true);
      const [object] = args;
      const { container } = object;
      const min = container ? 0 : 1;
      this.addProperties(object, propertyInstance({
        tweenable: true,
        name: "width",
        type: DataType.Percent,
        group: DataGroup.Size,
        defaultValue: 1,
        max: 2,
        min
      }));
      this.addProperties(object, propertyInstance({
        tweenable: true,
        name: "height",
        type: DataType.Percent,
        group: DataGroup.Size,
        defaultValue: 1,
        max: 2,
        min
      }));
    }
    containerCommandFilters(args, tweening) {
      const commandFilters = [];
      const { commandFiles, containerRects, filterInput: input, videoRate: videoRate2, track } = args;
      let filterInput = input;
      const maxSize = tweening.size ? tweenMaxSize(...containerRects) : containerRects[0];
      const colorArgs = {
        ...args,
        contentColors: [colorBlackOpaque, colorBlackOpaque],
        outputSize: maxSize
        //{ width: maxSize.width * 2, height: maxSize.height * 2 }
      };
      commandFilters.push(...this.colorBackCommandFilters(colorArgs, `container-${track}-back`));
      const colorInput = arrayLast(arrayLast(commandFilters).outputs);
      const { id: id2 } = this;
      const fileInput = commandFilesInput(commandFiles, id2, true);
      commandFilters.push(...this.scaleCommandFilters({ ...args, filterInput: fileInput }));
      filterInput = arrayLast(arrayLast(commandFilters).outputs);
      if (tweening.size) {
        assertPopulatedString(filterInput, "overlay input");
        commandFilters.push(...this.overlayCommandFilters(colorInput, filterInput));
        filterInput = arrayLast(arrayLast(commandFilters).outputs);
      }
      const cropArgs = { duration: 0, videoRate: videoRate2 };
      assertPopulatedString(filterInput, "crop input");
      const { cropFilter } = this;
      cropFilter.setValue(maxSize.width, "width");
      cropFilter.setValue(maxSize.height, "height");
      cropFilter.setValue(0, "x");
      cropFilter.setValue(0, "y");
      commandFilters.push(...cropFilter.commandFilters({ ...cropArgs, filterInput }));
      filterInput = arrayLast(arrayLast(commandFilters).outputs);
      if (!tweening.size) {
        assertPopulatedString(filterInput, "overlay input");
        commandFilters.push(...this.overlayCommandFilters(colorInput, filterInput));
        filterInput = arrayLast(arrayLast(commandFilters).outputs);
      }
      assertPopulatedString(filterInput, "alphamerge input");
      commandFilters.push(...this.alphamergeCommandFilters({ ...args, filterInput }));
      filterInput = arrayLast(arrayLast(commandFilters).outputs);
      commandFilters.push(...this.containerFinalCommandFilters({ ...args, filterInput }));
      return commandFilters;
    }
    containerPreviewItemPromise(containerRect, time, range, icon) {
      return this.itemPromise(containerRect, time, range, icon);
    }
    contentCommandFilters(args, tweening) {
      const commandFilters = [];
      const { containerRects, visible, time, videoRate: videoRate2, clipTime, commandFiles, filterInput: input, track, upload } = args;
      if (!visible)
        return commandFilters;
      assertTimeRange(clipTime);
      assertPopulatedArray(containerRects, "containerRects");
      const { id: id2 } = this;
      let filterInput = input || commandFilesInput(commandFiles, id2, visible);
      const contentArgs = {
        containerRects,
        time,
        timeRange: clipTime
      };
      const contentRects = this.contentRects(contentArgs);
      const tweeningContainer = !rectsEqual(...containerRects);
      const [contentRect, contentRectEnd] = contentRects;
      const duration = isTimeRange(time) ? time.lengthSeconds : 0;
      const maxContainerSize = tweeningContainer ? tweenMaxSize(...containerRects) : containerRects[0];
      const colorInput = `content-${track}-back`;
      if (!upload) {
        const colorArgs = {
          ...args,
          contentColors: [colorTransparent, colorTransparent],
          outputSize: maxContainerSize
        };
        commandFilters.push(...this.colorBackCommandFilters(colorArgs, colorInput));
      }
      const scaleArgs = {
        ...args,
        filterInput,
        containerRects: contentRects
      };
      commandFilters.push(...this.scaleCommandFilters(scaleArgs));
      if (upload)
        return commandFilters;
      filterInput = arrayLast(arrayLast(commandFilters).outputs);
      if (tweening.size) {
        commandFilters.push(...this.overlayCommandFilters(colorInput, filterInput));
        filterInput = arrayLast(arrayLast(commandFilters).outputs);
      }
      const cropArgs = {
        duration,
        videoRate: videoRate2
      };
      const { cropFilter } = this;
      cropFilter.setValue(maxContainerSize.width, "width");
      cropFilter.setValue(maxContainerSize.height, "height");
      cropFilter.setValue(contentRect.x, "x");
      cropFilter.setValue(contentRect.y, "y");
      cropFilter.setValue(contentRectEnd.x, `x${PropertyTweenSuffix}`);
      cropFilter.setValue(contentRectEnd.y, `y${PropertyTweenSuffix}`);
      commandFilters.push(...cropFilter.commandFilters({ ...cropArgs, filterInput }));
      filterInput = arrayLast(arrayLast(commandFilters).outputs);
      const { setsarFilter } = this;
      setsarFilter.setValue("1/1", "sar");
      commandFilters.push(...setsarFilter.commandFilters({ ...cropArgs, filterInput }));
      filterInput = arrayLast(arrayLast(commandFilters).outputs);
      if (!tweening.size) {
        commandFilters.push(...this.overlayCommandFilters(colorInput, filterInput, this.definition.alpha));
        filterInput = arrayLast(arrayLast(commandFilters).outputs);
      }
      commandFilters.push(...super.contentCommandFilters({ ...args, filterInput }, tweening));
      return commandFilters;
    }
    get setsarFilter() {
      return this._setsarFilter || (this._setsarFilter = filterFromId("setsar"));
    }
    iconUrl(size, time, clipTime) {
      return this.definition.url;
    }
    initialCommandFilters(args, tweening, container = false) {
      const commandFilters = [];
      const { filterInput, track } = args;
      if (container) {
        assertPopulatedString(filterInput);
        commandFilters.push(this.copyCommandFilter(filterInput, track));
      }
      return commandFilters;
    }
    intrinsicRect(editing = false) {
      const key = editing ? "previewSize" : "sourceSize";
      const { [key]: size } = this.definition;
      assertSizeAboveZero(size, key);
      const rect = { ...PointZero, ...size };
      return rect;
    }
    intrinsicsKnown(options2) {
      const { editing, size } = options2;
      if (!size)
        return true;
      const key = editing ? "previewSize" : "sourceSize";
      const { [key]: definitionSize } = this.definition;
      return sizeAboveZero(definitionSize);
    }
    itemIconPromise(rect, time, range, cache) {
      const { clip } = this;
      const { preloader } = clip.track.mash;
      const url = this.iconUrl(sizeCopy(rect), time, range);
      const imageUrl = urlPrependProtocol("image", url);
      const svgUrl2 = urlPrependProtocol("svg", imageUrl, { ...rect });
      const definition = cache ? this.definition : void 0;
      return preloader.loadPromise(svgUrl2, definition);
    }
    // protected previewItem?: SvgItem
    itemPreviewPromise(rect, time, range) {
      return this.itemIconPromise(rect, time, range);
    }
    itemPromise(containerRect, time, range, icon) {
      const { container } = this;
      const rect = container ? containerRect : this.itemContentRect(containerRect, time, range);
      if (icon)
        return this.itemIconPromise(rect, time, range);
      return this.itemPreviewPromise(rect, time, range).then((svgItem) => {
        svgSetDimensions(svgItem, rect);
        return svgItem;
      });
    }
    itemContentRect(containerRect, time, timeRange) {
      const contentArgs = {
        containerRects: containerRect,
        time,
        timeRange,
        editing: true
      };
      const [contentRect] = this.contentRects(contentArgs);
      const { x, y } = contentRect;
      const point = { x: containerRect.x - x, y: containerRect.y - y };
      const rect = rectFromSize(contentRect, point);
      return rect;
    }
  };
}
function UpdatableSizeDefinitionMixin(Base) {
  return class extends Base {
    constructor(...args) {
      super(...args);
      __publicField(this, "alpha");
      __publicField(this, "previewSize");
      __publicField(this, "sourceSize");
      const [object] = args;
      const { sourceSize, previewSize } = object;
      if (sizeAboveZero(previewSize))
        this.previewSize = previewSize;
      if (sizeAboveZero(sourceSize))
        this.sourceSize = sourceSize;
    }
    toJSON() {
      const json = super.toJSON();
      const { sourceSize, previewSize } = this;
      if (sourceSize)
        json.sourceSize = this.sourceSize;
      if (previewSize)
        json.previewSize = this.previewSize;
      return json;
    }
  };
}
var UpdatableDurationDefinitionTypes = [
  DefinitionType.Audio,
  DefinitionType.Video,
  DefinitionType.VideoSequence
];
var isUpdatableDuration = (value) => {
  return isPreloadable(value) && "startOptions" in value;
};
function assertUpdatableDuration(value, name) {
  if (!isUpdatableDuration(value))
    throwError(value, "Updatable", name);
}
var isUpdatableDurationType = (value) => {
  return isDefinitionType(value) && UpdatableDurationDefinitionTypes.includes(value);
};
var isUpdatableDurationDefinition = (value) => {
  return isPreloadableDefinition(value) && "audibleSource" in value;
};
function assertUpdatableDurationDefinition(value, name) {
  if (!isUpdatableDurationDefinition(value))
    throwError(value, "UpdatableDefinition", name);
}
var AudibleGainDelimiter = ",";
function UpdatableDurationMixin(Base) {
  return class extends Base {
    constructor(...args) {
      super(...args);
      __publicField(this, "gain", 1);
      __publicField(this, "gainPairs", []);
      __publicField(this, "hasIntrinsicTiming", true);
      __publicField(this, "_trimFilter");
      const [object] = args;
      const { gain } = object;
      if (isDefined(gain)) {
        if (isString(gain)) {
          if (gain.includes(AudibleGainDelimiter)) {
            const floats = gain.split(AudibleGainDelimiter).map((string) => parseFloat(string));
            const z = floats.length / 2;
            for (let i = 0; i < z; i += 1) {
              this.gainPairs.push([floats[i * 2], floats[i * 2 + 1]]);
            }
            this.gain = -1;
          } else
            this.gain = Number(gain);
        } else if (isPositive(gain))
          this.gain = gain;
      }
    }
    definitionTime(masherTime, clipRange) {
      const superTime = super.definitionTime(masherTime, clipRange);
      const { startTrim, endTrim, definition } = this;
      const { duration } = definition;
      const durationTime = timeFromSeconds(duration, clipRange.fps);
      const durationFrames = durationTime.frame - (startTrim + endTrim);
      const offset2 = superTime.frame % durationFrames;
      return superTime.withFrame(offset2 + startTrim).divide(this.speed);
    }
    frames(quantize) {
      const { definition, startTrim, endTrim } = this;
      const frames = definition.frames(quantize);
      return frames - (startTrim + endTrim);
    }
    fileUrls(args) {
      const { editing, audible, time } = args;
      if (!audible || editing && !time.isRange) {
        return [];
      }
      if (!(this.mutable() && !this.muted))
        return [];
      const { definition } = this;
      const file = definition.urlAudible(editing);
      const graphFile = {
        type: LoadType.Audio,
        file,
        definition,
        input: true
      };
      return [graphFile];
    }
    hasGain() {
      if (this.gain === 0)
        return true;
      if (isPositive(this.gain))
        return false;
      if (this.gainPairs.length !== 2)
        return false;
      const [first, second] = this.gainPairs;
      if (first.length !== 2)
        return false;
      if (second.length !== 2)
        return false;
      if (Math.max(...first))
        return false;
      const [time, value] = second;
      return time === 1 && value === 0;
    }
    initialCommandFilters(args, tweening, container = false) {
      const commandFilters = [];
      const { time, quantize, commandFiles, clipTime, videoRate: videoRate2, duration } = args;
      const { id: id2 } = this;
      let filterInput = commandFilesInput(commandFiles, id2, true);
      assertPopulatedString(filterInput, "filterInput");
      const trimFilter = "trim";
      const trimId = idGenerate(trimFilter);
      const trimOptions = {};
      if (duration)
        trimOptions.duration = duration;
      const { frame } = this.definitionTime(time, clipTime);
      if (frame)
        trimOptions.start = timeFromArgs(frame, quantize).seconds;
      const commandFilter = {
        inputs: [filterInput],
        ffmpegFilter: trimFilter,
        options: trimOptions,
        outputs: [trimId]
      };
      commandFilters.push(commandFilter);
      filterInput = trimId;
      if (duration) {
        const fpsFilter = "fps";
        const fpsId = idGenerate(fpsFilter);
        const fpsCommandFilter = {
          ffmpegFilter: fpsFilter,
          options: { fps: videoRate2 },
          inputs: [filterInput],
          outputs: [fpsId]
        };
        commandFilters.push(fpsCommandFilter);
        filterInput = fpsId;
      }
      const setptsFilter = "setpts";
      const setptsId = idGenerate(setptsFilter);
      const setptsCommandFilter = {
        ffmpegFilter: setptsFilter,
        options: { expr: "PTS-STARTPTS" },
        inputs: [filterInput],
        outputs: [setptsId]
      };
      commandFilters.push(setptsCommandFilter);
      return commandFilters;
    }
    intrinsicsKnown(options2) {
      const superKnown = super.intrinsicsKnown(options2);
      if (!superKnown)
        return false;
      const { duration } = options2;
      if (!duration)
        return true;
      return isAboveZero(this.definition.duration);
    }
    mutable() {
      return this.definition.audio;
    }
    selectedProperty(property) {
      const { name } = property;
      switch (name) {
        case "gain":
          return this.mutable() && !this.muted;
      }
      return super.selectedProperty(property);
    }
    setValue(value, name, property) {
      super.setValue(value, name, property);
      if (property)
        return;
      switch (name) {
        case "startTrim":
        case "endTrim":
        case "speed":
          this.clip.resetTiming(this);
          break;
      }
    }
    startOptions(seconds, timeRange) {
      let offset2 = timeRange.withFrame(this.startTrim).seconds;
      let start = timeRange.seconds - seconds;
      let duration = timeRange.lengthSeconds;
      if (start < 0) {
        offset2 -= start;
        duration += start;
        start = 0;
      }
      return { start, offset: offset2, duration };
    }
    toJSON() {
      const json = super.toJSON();
      const { speed, gain } = this;
      if (speed !== 1)
        json.speed = speed;
      if (gain !== 1)
        json.gain = gain;
      return json;
    }
    get trimFilter() {
      return this._trimFilter || (this._trimFilter = filterFromId("trim"));
    }
  };
}
function UpdatableDurationDefinitionMixin(Base) {
  return class extends Base {
    constructor(...args) {
      super(...args);
      __publicField(this, "audio", false);
      __publicField(this, "audioUrl", "");
      __publicField(this, "duration", 0);
      __publicField(this, "loadedAudio");
      __publicField(this, "loop", false);
      __publicField(this, "waveform");
      const [object] = args;
      const { audioUrl, audio, loop, duration, waveform, loadedAudio } = object;
      if (audio || audioUrl || loadedAudio) {
        this.audio = true;
        if (isPopulatedString(audioUrl))
          this.audioUrl = audioUrl;
        if (waveform)
          this.waveform = waveform;
        if (loadedAudio)
          this.loadedAudio = loadedAudio;
      }
      if (isAboveZero(duration))
        this.duration = duration;
      if (loop) {
        this.loop = loop;
        this.properties.push(propertyInstance({ name: "loops", defaultValue: 1 }));
      }
      this.properties.push(propertyInstance({
        name: "gain",
        defaultValue: 1,
        type: DataType.Percent,
        min: 0,
        max: 2,
        step: 0.01
      }));
      this.properties.push(propertyInstance({
        name: "speed",
        defaultValue: 1,
        type: DataType.Percent,
        min: 0.1,
        max: 2,
        step: 0.1,
        group: DataGroup.Timing
      }));
      this.properties.push(propertyInstance({
        name: "startTrim",
        defaultValue: 0,
        type: DataType.Frame,
        step: 1,
        min: 0,
        group: DataGroup.Timing
      }));
      this.properties.push(propertyInstance({
        name: "endTrim",
        defaultValue: 0,
        type: DataType.Frame,
        step: 1,
        min: 0,
        group: DataGroup.Timing
      }));
    }
    audibleSource(preloader) {
      const { loadedAudio } = this;
      if (loadedAudio) {
        return AudibleContextInstance.createBufferSource(loadedAudio);
      }
      const { audioUrl } = this;
      if (!isPopulatedString(audioUrl)) {
        this.audio = false;
        return;
      }
      const protocolUrl = urlPrependProtocol("audio", audioUrl);
      const cache = preloader.getCache(protocolUrl);
      if (!cache) {
        return;
      }
      const { error, result } = cache;
      if (error || !isLoadedAudio(result)) {
        this.audio = false;
        this.audioUrl = "";
        return;
      }
      this.loadedAudio = result;
      return AudibleContextInstance.createBufferSource(result);
    }
    frames(quantize) {
      const { duration } = this;
      if (!duration)
        return Duration.Unknown;
      return timeFromSeconds(this.duration, quantize, "floor").frame;
    }
    toJSON() {
      const json = super.toJSON();
      const { duration, audio, loop, waveform, audioUrl, url } = this;
      if (duration)
        json.duration = duration;
      if (audio)
        json.audio = audio;
      if (loop)
        json.loop = loop;
      if (waveform)
        json.waveform = waveform;
      if (url)
        json.url = url;
      else if (audioUrl)
        json.audioUrl = audioUrl;
      return json;
    }
    urlAudible(editing = false) {
      if (editing) {
        return urlPrependProtocol("audio", this.audioUrl || this.url);
      }
      return this.source;
    }
  };
}
var AudioPreview = class {
  constructor(object) {
    __publicField(this, "buffer", Default.mash.buffer);
    __publicField(this, "bufferSource");
    __publicField(this, "gain", Default.mash.gain);
    __publicField(this, "playing", false);
    __publicField(this, "playingClips", []);
    __publicField(this, "preloader");
    // position of masher (in seconds) when startPlaying called
    __publicField(this, "startedMashAt", 0);
    // currentTime of context (in seconds) was created when startPlaying called
    __publicField(this, "contextSecondsWhenStarted", 0);
    const { buffer, gain, preloader } = object;
    if (isPositive(gain))
      this.gain = gain;
    if (isAboveZero(buffer))
      this.buffer = buffer;
    this.preloader = preloader;
  }
  adjustClipGain(clip, quantize) {
    const timeRange = clip.timeRange(quantize);
    const avs = this.clipSources(clip);
    avs.forEach((av) => {
      this.adjustSourceGain(av, timeRange);
    });
  }
  adjustSourceGain(av, timeRange) {
    const source2 = AudibleContextInstance.getSource(av.id);
    if (!source2) {
      return;
    }
    const { gainNode } = source2;
    if (this.gain === 0) {
      gainNode.gain.value = 0;
      return;
    }
    const gain = av.gain;
    if (isPositive(gain)) {
      gainNode.gain.value = this.gain * gain;
      return;
    }
    const options2 = isTimeRange(timeRange) ? av.startOptions(this.seconds, timeRange) : timeRange;
    const { start, duration } = options2;
    gainNode.gain.cancelScheduledValues(0);
    av.gainPairs.forEach((pair) => {
      const [position, value] = pair;
      gainNode.gain.linearRampToValueAtTime(this.gain * value, start + position * duration);
    });
  }
  bufferClips(clips, quantize) {
    if (!this.createSources(clips, quantize))
      return false;
    this.destroySources(clips);
    return true;
  }
  clear() {
  }
  clipSources(clip) {
    const avs = [];
    const { container, content } = clip;
    if (isUpdatableDuration(container) && !container.muted)
      avs.push(container);
    if (isUpdatableDuration(content) && !content.muted)
      avs.push(content);
    return avs;
  }
  createSources(clips, quantize, time) {
    if (!this.playing && !time)
      return false;
    const addingClips = clips.filter((clip) => !this.playingClips.includes(clip));
    if (!addingClips.length)
      return true;
    let okay = true;
    addingClips.forEach((clip) => {
      const avs = this.clipSources(clip);
      const timeRange = clip.timeRange(quantize);
      const filtered = avs.filter((av) => !AudibleContextInstance.hasSource(av.id));
      okay && (okay = filtered.every((av) => {
        const startSeconds = this.playing ? this.seconds : (time == null ? void 0 : time.seconds) || 0;
        const options2 = av.startOptions(startSeconds, timeRange);
        const { start, duration, offset: offset2 } = options2;
        if (isPositive(start) && isAboveZero(duration)) {
          const { definition, id: id2 } = av;
          assertUpdatableDurationDefinition(definition);
          const audibleSource = definition.audibleSource(this.preloader);
          if (!audibleSource) {
            if (!start) {
              return false;
            }
            return true;
          }
          const { loop } = definition;
          AudibleContextInstance.startAt(id2, audibleSource, start, duration, offset2, loop);
          this.adjustSourceGain(av, options2);
        } else
          console.error(this.constructor.name, "createSources", options2);
        return true;
      }));
    });
    this.playingClips.push(...addingClips);
    return okay;
  }
  destroySources(clipsToKeep = []) {
    const sourceClips = [...this.playingClips];
    const clipsToRemove = sourceClips.filter((clip) => !clipsToKeep.includes(clip));
    clipsToRemove.forEach((clip) => {
      const avs = this.clipSources(clip);
      avs.forEach((av) => AudibleContextInstance.deleteSource(av.id));
    });
    this.playingClips = clipsToKeep;
  }
  setGain(value, quantize) {
    if (this.gain === value)
      return;
    this.gain = value;
    if (this.playing) {
      this.playingClips.forEach((clip) => this.adjustClipGain(clip, quantize));
    }
  }
  get seconds() {
    const ellapsed = AudibleContextInstance.currentTime - this.contextSecondsWhenStarted;
    const started = ellapsed + this.startedMashAt;
    return started;
  }
  startContext() {
    if (this.bufferSource)
      throw Errors.internal + "bufferSource startContext";
    if (this.playing)
      throw Errors.internal + "playing";
    const buffer = AudibleContextInstance.createBuffer(this.buffer);
    this.bufferSource = AudibleContextInstance.createBufferSource(buffer);
    this.bufferSource.loop = true;
    this.bufferSource.connect(AudibleContextInstance.destination);
    this.bufferSource.start(0);
  }
  // called when playhead starts moving
  startPlaying(time, clips, quantize) {
    if (!this.bufferSource)
      throw Errors.internal + "bufferSource startPlaying";
    if (this.playing)
      throw Errors.internal + "playing";
    const { seconds } = time;
    this.playing = true;
    this.startedMashAt = seconds;
    this.contextSecondsWhenStarted = AudibleContextInstance.currentTime;
    if (!this.createSources(clips, quantize, time)) {
      this.stopPlaying();
      return false;
    }
    return true;
  }
  stopContext() {
    if (!this.bufferSource)
      return;
    this.bufferSource.stop();
    this.bufferSource.disconnect(AudibleContextInstance.destination);
    delete this.bufferSource;
  }
  stopPlaying() {
    if (!this.playing)
      return;
    this.playing = false;
    this.destroySources();
    this.startedMashAt = 0;
    this.contextSecondsWhenStarted = 0;
  }
};
var FilterGraphInputVisible = "BACKCOLOR";
var FilterGraphInputAudible = "SILENCE";
var FilterGraphClass = class {
  constructor(args) {
    __publicField(this, "_id");
    __publicField(this, "background");
    __publicField(this, "_clips");
    __publicField(this, "_commandFiles");
    __publicField(this, "mash");
    __publicField(this, "size");
    __publicField(this, "streaming", false);
    __publicField(this, "time");
    __publicField(this, "upload");
    __publicField(this, "visible", false);
    __publicField(this, "videoRate");
    const { upload, mash, background, size, time, streaming, videoRate: videoRate2, visible } = args;
    assertMash(mash);
    this.mash = mash;
    this.time = time;
    this.videoRate = videoRate2;
    this.background = background;
    this.upload = upload;
    this.size = size;
    if (visible)
      this.visible = true;
    if (streaming)
      this.streaming = true;
    assertTrue(isAboveZero(this.videoRate), "videoRate");
    assertTrue(this.time.fps === this.quantize, "time is in mash rate");
  }
  get id() {
    return this._id || (this._id = idGenerate("filtergraph"));
  }
  get avType() {
    return this.visible ? AVType.Video : AVType.Audio;
  }
  get commandFilterVisible() {
    const { duration, videoRate: rate, background, size } = this;
    const color2 = background || colorTransparent;
    const colorCommandFilter = {
      ffmpegFilter: "color",
      options: { color: color2, rate, size: `${size.width}x${size.height}` },
      inputs: [],
      outputs: [FilterGraphInputVisible]
    };
    if (duration)
      colorCommandFilter.options.duration = duration;
    return colorCommandFilter;
  }
  get commandFilterAudible() {
    const { duration } = this;
    const silenceCommandFilter = {
      ffmpegFilter: "aevalsrc",
      options: { exprs: 0, duration },
      inputs: [],
      outputs: [FilterGraphInputAudible]
    };
    if (duration)
      silenceCommandFilter.options.duration = duration;
    return silenceCommandFilter;
  }
  get clips() {
    return this._clips || (this._clips = this.clipsInitialize);
  }
  get clipsInitialize() {
    const { time, mash, avType } = this;
    return mash.clipsInTimeOfType(time, avType).sort(sortByTrack);
  }
  get commandInputs() {
    return this.inputCommandFiles.map((commandFile) => {
      const { options: options2 } = commandFile;
      const input = { source: this.preloader.key(commandFile), options: options2 };
      return input;
    });
  }
  get filterGraphCommandFiles() {
    return this._commandFiles || (this._commandFiles = this.commandFilesInitialize);
  }
  get commandFilesInitialize() {
    const { time, videoRate: videoRate2, quantize, size: outputSize, clips, visible, preloader } = this;
    const commandFiles = clips.flatMap((clip) => {
      const clipTime = clip.timeRange(quantize);
      const chainArgs = {
        time,
        quantize,
        visible,
        outputSize,
        videoRate: videoRate2,
        clipTime
      };
      return clip.clipCommandFiles(chainArgs);
    });
    commandFiles.forEach((commandFile) => {
      const { definition } = commandFile;
      assertDefinition(definition);
      const resolved = preloader.key(commandFile);
      commandFile.resolved = resolved;
    });
    return commandFiles;
  }
  get commandFilters() {
    const filters2 = [];
    const { time, quantize, size: outputSize, clips, visible, videoRate: videoRate2, filterGraphCommandFiles: commandFiles, upload } = this;
    const chainArgs = {
      videoRate: videoRate2,
      time,
      quantize,
      visible,
      outputSize,
      commandFiles,
      chainInput: "",
      clipTime: timeRangeFromTime(time),
      track: 0,
      upload
    };
    if (visible) {
      if (!upload) {
        filters2.push(this.commandFilterVisible);
        chainArgs.chainInput = FilterGraphInputVisible;
      }
    } else {
      filters2.push(this.commandFilterAudible);
      chainArgs.chainInput = FilterGraphInputAudible;
    }
    const { length: length2 } = clips;
    clips.forEach((clip, index) => {
      chainArgs.clipTime = clip.timeRange(quantize);
      chainArgs.track = index;
      filters2.push(...clip.commandFilters(chainArgs));
      const lastFilter = arrayLast(filters2);
      if (index < length2 - 1) {
        if (!lastFilter.outputs.length)
          lastFilter.outputs.push(idGenerate("clip"));
      }
      chainArgs.chainInput = arrayLast(lastFilter.outputs);
    });
    return filters2;
  }
  get duration() {
    return this.time.lengthSeconds;
  }
  get inputCommandFiles() {
    return this.filterGraphCommandFiles.filter((file) => file.input);
  }
  get preloader() {
    return this.mash.preloader;
  }
  get quantize() {
    return this.mash.quantize;
  }
};
var FilterGraphsClass = class {
  constructor(args) {
    __publicField(this, "args");
    __publicField(this, "filterGraphsVisible", []);
    __publicField(this, "filterGraphAudible");
    __publicField(this, "_graphFiles");
    __publicField(this, "time");
    this.args = args;
    const { avType, times, mash, ...rest } = args;
    const { length: length2 } = times;
    if (!length2) {
      this.time = timeFromArgs();
      return;
    }
    const [time] = times;
    const startFrames = [];
    const endFrames = [];
    const rates = [];
    times.forEach((time2) => {
      rates.push(time2.fps);
      startFrames.push(time2.frame);
      if (time2.isRange)
        endFrames.push(time2.timeRange.end);
    });
    if (endFrames.length) {
      const rate = Math.max(...rates);
      if (rate !== Math.min(...rates))
        throw Errors.internal + "timeranges fps";
      const startFrame = Math.min(...startFrames);
      const endFrame = Math.max(...endFrames);
      this.time = timeRangeFromArgs(startFrame, rate, endFrame);
    } else {
      assertTrue(length2 === 1, "just one time");
      this.time = time;
    }
    if (avType !== AVType.Video) {
      assertTrue(length2 === 1 || avType !== AVType.Audio, "single time for avtype audio");
      const filterGraphArgs = {
        ...rest,
        time: this.time,
        mash,
        visible: false
      };
      this.filterGraphAudible = new FilterGraphClass(filterGraphArgs);
    }
    if (avType !== AVType.Audio) {
      this.filterGraphsVisible.push(...times.map((time2) => {
        const filterGraphArgs = {
          ...rest,
          time: time2,
          mash,
          visible: true
        };
        const filterGraph = new FilterGraphClass(filterGraphArgs);
        return filterGraph;
      }));
    }
  }
  assureDuration() {
  }
  assureSize() {
  }
  get duration() {
    return this.time.lengthSeconds;
  }
  get filterGraphVisible() {
    return this.filterGraphsVisible[0];
  }
  get fileUrls() {
    const graphs = [...this.filterGraphsVisible];
    if (this.filterGraphAudible)
      graphs.push(this.filterGraphAudible);
    return this._graphFiles || (this._graphFiles = graphs.flatMap((graph) => graph.filterGraphCommandFiles));
  }
  get graphFilesInput() {
    return this.fileUrls.filter((graphFile) => graphFile.input);
  }
  get loadPromise() {
    return this.args.mash.preloader.loadFilesPromise(this.fileUrls);
  }
};
var TrackPreviewHandleSize = 8;
var TrackPreviewLineSize = 2;
var TrackPreviewClass = class {
  constructor(args) {
    __publicField(this, "args");
    __publicField(this, "_rect");
    __publicField(this, "_timeRange");
    this.args = args;
  }
  get clip() {
    return this.args.clip;
  }
  get container() {
    return this.clip.container;
  }
  get editor() {
    return this.preview.editor;
  }
  get icon() {
    return !!this.args.icon;
  }
  get id() {
    return this.clip.id;
  }
  pointerDown() {
    const clickPoint = { ...PointZero };
    const { editor, container, timeRange, rect, clip } = this;
    const { rect: contentRect } = editor;
    const removeWindowHandlers = () => {
      globalThis.window.removeEventListener("pointermove", pointerMoveStart);
      globalThis.window.removeEventListener("pointermove", pointerMove);
      globalThis.window.removeEventListener("pointerup", pointerUp);
      globalThis.window.removeEventListener("pointerup", pointerDown);
    };
    const pointerUp = (event) => {
      eventStop(event);
      removeWindowHandlers();
      editor.dragging = false;
      editor.redraw();
    };
    const pointerMove = (event) => {
      eventStop(event);
      const { offE, offN, offS, offW } = container;
      const { x, y, width: width2, height: height2 } = rect;
      let totalWidth = contentRect.width - width2;
      let totalHeight = contentRect.height - height2;
      let initialX = 0;
      let initialY = 0;
      if (offE) {
        initialX -= width2;
        totalWidth += width2;
      }
      if (offW)
        totalWidth += width2;
      if (offN) {
        initialY -= height2;
        totalHeight += height2;
      }
      if (offS)
        totalHeight += height2;
      const { clientX, clientY } = event;
      const localX = clientX - contentRect.x;
      const localY = clientY - contentRect.y;
      const clickX = clickPoint.x - contentRect.x;
      const clickY = clickPoint.y - contentRect.y;
      const xPos = localX - (clickX - x);
      const yPos = localY - (clickY - y);
      const limitedX = tweenMinMax(xPos, initialX, initialX + totalWidth);
      const limitedY = tweenMinMax(yPos, initialY, initialY + totalHeight);
      const pointsTweening = tweeningPoints(container);
      const { lastTime } = timeRange;
      const timesEqual = editor.time.equalsTime(lastTime);
      const tweening = pointsTweening && timesEqual;
      const xKey = tweening ? `x${PropertyTweenSuffix}` : "x";
      const yKey = tweening ? `y${PropertyTweenSuffix}` : "y";
      const undoValues = {
        [xKey]: container.value(xKey),
        [yKey]: container.value(yKey)
      };
      const redoValues = {
        [xKey]: totalWidth ? limitedX / totalWidth : undoValues[xKey],
        [yKey]: totalHeight ? limitedY / totalHeight : undoValues[yKey]
      };
      const args = {
        property: DataGroup.Point,
        target: container,
        type: ActionType.ChangeMultiple,
        redoValues,
        undoValues
      };
      editor.actions.create(args);
    };
    const pointerMoveStart = (event) => {
      eventStop(event);
      const { clientX: x, clientY: y } = event;
      const nowPoint = { x, y };
      if (pointsEqual(nowPoint, clickPoint))
        return;
      if (tweeningPoints(container)) {
        const { time } = editor;
        const closest = time.closest(timeRange);
        if (!time.equalsTime(closest)) {
          removeWindowHandlers();
          editor.goToTime(closest);
          return;
        }
      }
      editor.dragging = true;
      globalThis.window.removeEventListener("pointermove", pointerMoveStart);
      globalThis.window.addEventListener("pointermove", pointerMove);
      pointerMove(event);
    };
    const pointerDown = (event) => {
      eventStop(event);
      if (!(event instanceof PointerEvent))
        return;
      const { clientX: x, clientY: y } = event;
      clickPoint.x = x;
      clickPoint.y = y;
      globalThis.window.addEventListener("pointermove", pointerMoveStart);
      globalThis.window.addEventListener("pointerup", pointerUp);
      if (editor.selection.clip !== clip) {
        editor.selection.set(clip);
      }
    };
    return pointerDown;
  }
  get preview() {
    return this.args.preview;
  }
  get quantize() {
    return this.preview.quantize;
  }
  get rect() {
    return this._rect || this.rectInitialize;
  }
  get rectInitialize() {
    const { time, timeRange, clip, size } = this;
    assertSizeAboveZero(size, `${this.constructor.name}.rectInitialize size`);
    const containerRectArgs = {
      size,
      time,
      timeRange,
      editing: true
    };
    const containerRects = clip.rects(containerRectArgs);
    assertTrue(rectsEqual(...containerRects));
    return containerRects[0];
  }
  get size() {
    return this.preview.size;
  }
  editingSvgItem(classes, inactive) {
    const { container, rect } = this;
    const svgItem = container.pathElement(rect);
    svgItem.setAttribute("vector-effect", "non-scaling-stroke");
    svgAddClass(svgItem, classes);
    if (!inactive)
      svgItem.addEventListener("pointerdown", this.pointerDown());
    return svgItem;
  }
  svgBoundsElement(lineClasses, handleClasses, inactive) {
    const items = [];
    const handle = TrackPreviewHandleSize;
    const line = TrackPreviewLineSize;
    const halfLine = line / 2;
    const { rect, container } = this;
    const { directions } = container;
    const { width: width2, height: height2, x, y } = rect;
    const lineRect = { x: x - halfLine, y: y - halfLine, width: width2, height: line };
    items.push(svgPolygonElement(lineRect, lineClasses));
    lineRect.y = y + height2 - halfLine;
    items.push(svgPolygonElement(lineRect, lineClasses));
    lineRect.x = x + width2 - halfLine;
    lineRect.height = height2;
    lineRect.width = line;
    lineRect.y = y;
    items.push(svgPolygonElement(lineRect, lineClasses));
    lineRect.x = x - halfLine;
    items.push(svgPolygonElement(lineRect, lineClasses));
    const size = { width: width2, height: height2 };
    directions.forEach((direction) => {
      const point = this.svgHandlePoint(size, direction);
      const rect2 = { x: x + point.x, y: y + point.y, width: handle, height: handle };
      const element = svgPolygonElement(rect2, [...handleClasses, direction.toLowerCase()]);
      items.push(element);
      if (inactive)
        return;
      element.addEventListener("pointerdown", (event) => {
        this.editor.selection.set(this.clip);
        eventStop(event);
      });
    });
    return items;
  }
  svgHandlePoint(dimensions, direction) {
    const handle = TrackPreviewHandleSize;
    const halfHandle = handle / 2;
    const { width: width2, height: height2 } = dimensions;
    const point = { ...PointZero };
    const [first, second] = String(direction).split("");
    assertDirection(first, direction);
    const last = second || first;
    assertDirection(last);
    switch (last) {
      case Direction.W:
        point.x = -halfHandle;
        break;
      case Direction.E:
        point.x = width2 - halfHandle;
        break;
      default:
        point.x = Math.round(width2 / 2) - halfHandle;
    }
    switch (first) {
      case Direction.N:
        point.y = -halfHandle;
        break;
      case Direction.S:
        point.y = height2 - halfHandle;
        break;
      default:
        point.y = Math.round(height2 / 2) - halfHandle;
    }
    return point;
  }
  get time() {
    return this.preview.time;
  }
  get timeRange() {
    return this._timeRange || (this._timeRange = this.clip.timeRange(this.quantize));
  }
};
var PreviewClass = class {
  constructor(args) {
    __publicField(this, "audible", false);
    __publicField(this, "background");
    __publicField(this, "_clips");
    __publicField(this, "combine", false);
    __publicField(this, "editor");
    __publicField(this, "mash");
    __publicField(this, "onlyClip");
    __publicField(this, "size");
    __publicField(this, "selectedClip");
    __publicField(this, "streaming", false);
    __publicField(this, "_svgItems");
    __publicField(this, "time");
    __publicField(this, "_trackPreviews");
    __publicField(this, "visible", true);
    const { selectedClip, editor, time, mash, background, onlyClip, size } = args;
    this.mash = mash;
    this.size = size || mash.imageSize;
    this.time = time;
    this.background = background;
    this.selectedClip = selectedClip;
    this.onlyClip = onlyClip;
    if (isObject(editor))
      this.editor = editor;
  }
  get clips() {
    return this._clips || (this._clips = this.clipsInitialize);
  }
  get clipsInitialize() {
    const { mash, time, onlyClip } = this;
    if (onlyClip)
      return [onlyClip];
    return mash.clipsInTimeOfType(time, AVType.Video).sort(sortByTrack);
  }
  get duration() {
    return this.time.lengthSeconds;
  }
  get editing() {
    return isObject(this.editor);
  }
  get intrinsicSizePromise() {
    const { clips, preloader } = this;
    const options2 = { editing: true, size: true };
    const unknownClips = clips.filter((clip) => !clip.intrinsicsKnown(options2));
    const files = unknownClips.flatMap((clip) => clip.intrinsicGraphFiles(options2));
    return preloader.loadFilesPromise(files);
  }
  get itemsPromise() {
    const { clips, size, time, onlyClip } = this;
    let promise = Promise.resolve([]);
    const icon = !!onlyClip;
    clips.forEach((clip) => {
      promise = promise.then((lastTuple) => {
        return clip.previewItemsPromise(size, time, icon).then((svgItems) => {
          return [...lastTuple, ...svgItems];
        });
      });
    });
    return promise;
  }
  get preloader() {
    return this.mash.preloader;
  }
  get quantize() {
    return this.mash.quantize;
  }
  get trackPreviews() {
    return this._trackPreviews || (this._trackPreviews = this.trackPreviewsInitialize);
  }
  get trackPreviewsInitialize() {
    const trackPreviews = [];
    const { time, quantize, clips } = this;
    const tweenTime = time.isRange ? void 0 : time.scale(quantize);
    clips.forEach((clip) => {
      const clipTimeRange = clip.timeRange(quantize);
      const range = clipTimeRange.scale(time.fps);
      const frame = Math.max(0, time.frame - range.frame);
      const timeRange = range.withFrame(frame);
      const filterChainArgs = {
        clip,
        preview: this,
        tweenTime,
        timeRange,
        icon: !!this.onlyClip
      };
      trackPreviews.push(new TrackPreviewClass(filterChainArgs));
    });
    return trackPreviews;
  }
  get svgItemsPromise() {
    return this.previewItemsPromise;
  }
  get previewItemsPromise() {
    if (this._svgItems)
      return Promise.resolve(this._svgItems);
    const sizePromise = this.intrinsicSizePromise;
    const itemsPromise = sizePromise.then(() => this.itemsPromise);
    return itemsPromise.then((svgItems) => {
      return this._svgItems = this.tupleItems(svgItems);
    });
  }
  tupleItems(svgItems) {
    const { size, editing, background, selectedClip, editor } = this;
    const previewItems = [...svgItems];
    const trackClasses = "track";
    previewItems.forEach((item) => svgAddClass(item, trackClasses));
    const backgroundClasses = "background";
    if (background) {
      const backgroundPolygon = svgPolygonElement(size, backgroundClasses, background);
      const backgroundSvg = svgElement(size, backgroundPolygon);
      previewItems.unshift(backgroundSvg);
    }
    if (!(editing && svgItems.length))
      return previewItems;
    assertObject(editor);
    const { dragging } = editor;
    const { trackPreviews } = this;
    const selectedPreview = trackPreviews.find((preview) => preview.clip === selectedClip);
    const hoverItems = trackPreviews.map((trackPreview) => {
      const trackSelected = trackPreview === selectedPreview;
      const classes2 = ["outline"];
      if (!(dragging || trackSelected))
        classes2.push("animate");
      return trackPreview.editingSvgItem(classes2);
    });
    const outlineClasses = ["outlines"];
    const hoversSvg = svgElement(size, hoverItems);
    svgAddClass(hoversSvg, outlineClasses);
    previewItems.push(hoversSvg);
    if (!selectedPreview)
      return previewItems;
    const classes = ["bounds", "back"];
    const lineClasses = ["line"];
    const handleClasses = ["handle"];
    const activeSvg = svgElement(size, selectedPreview.svgBoundsElement(lineClasses, handleClasses, true));
    svgAddClass(activeSvg, classes);
    classes[1] = "fore";
    const passiveSvg = svgElement(size, selectedPreview.svgBoundsElement(lineClasses, handleClasses));
    svgAddClass(passiveSvg, classes);
    previewItems.push(activeSvg, passiveSvg);
    return previewItems;
  }
};
var ClipClass = class extends InstanceBase {
  constructor(...args) {
    super(...args);
    __publicField(this, "_container");
    __publicField(this, "_content");
    __publicField(this, "selectType", SelectType.Clip);
    __publicField(this, "_track");
    const [object] = args;
    const { container, content } = object;
    this.containerInitialize(container || {});
    this.contentInitialize(content || {});
  }
  assureTimingAndSizing(timing, sizing, tweenable) {
    const { timing: myTiming, sizing: mySizing, containerId: containerId2 } = this;
    let timingOk = myTiming !== timing;
    let sizingOk = mySizing !== sizing;
    timingOk || (timingOk = tweenable.hasIntrinsicTiming);
    sizingOk || (sizingOk = tweenable.hasIntrinsicSizing);
    if (!timingOk) {
      if (timing === Timing.Content && containerId2) {
        this.timing = Timing.Container;
      } else
        this.timing = Timing.Custom;
    }
    if (!sizingOk) {
      if (sizing === Sizing.Content && containerId2) {
        this.sizing = Sizing.Container;
      } else
        this.sizing = Sizing.Preview;
    }
    return !(sizingOk && timingOk);
  }
  get audible() {
    return this.mutable;
  }
  clipFileUrls(args) {
    const files = [];
    const { quantize } = args;
    const { content, container, frames } = this;
    if (isAboveZero(frames))
      args.clipTime || (args.clipTime = this.timeRange(quantize));
    if (container)
      files.push(...container.fileUrls(args));
    files.push(...content.fileUrls(args));
    return files;
  }
  clipIcon(size, scale, buffer = 1) {
    const { container } = this;
    if (!container)
      return;
    const { track } = this;
    const { quantize, imageSize } = track.mash;
    assertSizeAboveZero(imageSize, "track.mash.imageSize");
    const frameSize = sizeEven(sizeCover(imageSize, size, true));
    assertSizeAboveZero(frameSize, `${this.constructor.name}.clipIcon containedSize`);
    const widthAndBuffer = frameSize.width + buffer;
    const cellCount = Math.ceil(size.width / widthAndBuffer);
    const clipTime = this.timeRange(quantize);
    const { startTime } = clipTime;
    const previews = [];
    const { mash } = track;
    let pixel = 0;
    for (let i = 0; i < cellCount; i++) {
      const { copy: time } = startTime;
      const previewArgs = {
        mash,
        time,
        onlyClip: this,
        size: frameSize
      };
      const preview = new PreviewClass(previewArgs);
      previews.push(preview);
      pixel += widthAndBuffer;
      startTime.frame = clipTime.frame + pixelToFrame(pixel, scale, "floor");
    }
    let svgItemPromise = Promise.resolve([]);
    previews.forEach((preview) => {
      svgItemPromise = svgItemPromise.then((items) => {
        return preview.svgItemsPromise.then((svgItems) => {
          return [...items, ...svgItems];
        });
      });
    });
    return svgItemPromise.then((svgItems) => {
      const point = { ...PointZero };
      const containerSvg = svgElement(size);
      svgItems.forEach((groupItem) => {
        svgSetDimensions(groupItem, point);
        svgAppend(containerSvg, groupItem);
        point.x += widthAndBuffer;
      });
      return containerSvg;
    });
  }
  clipCommandFiles(args) {
    const commandFiles = [];
    const { visible, quantize, outputSize, time } = args;
    const clipTime = this.timeRange(quantize);
    const { content, container } = this;
    const contentArgs = { ...args, clipTime };
    if (visible) {
      assertSizeAboveZero(outputSize, "outputSize");
      assertContainer(container);
      const containerRectArgs = {
        size: outputSize,
        time,
        timeRange: clipTime,
        loading: true
      };
      const containerRects = this.rects(containerRectArgs);
      const colors = isColorContent(content) ? content.contentColors(time, clipTime) : void 0;
      const fileArgs = {
        ...contentArgs,
        outputSize,
        contentColors: colors,
        containerRects
      };
      if (!colors) {
        const contentFiles = content.visibleCommandFiles(fileArgs);
        commandFiles.push(...contentFiles);
      }
      const containerFiles = container.visibleCommandFiles(fileArgs);
      commandFiles.push(...containerFiles);
    } else {
      assertTrue(!visible, "outputSize && container");
      commandFiles.push(...this.content.audibleCommandFiles(contentArgs));
    }
    return commandFiles;
  }
  commandFilters(args) {
    const commandFilters = [];
    const { visible, quantize, outputSize, time } = args;
    const clipTime = this.timeRange(quantize);
    const contentArgs = { ...args, clipTime };
    const { content, container } = this;
    if (!visible)
      return this.content.audibleCommandFilters(contentArgs);
    assertSizeAboveZero(outputSize, "outputSize");
    assertContainer(container);
    const containerRectArgs = {
      size: outputSize,
      time,
      timeRange: clipTime
    };
    const containerRects = this.rects(containerRectArgs);
    contentArgs.containerRects = containerRects;
    const tweening = {
      point: !pointsEqual(...containerRects),
      size: !sizesEqual(...containerRects)
    };
    const isColor = isColorContent(content);
    const colors = isColor ? content.contentColors(time, clipTime) : void 0;
    const hasColorContent = isPopulatedArray(colors);
    if (hasColorContent) {
      tweening.color = colors[0] !== colors[1];
      tweening.canColor = tweening.color ? container.canColorTween(args) : container.canColor(args);
    }
    const timeDuration = time.isRange ? time.lengthSeconds : 0;
    const duration = timeDuration ? Math.min(timeDuration, clipTime.lengthSeconds) : 0;
    const containerArgs = {
      ...contentArgs,
      contentColors: colors,
      outputSize,
      containerRects,
      duration
    };
    if (hasColorContent) {
      if (!tweening.canColor) {
        commandFilters.push(...container.containerColorCommandFilters(containerArgs));
        containerArgs.filterInput = arrayLast(arrayLast(commandFilters).outputs);
      }
    } else {
      commandFilters.push(...content.commandFilters(containerArgs, tweening));
      containerArgs.filterInput = arrayLast(arrayLast(commandFilters).outputs);
    }
    commandFilters.push(...container.commandFilters(containerArgs, tweening, true));
    return commandFilters;
  }
  get container() {
    return this._container || this.containerInitialize();
  }
  containerInitialize(containerObject = {}) {
    const { containerId: containerId2 } = this;
    const definitionId = containerId2 || containerObject.definitionId;
    if (!isPopulatedString(definitionId))
      return;
    const definition = Defined.fromId(definitionId);
    const object = { ...containerObject, definitionId, container: true };
    const instance = definition.instanceFromObject(object);
    assertContainer(instance);
    this.assureTimingAndSizing(Timing.Container, Sizing.Container, instance);
    instance.clip = this;
    if (this.timing === Timing.Container && this._track)
      this.resetTiming(instance);
    return this._container = instance;
  }
  get content() {
    return this._content || this.contentInitialize();
  }
  contentInitialize(contentObject = {}) {
    const { contentId: contentId2 } = this;
    const definitionId = contentId2 || contentObject.definitionId;
    assertPopulatedString(definitionId);
    const definition = Defined.fromId(definitionId);
    const object = { ...contentObject, definitionId };
    const instance = definition.instanceFromObject(object);
    assertContent(instance);
    if (this.assureTimingAndSizing(Timing.Content, Sizing.Content, instance)) {
      const { container } = this;
      if (container) {
        this.assureTimingAndSizing(Timing.Container, Sizing.Container, container);
      }
    }
    instance.clip = this;
    if (this.timing === Timing.Content && this._track)
      this.resetTiming(instance);
    return this._content = instance;
  }
  copy() {
    const object = { ...this.toJSON(), id: "" };
    return this.definition.instanceFromObject(object);
  }
  definitionIds() {
    const ids = [
      ...super.definitionIds(),
      ...this.content.definitionIds()
    ];
    if (this.container)
      ids.push(...this.container.definitionIds());
    return ids;
  }
  get endFrame() {
    return this.frame + this.frames;
  }
  endTime(quantize) {
    return timeFromArgs(this.endFrame, quantize);
  }
  intrinsicsKnown(options2) {
    const { content, container } = this;
    let known = content.intrinsicsKnown(options2);
    if (container)
      known && (known = container.intrinsicsKnown(options2));
    return known;
  }
  intrinsicGraphFiles(options2) {
    const { content, container } = this;
    const files = [];
    if (!content.intrinsicsKnown(options2)) {
      files.push(content.intrinsicGraphFile(options2));
    }
    if (container && !container.intrinsicsKnown(options2)) {
      files.push(container.intrinsicGraphFile(options2));
    }
    return files;
  }
  maxFrames(_quantize, _trim) {
    return 0;
  }
  get mutable() {
    const { content } = this;
    const contentMutable = content.mutable();
    if (contentMutable) {
      return true;
    }
    const { container } = this;
    if (!container)
      return false;
    const containerMutable = container.mutable();
    return containerMutable;
  }
  get notMuted() {
    const { content, muted } = this;
    if (muted)
      return false;
    if (content.mutable() && !content.muted)
      return true;
    const { container } = this;
    if (!(container == null ? void 0 : container.mutable()))
      return true;
    return !container.muted;
  }
  previewItemsPromise(size, time, icon) {
    assertSizeAboveZero(size, "previewItemsPromise");
    const timeRange = this.timeRange(this.track.mash.quantize);
    const svgTime = time || timeRange.startTime;
    const { container, content } = this;
    assertContainer(container);
    const containerRectArgs = {
      size,
      time: svgTime,
      timeRange,
      editing: true
    };
    const containerRects = this.rects(containerRectArgs);
    assertTrue(rectsEqual(...containerRects));
    const [containerRect] = containerRects;
    return container.containedContent(content, containerRect, size, svgTime, timeRange, icon);
  }
  rectIntrinsic(size, loading, editing) {
    const rect = { ...size, ...PointZero };
    const { sizing } = this;
    if (sizing === Sizing.Preview)
      return rect;
    const target = sizing === Sizing.Container ? this.container : this.content;
    assertTweenable(target);
    const known = target.intrinsicsKnown({ editing, size: true });
    if (loading && !known)
      return rect;
    assertTrue(known, "intrinsicsKnown");
    const targetRect = target.intrinsicRect(editing);
    return targetRect;
  }
  rects(args) {
    const { size, loading, editing } = args;
    const intrinsicRect = this.rectIntrinsic(size, loading, editing);
    const { container } = this;
    assertContainer(container);
    return container.containerRects(args, intrinsicRect);
  }
  resetTiming(tweenable, quantize) {
    const { timing } = this;
    const track = this._track;
    switch (timing) {
      case Timing.Custom: {
        if (isAboveZero(this.frames))
          break;
        this.frames = Default.duration * (quantize || track.mash.quantize);
        break;
      }
      case Timing.Container: {
        const container = isContainer(tweenable) ? tweenable : this.container;
        if (!container)
          break;
        this.frames = container.frames(quantize || track.mash.quantize);
        break;
      }
      case Timing.Content: {
        const content = isContent(tweenable) ? tweenable : this.content;
        if (!content)
          break;
        this.frames = content.frames(quantize || track.mash.quantize);
        break;
      }
    }
  }
  selectables() {
    return [this, ...this.track.selectables()];
  }
  selectedItems(actions) {
    const selected = [];
    const { properties: properties2 } = this;
    const props = properties2.filter((property) => this.selectedProperty(property));
    props.forEach((property) => {
      const { name } = property;
      const isFrames = name === "frames" || name === "frame";
      const undoValue = this.value(name);
      const target = this;
      selected.push({
        value: undoValue,
        selectType: SelectType.Clip,
        property,
        changeHandler: (property2, redoValue) => {
          assertPopulatedString(property2);
          const options2 = {
            property: property2,
            target,
            redoValue,
            undoValue,
            type: isFrames ? ActionType.ChangeFrame : ActionType.Change
          };
          actions.create(options2);
        }
      });
    });
    return selected;
  }
  selectedProperty(property) {
    var _a;
    const { name, type: type2 } = property;
    switch (type2) {
      case DataType.ContainerId:
      case DataType.ContentId:
        return false;
    }
    switch (name) {
      case "sizing":
        return !isAudio(this.content);
      case "timing": {
        if (this.content.hasIntrinsicTiming)
          break;
        return !!((_a = this.container) == null ? void 0 : _a.hasIntrinsicSizing);
      }
      case "frame":
        return !this.track.dense;
      case "frames":
        return this.timing === Timing.Custom;
    }
    return true;
  }
  setValue(value, name, property) {
    super.setValue(value, name, property);
    switch (name) {
      case "containerId": {
        if (this._container)
          this.containerInitialize(this._container.toJSON());
        break;
      }
      case "contentId": {
        if (this._content)
          this.contentInitialize(this._content.toJSON());
        break;
      }
    }
  }
  // private _svgElement?: SVGSVGElement
  // private get svgElement() { 
  //   return this._svgElement ||= svgElement() 
  // }
  // private updateSvg(rect: Rect) {
  //   svgSetDimensions(this.svgElement, rect)
  // }
  time(quantize) {
    return timeFromArgs(this.frame, quantize);
  }
  timeRange(quantize) {
    const { frame, frames } = this;
    assertPositive(frame, "timeRange frame");
    assertAboveZero(frames, "timeRange frames");
    return timeRangeFromArgs(this.frame, quantize, this.frames);
  }
  timeRangeRelative(timeRange, quantize) {
    const range = this.timeRange(quantize).scale(timeRange.fps);
    const frame = Math.max(0, timeRange.frame - range.frame);
    return timeRange.withFrame(frame);
  }
  toJSON() {
    const json = super.toJSON();
    const { container, content } = this;
    json.content = content;
    json.contentId = content.definitionId;
    if (container) {
      json.container = container;
      json.containerId = container.definitionId;
    } else
      json.containerId = "";
    return json;
  }
  toString() {
    return `[Clip ${this.label}]`;
  }
  get track() {
    return this._track;
  }
  set track(value) {
    this._track = value;
  }
  get trackNumber() {
    const { track } = this;
    return track ? track.index : -1;
  }
  set trackNumber(value) {
    if (value < 0)
      delete this._track;
  }
  get visible() {
    return !!this.containerId;
  }
};
var ClipDefinitionClass = class extends DefinitionBase {
  constructor(...args) {
    super(...args);
    __publicField(this, "audible", false);
    __publicField(this, "streamable", false);
    __publicField(this, "type", DefinitionType.Clip);
    __publicField(this, "visible", false);
    this.properties.push(propertyInstance({
      name: "containerId",
      type: DataType.ContainerId,
      defaultValue: DefaultContainerId
    }));
    this.properties.push(propertyInstance({
      name: "contentId",
      type: DataType.ContentId,
      defaultValue: DefaultContentId
    }));
    this.properties.push(propertyInstance({
      name: "label",
      type: DataType.String
    }));
    this.properties.push(propertyInstance({
      name: "sizing",
      type: DataType.Sizing,
      defaultValue: Sizing.Content
      // group: DataGroup.Sizing,
    }));
    this.properties.push(propertyInstance({
      name: "timing",
      type: DataType.Timing,
      defaultValue: Timing.Content,
      group: DataGroup.Timing
    }));
    this.properties.push(propertyInstance({
      name: "frame",
      type: DataType.Frame,
      group: DataGroup.Timing,
      defaultValue: Duration.None,
      min: 0,
      step: 1
    }));
    this.properties.push(propertyInstance({
      name: "frames",
      type: DataType.Frame,
      defaultValue: Duration.Unknown,
      min: 1,
      step: 1,
      group: DataGroup.Timing
    }));
  }
  instanceArgs(object = {}) {
    const args = super.instanceArgs(object);
    const { containerId: containerId2, contentId: contentId2 } = args;
    const defaultContent2 = isUndefined(contentId2) || contentId2 === DefaultContentId;
    let defaultContainer2 = isUndefined(containerId2) || containerId2 === DefaultContainerId;
    if (args.sizing === Sizing.Content && defaultContent2) {
      args.sizing = Sizing.Container;
    }
    if (args.sizing === Sizing.Container && defaultContainer2) {
      args.sizing = Sizing.Preview;
    }
    if (args.timing === Timing.Content && defaultContent2) {
      args.timing = Timing.Container;
    }
    if (args.timing === Timing.Container && defaultContainer2) {
      args.timing = Timing.Custom;
    }
    return args;
  }
  instanceFromObject(object = {}) {
    return new ClipClass(this.instanceArgs(object));
  }
};
var label = "Visible";
var type = "visible";
var id = "com.moviemasher.clip.default";
var containerId = "com.moviemasher.container.default";
var contentId = "com.moviemasher.content.default";
var clipDefaultJson = {
  label,
  type,
  id,
  containerId,
  contentId
};
var clipDefault = new ClipDefinitionClass(clipDefaultJson);
var clipDefaultId = clipDefault.id;
var clipDefaults = [clipDefault];
var clipDefinition = (object) => {
  const { id: id2 } = object;
  assertPopulatedString(id2);
  return new ClipDefinitionClass({ ...object, type: DefinitionType.Clip });
};
var clipDefinitionFromId = (id2) => {
  const definition = clipDefaults.find((definition2) => definition2.id === id2);
  if (definition)
    return definition;
  return clipDefinition({ id: id2 });
};
var clipInstance = (object = {}) => {
  const { definitionId = clipDefaultId } = object;
  if (!definitionId)
    throw Errors.id;
  const definition = clipDefinitionFromId(definitionId);
  const instance = definition.instanceFromObject(object);
  return instance;
};
var clipFromId = (id2) => {
  const definition = clipDefinitionFromId(id2);
  const instance = definition.instanceFromObject({ definitionId: id2 });
  return instance;
};
Factories[DefinitionType.Clip] = {
  definition: clipDefinition,
  definitionFromId: clipDefinitionFromId,
  fromId: clipFromId,
  instance: clipInstance,
  defaults: clipDefaults
};
var TrackClass = class extends PropertiedClass {
  constructor(args) {
    super();
    __publicField(this, "clips", []);
    __publicField(this, "dense", false);
    __publicField(this, "_identifier");
    __publicField(this, "index", 0);
    __publicField(this, "_mash");
    __publicField(this, "selectType", SelectType.Track);
    const { clips, index: layer, dense } = args;
    if (isPositive(layer))
      this.index = layer;
    this.dense = isDefined(dense) ? !!dense : !this.index;
    this.properties.push(propertyInstance({ name: "dense", defaultValue: false }));
    this.propertiesInitialize(args);
    if (clips) {
      this.clips.push(...clips.map((clip) => {
        const instance = clipInstance(clip);
        instance.track = this;
        return instance;
      }));
    }
  }
  addClips(clips, insertIndex = 0) {
    let clipIndex = insertIndex || 0;
    if (!this.dense)
      clipIndex = 0;
    const origIndex = clipIndex;
    const spliceClips = this.clips.filter((other, index) => {
      const moving = clips.includes(other);
      if (origIndex && moving && index < origIndex)
        clipIndex -= 1;
      return !moving;
    });
    spliceClips.splice(clipIndex, 0, ...clips);
    this.sortClips(spliceClips);
    arraySet(this.clips, spliceClips);
  }
  assureFrame(clips) {
    const clipsArray = clips || this.clips;
    let changed = false;
    let endFrame = 0;
    const ranges = [];
    const { dense } = this;
    clipsArray.forEach((clip) => {
      const { frame } = clip;
      if (dense ? frame !== endFrame : ranges.some((range) => range.includes(frame))) {
        changed = true;
        clip.frame = endFrame;
      }
      endFrame = clip.frame + clip.frames;
      if (!dense)
        ranges.push(clip.timeRange(1));
    });
    return changed;
  }
  assureFrames(quantize, clips) {
    const suppliedClips = isDefined(clips);
    const clipsArray = clips || this.clips;
    clipsArray.forEach((clip) => {
      const { frames } = clip;
      if (isAboveZero(frames))
        return;
      clip.resetTiming(void 0, quantize);
      if (isAboveZero(clip.frames) || !suppliedClips)
        return;
      clip.frames = Math.floor(Default.duration * quantize);
    });
  }
  frameForClipNearFrame(clip, frame = 0) {
    if (this.dense)
      return frame;
    const others = this.clips.filter((other) => clip !== other && other.endFrame > frame);
    if (!others.length)
      return frame;
    const startFrame = clip.frame;
    const endFrame = clip.endFrame;
    const frames = endFrame - startFrame;
    let lastFrame = frame;
    others.find((clip2) => {
      if (clip2.frame >= lastFrame + frames)
        return true;
      lastFrame = clip2.endFrame;
    });
    return lastFrame;
  }
  get frames() {
    const { clips } = this;
    const { length: length2 } = clips;
    if (!length2)
      return Duration.None;
    for (const clip2 of clips) {
      const { frames: clipFrames } = clip2;
      switch (clipFrames) {
        case Duration.Unknown:
        case Duration.Unlimited:
          return clipFrames;
      }
    }
    const clip = arrayLast(clips);
    const { frame, frames } = clip;
    return frame + frames;
  }
  get identifier() {
    return this._identifier || (this._identifier = idGenerate("track"));
  }
  get mash() {
    const { _mash } = this;
    assertMash(_mash);
    return _mash;
  }
  set mash(value) {
    this._mash = value;
  }
  removeClips(clips) {
    const newClips = this.clips.filter((other) => !clips.includes(other));
    assertTrue(newClips.length !== this.clips.length);
    clips.forEach((clip) => clip.trackNumber = -1);
    this.sortClips(newClips);
    arraySet(this.clips, newClips);
  }
  selectables() {
    return [this, ...this.mash.selectables()];
  }
  selectedItems(actions) {
    return this.properties.map((property) => {
      const undoValue = this.value(property.name);
      const target = this;
      return {
        value: undoValue,
        property,
        selectType: SelectType.Track,
        changeHandler: (property2, redoValue) => {
          assertPopulatedString(property2);
          const options2 = { target, property: property2, redoValue, undoValue };
          actions.create(options2);
        }
      };
    });
  }
  sortClips(clips) {
    const sortClips = clips || this.clips;
    const changed = this.assureFrame(sortClips);
    sortClips.sort(sortByFrame);
    return changed;
  }
  toJSON() {
    const json = super.toJSON();
    json.clips = this.clips;
    return json;
  }
};
var trackInstance = (object) => new TrackClass(object);
var TrackFactory = { instance: trackInstance };
var NonePreview = class extends PreviewClass {
  get clips() {
    return [];
  }
};
var MashClass = class extends EditedClass {
  constructor(args) {
    super(args);
    __publicField(this, "_buffer", Default.mash.buffer);
    __publicField(this, "_bufferTimer");
    __publicField(this, "_composition");
    __publicField(this, "drawInterval");
    __publicField(this, "drawingTime");
    __publicField(this, "drawnSeconds", 0);
    __publicField(this, "drawnTime");
    __publicField(this, "_frame", 0);
    __publicField(this, "_gain", Default.mash.gain);
    __publicField(this, "_layer");
    __publicField(this, "loadingPromises", []);
    __publicField(this, "loop", false);
    __publicField(this, "_paused", true);
    __publicField(this, "_playing", false);
    __publicField(this, "_preview");
    __publicField(this, "_rendering", "");
    __publicField(this, "seekTime");
    __publicField(this, "selectType", SelectType.Mash);
    __publicField(this, "tracks", []);
    const { createdAt, icon, id: id2, label: label2, frame, preloader, rendering, tracks, ...rest } = args;
    this.dataPopulate(rest);
    if (isPopulatedString(rendering))
      this._rendering = rendering;
    if (isPopulatedString(createdAt))
      this.createdAt = createdAt;
    if (isAboveZero(frame))
      this._frame = frame;
    if (isPopulatedArray(tracks))
      tracks.forEach((trackObject, index) => {
        const trackArgs = {
          dense: !index,
          ...trackObject,
          index
        };
        const track = trackInstance(trackArgs);
        track.mash = this;
        track.assureFrames(this.quantize);
        track.sortClips();
        this.tracks.push(track);
      });
    this.assureTrack();
    this.tracks.sort(sortByIndex);
    this._preview = new NonePreview({ mash: this, time: timeFromArgs() });
    this.label || (this.label = Default.mash.label);
  }
  addClipToTrack(clip, trackIndex = 0, insertIndex = 0, frame) {
    const clipsArray = isArray(clip) ? clip : [clip];
    const trackClips = this.trackClips(clipsArray, trackIndex);
    this.emitIfFramesChange(() => {
      trackClips.forEach((entry) => {
        const [index, clips] = entry;
        const newTrack = this.tracks[index];
        assertTrack(newTrack, "track");
        clips.forEach((clip2) => {
          const oldTrackNumber = clip2.trackNumber;
          if (isPositive(oldTrackNumber) && oldTrackNumber !== index) {
            clip2.track.removeClips([clip2]);
          }
          if (isPositive(frame))
            clip2.frame = frame;
          clip2.track = newTrack;
        });
        newTrack.assureFrames(this.quantize, clips);
        newTrack.addClips(clips, insertIndex);
      });
    });
  }
  addTrack(options2 = {}) {
    var _a;
    if (!isPositive(options2.index))
      options2.index = this.tracks.length;
    const track = trackInstance(options2);
    track.mash = this;
    this.tracks.push(track);
    this.tracks.sort(sortByIndex);
    (_a = this.emitter) == null ? void 0 : _a.emit(EventType.Track);
    return track;
  }
  assureTrack() {
    if (!this.tracks.length) {
      const trackArgs = { dense: true };
      const track = trackInstance(trackArgs);
      track.mash = this;
      this.tracks.push(track);
    }
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(value) {
    if (!isAboveZero(value))
      throw Errors.invalid.argument + "buffer " + value;
    if (this._buffer !== value) {
      this._buffer = value;
      if (this._composition)
        this.composition.buffer = value;
    }
  }
  bufferStart() {
    if (this._bufferTimer)
      return;
    this._bufferTimer = setInterval(() => {
      if (this._paused)
        return;
      const options2 = {
        editing: true,
        audible: true
      };
      this.loadPromiseUnlessBuffered(options2);
      const clips = this.clipsAudibleInTime(this.timeToBuffer);
      this.composition.bufferClips(clips, this.quantize);
    }, Math.round(this.buffer * 1e3 / 2));
  }
  bufferStop() {
    if (!this._bufferTimer)
      return;
    clearInterval(this._bufferTimer);
    delete this._bufferTimer;
  }
  changeTiming(propertied, property, value) {
    this.emitIfFramesChange(() => {
      propertied.setValue(value, property);
    });
  }
  clearDrawInterval() {
    if (!this.drawInterval)
      return;
    clearInterval(this.drawInterval);
    this.drawInterval = void 0;
  }
  clearPreview() {
    delete this._preview;
  }
  clipIntersects(clip, range) {
    if (!clip.frames)
      return true;
    return clip.timeRange(this.quantize).intersects(range);
  }
  get clips() {
    return this.tracks.map((track) => track.clips).flat();
  }
  clipsAudibleInTime(time) {
    const { clips } = this;
    const clipsAudible = clips.filter((clip) => clip.mutable && clip.notMuted);
    return this.filterIntersecting(clipsAudible, time);
  }
  clipsInTime(time) {
    return this.filterIntersecting(this.clips, time);
  }
  clipsInTimeOfType(time, avType = AVType.Both) {
    switch (avType) {
      case AVType.Both:
        return this.clipsInTime(time);
      case AVType.Audio:
        return this.clipsAudibleInTime(time);
      case AVType.Video:
        return this.clipsVisibleInTime(time);
    }
  }
  get clipsVisible() {
    return this.clips.filter((clip) => clip.container);
  }
  clipsVisibleInTime(time) {
    return this.filterIntersecting(this.clipsVisible, time);
  }
  compositeVisible(time) {
    var _a;
    this.drawingTime = time;
    this.clearPreview();
    (_a = this.emitter) == null ? void 0 : _a.emit(EventType.Draw);
  }
  // private counter = 0
  compositeVisibleRequest(time) {
    requestAnimationFrame(() => {
      this.compositeVisible(time);
    });
  }
  get composition() {
    if (!this._composition) {
      const options2 = {
        buffer: this.buffer,
        gain: this.gain,
        preloader: this.preloader
      };
      this._composition = new AudioPreview(options2);
    }
    return this._composition;
  }
  get definitionIds() {
    const { clips } = this;
    const ids = clips.flatMap((clip) => clip.definitionIds());
    const set = [...new Set(ids)];
    return set;
  }
  destroy() {
    this.paused = true;
    this.clearDrawInterval();
  }
  draw() {
    const { time } = this;
    this.compositeVisible(time);
  }
  drawRequest() {
    const { time } = this;
    this.compositeVisibleRequest(time);
  }
  drawTime(time) {
    var _a;
    const timeChange = time !== this.time;
    this.drawnTime = time;
    this.drawRequest();
    (_a = this.emitter) == null ? void 0 : _a.emit(timeChange ? EventType.Time : EventType.Loaded);
  }
  drawWhilePlayerNotPlaying() {
    const now = performance.now();
    const ellapsed = now - this.drawnSeconds;
    if (ellapsed < 1 / this.quantize)
      return;
    this.drawnSeconds = now;
    const { time } = this;
    const clips = this.clipsVisibleInTime(time);
    const streamableClips = clips.filter((clip) => clip.definition.streamable);
    if (!streamableClips.length)
      return;
    const files = this.graphFilesUnloaded({ time, editing: true, visible: true });
    const loading = files.length;
    if (loading)
      return;
    this.drawRequest();
  }
  get duration() {
    return this.endTime.seconds;
  }
  emitIfFramesChange(method) {
    var _a;
    const origFrames = this.frames;
    method();
    const { frames } = this;
    if (origFrames !== frames) {
      (_a = this.emitter) == null ? void 0 : _a.emit(EventType.Duration);
      if (this.frame > frames)
        this.seekToTime(timeFromArgs(frames, this.quantize));
    }
  }
  get endTime() {
    return timeFromArgs(this.frames, this.quantize);
  }
  filterGraphs(options2 = {}) {
    const { background, time, avType, graphType, size, videoRate: videoRate2, ...rest } = options2;
    const definedTime = time || this.time;
    const definedAVType = avType || (definedTime.isRange ? AVType.Both : AVType.Video);
    const filterGraphsOptions = {
      ...rest,
      times: this.timeRanges(definedAVType, definedTime),
      avType: definedAVType,
      graphType: graphType || GraphType.Mash,
      size: size || this.imageSize,
      videoRate: videoRate2 || definedTime.fps,
      mash: this,
      background: background || this.color
    };
    return new FilterGraphsClass(filterGraphsOptions);
  }
  filterIntersecting(clips, time) {
    const scaled = time.scale(this.quantize);
    return clips.filter((clip) => this.clipIntersects(clip, scaled));
  }
  // initial frame supplied to constructor
  get frame() {
    return this.time.scale(this.quantize, "floor").frame;
  }
  get frames() {
    const { tracks } = this;
    if (tracks.length) {
      const frames = this.tracks.map((track) => track.frames);
      if (isPositive(Math.min(...frames)))
        return Math.max(0, ...frames);
      return Duration.Unknown;
    }
    return Duration.None;
  }
  get gain() {
    return this._gain;
  }
  set gain(value) {
    if (!isPositive(value))
      throw Errors.invalid.argument + "gain " + value;
    if (this._gain !== value) {
      this._gain = value;
      if (this._composition)
        this.composition.setGain(value, this.quantize);
    }
  }
  graphFileOptions(options2 = {}) {
    const { time, audible, visible, editing, streaming } = options2;
    const definedTime = time || this.time;
    const { isRange } = definedTime;
    const definedVisible = visible || !isRange;
    const definedAudible = isRange && audible;
    const args = {
      editing,
      streaming,
      audible: definedAudible,
      visible: definedVisible,
      time: definedTime,
      quantize: this.quantize
    };
    const okay = definedVisible || definedAudible;
    assertTrue(okay, "audible || visible");
    return args;
  }
  editedGraphFiles(options2) {
    const args = this.graphFileOptions(options2);
    const { time, audible, visible } = args;
    const { quantize } = this;
    assertTime(time);
    const scaled = time.scale(this.quantize);
    const type2 = audible && visible ? AVType.Both : audible ? AVType.Audio : AVType.Video;
    const clips = this.clipsInTimeOfType(scaled, type2);
    return clips.flatMap((clip) => {
      const clipTime = clip.timeRange(quantize);
      const graphFileArgs = {
        ...args,
        clipTime,
        quantize,
        time
      };
      return clip.clipFileUrls(graphFileArgs);
    });
  }
  graphFilesUnloaded(options2) {
    const files = this.editedGraphFiles(options2);
    if (!files.length)
      return [];
    const { preloader } = this;
    return files.filter((file) => !preloader.loadedFile(file));
  }
  handleDrawInterval() {
    var _a;
    const { seconds } = this.composition;
    const nextFrameTime = this.time.withFrame(this.time.frame);
    if (seconds >= this.endTime.seconds) {
      if (this.loop)
        this.seekToTime(this.time.withFrame(0));
      else {
        this.paused = true;
        (_a = this.emitter) == null ? void 0 : _a.emit(EventType.Ended);
      }
    } else {
      if (seconds >= nextFrameTime.seconds) {
        const compositionTime = timeFromSeconds(seconds, this.time.fps);
        this.drawTime(compositionTime);
      }
    }
  }
  get layer() {
    return this._layer;
  }
  set layer(value) {
    this._layer = value;
  }
  loadPromise(args = {}) {
    const promise = this.loadPromiseUnlessBuffered(args);
    return promise || Promise.resolve();
  }
  get loading() {
    return !!this.loadingPromises.length;
  }
  loadPromiseUnlessBuffered(options2 = {}) {
    options2.time || (options2.time = this.timeToBuffer);
    const files = this.graphFilesUnloaded(options2);
    if (!files.length) {
      return;
    }
    const promise = this.preloader.loadFilesPromise(files);
    const removedPromise = promise.then(() => {
      const index = this.loadingPromises.indexOf(promise);
      if (index < 0)
        throw Errors.internal + "couldn't find promise~";
      this.loadingPromises.splice(index, 1);
    });
    this.loadingPromises.push(promise);
    return removedPromise;
  }
  get mashes() {
    return [this];
  }
  get paused() {
    return this._paused;
  }
  set paused(value) {
    var _a, _b;
    const paused = value || !this.frames;
    if (this._paused === paused)
      return;
    this._paused = paused;
    if (paused) {
      this.playing = false;
      this.bufferStop();
      if (this._bufferTimer) {
        clearInterval(this._bufferTimer);
        delete this._bufferTimer;
      }
      this.composition.stopContext();
      (_a = this.emitter) == null ? void 0 : _a.emit(EventType.Pause);
    } else {
      this.composition.startContext();
      this.bufferStart();
      const promise = this.loadPromiseUnlessBuffered({
        editing: true,
        audible: true,
        visible: true
      });
      if (promise)
        promise.then(() => {
          this.playing = true;
        });
      else
        this.playing = true;
      (_b = this.emitter) == null ? void 0 : _b.emit(EventType.Play);
    }
  }
  get playing() {
    return this._playing;
  }
  set playing(value) {
    var _a;
    if (this._playing !== value) {
      this._playing = value;
      if (value) {
        const { quantize, time } = this;
        const clips = this.clipsAudibleInTime(this.timeToBuffer);
        if (!this.composition.startPlaying(time, clips, quantize)) {
          const currentClips = this.clipsAudibleInTime(this.timeToBuffer);
          if (!this.composition.startPlaying(time, currentClips, quantize)) {
            this._playing = false;
            return;
          }
        }
        (_a = this.emitter) == null ? void 0 : _a.emit(EventType.Playing);
        this.setDrawInterval();
      } else {
        this.composition.stopPlaying();
        this.clearDrawInterval();
      }
    }
  }
  preview(options2) {
    return this._preview || (this._preview = this.previewInitialize(options2));
  }
  previewInitialize(options2) {
    return new PreviewClass(this.previewArgs(options2));
  }
  previewArgs(options2 = {}) {
    const { editor } = options2;
    const clip = editor == null ? void 0 : editor.selection.clip;
    const selectedClip = isClip(clip) ? clip : void 0;
    const { drawingTime, time, quantize } = this;
    const svgTime = drawingTime || time;
    const args = {
      selectedClip,
      time: svgTime.scale(quantize),
      mash: this,
      ...options2
    };
    if (isUndefined(options2.background))
      args.background = this.color;
    return args;
  }
  putPromise() {
    const { quantize, preloader } = this;
    const files = this.clips.flatMap((clip) => {
      const { container } = clip;
      if (isTextContainer(container)) {
        if (!container.intrinsicsKnown({ editing: true, size: true })) {
          const args = {
            editing: true,
            visible: true,
            quantize,
            time: clip.time(quantize),
            clipTime: clip.timeRange(quantize)
          };
          return container.fileUrls(args);
        }
      }
      return [];
    });
    return preloader.loadFilesPromise(files);
  }
  removeClipFromTrack(clip) {
    const clips = isArray(clip) ? clip : [clip];
    this.emitIfFramesChange(() => {
      clips.forEach((clip2) => {
        const track = clip2.track;
        track.removeClips([clip2]);
      });
    });
  }
  removeTrack(index) {
    var _a;
    const trackIndex = isPositive(index) ? index : this.tracks.length - 1;
    assertPositive(trackIndex);
    this.emitIfFramesChange(() => {
      this.tracks.splice(trackIndex, 1);
    });
    (_a = this.emitter) == null ? void 0 : _a.emit(EventType.Track);
  }
  get rendering() {
    return this._rendering;
  }
  set rendering(value) {
    var _a;
    this._rendering = value;
    (_a = this.emitter) == null ? void 0 : _a.emit(EventType.Render);
  }
  restartAfterStop(time, paused, seeking) {
    var _a;
    if (time.equalsTime(this.time)) {
      if (seeking) {
        delete this.seekTime;
        (_a = this.emitter) == null ? void 0 : _a.emit(EventType.Seeked);
      }
      this.drawTime(time);
      if (!paused) {
        this.playing = true;
      }
    }
  }
  reload() {
    return this.stopLoadAndDraw();
  }
  seekToTime(time) {
    var _a, _b;
    if (this.seekTime !== time) {
      this.seekTime = time;
      (_a = this.emitter) == null ? void 0 : _a.emit(EventType.Seeking);
      (_b = this.emitter) == null ? void 0 : _b.emit(EventType.Time);
    }
    return this.stopLoadAndDraw(true);
  }
  selectables() {
    const selectables = [this];
    if (this._layer)
      selectables.push(...this.layer.selectables());
    return selectables;
  }
  selectedItems(actions) {
    return this.properties.map((property) => {
      const undoValue = this.value(property.name);
      const target = this;
      return {
        value: undoValue,
        selectType: SelectType.Mash,
        property,
        changeHandler: (property2, redoValue) => {
          assertPopulatedString(property2);
          const options2 = { property: property2, target, redoValue, undoValue };
          actions.create(options2);
        }
      };
    });
  }
  setDrawInterval() {
    if (this.drawInterval)
      return;
    this.clearDrawInterval();
    this.drawInterval = setInterval(() => {
      this.handleDrawInterval();
    }, 500 / this.time.fps);
  }
  stopLoadAndDraw(seeking) {
    const { time, paused, playing } = this;
    if (playing)
      this.playing = false;
    const promise = this.loadPromiseUnlessBuffered({
      editing: true,
      visible: true,
      audible: playing
    });
    if (promise)
      return promise.then(() => {
        this.restartAfterStop(time, paused, seeking);
      });
    this.restartAfterStop(time, paused, seeking);
  }
  previewItems(options2) {
    return this.preview(options2).previewItemsPromise;
  }
  get time() {
    return this.seekTime || this.drawnTime || timeFromArgs(this._frame, this.quantize);
  }
  get timeRange() {
    const { endTime, time } = this;
    const scaled = endTime.scale(time.fps);
    const range = timeRangeFromTime(time, scaled.frame);
    return range;
  }
  timeRanges(avType, startTime) {
    const time = startTime || this.time;
    const { quantize } = this;
    const start = time.scale(this.quantize, "floor");
    const end = start.isRange ? start.timeRange.endTime : void 0;
    const fullRangeClips = this.clipsInTimeOfType(time, avType);
    const { length: length2 } = fullRangeClips;
    if (!length2)
      return [];
    if (length2 === 1 || !start.isRange || avType === AVType.Audio)
      return [time];
    const frames = /* @__PURE__ */ new Set();
    fullRangeClips.forEach((clip) => {
      frames.add(Math.max(clip.frame, start.frame));
      frames.add(Math.min(clip.frame + clip.frames, end.frame));
    });
    const uniqueFrames = [...frames].sort((a, b) => a - b);
    let frame = uniqueFrames.shift();
    const ranges = uniqueFrames.map((uniqueFrame) => {
      const range = timeRangeFromArgs(frame, quantize, uniqueFrame - frame);
      frame = uniqueFrame;
      return range;
    });
    return ranges;
  }
  get timeToBuffer() {
    const { time, quantize, buffer, paused } = this;
    if (paused)
      return timeFromArgs(time.scale(quantize, "floor").frame, quantize);
    return timeRangeFromTimes(time, timeFromSeconds(buffer + time.seconds, time.fps));
  }
  toJSON() {
    const json = super.toJSON();
    json.tracks = this.tracks;
    if (this._rendering)
      json.rendering = this.rendering;
    return json;
  }
  trackClips(clips, trackIndex) {
    const oneTrack = isPositive(trackIndex);
    if (oneTrack)
      return [[trackIndex, clips]];
    let index = this.tracks.length - clips.length;
    return clips.map((clip) => [index++, [clip]]);
  }
};
var mashInstance = (object = {}) => new MashClass(object);
var isMashClass = (value) => value instanceof MashClass;
function assertMashClass(value) {
  if (!isMashClass(value))
    throw new Error("expected MashClass");
}
var LayerClass = class extends PropertiedClass {
  constructor(args) {
    super();
    __publicField(this, "_cast");
    __publicField(this, "_id");
    __publicField(this, "selectType", SelectType.Layer);
    __publicField(this, "triggers", []);
    __publicField(this, "type");
    this.properties.push(propertyInstance({ name: "label", type: DataType.String }));
    this.propertiesInitialize(args);
  }
  get cast() {
    return this._cast;
  }
  set cast(value) {
    this._cast = value;
  }
  get id() {
    return this._id || (this._id = idGenerate("layer"));
  }
  get mashes() {
    throw Errors.unimplemented + "mashes";
  }
  selectables() {
    return [this, ...this.cast.selectables()];
  }
  selectedItems(actions) {
    return this.properties.map((property) => {
      const undoValue = this.value(property.name);
      const target = this;
      return {
        value: undoValue,
        selectType: SelectType.Layer,
        property,
        changeHandler: (property2, redoValue) => {
          assertPopulatedString(property2);
          const options2 = { property: property2, target, redoValue, undoValue };
          actions.create(options2);
        }
      };
    });
  }
  toJSON() {
    const json = super.toJSON();
    json.type = this.type;
    json.triggers = this.triggers;
    return json;
  }
};
var LayerFolderClass = class extends LayerClass {
  constructor(args) {
    super(args);
    __publicField(this, "collapsed");
    __publicField(this, "layers");
    __publicField(this, "type", LayerType.Folder);
    const { label: label2, layers, collapsed } = args;
    if (!label2)
      this.label = Default.label;
    this.collapsed = collapsed;
    this.layers = layers;
  }
  get mashes() {
    return this.layers.flatMap((layer) => layer.mashes);
  }
  toJSON() {
    const json = super.toJSON();
    json.layers = this.layers;
    json.collapsed = this.collapsed;
    return json;
  }
};
var DirectionLabels = [
  "top",
  "right",
  "bottom",
  "left",
  "top right",
  "bottom right",
  "bottom left",
  "top left"
];
var LayerMashClass = class extends LayerClass {
  constructor(args) {
    super(args);
    __publicField(this, "mash");
    __publicField(this, "type", LayerType.Mash);
    const { mash } = args;
    if (!this.label)
      this.label = mash.label;
    this.mash = mash;
    mash.layer = this;
  }
  get mashes() {
    return [this.mash];
  }
  toJSON() {
    const json = super.toJSON();
    json.mash = this.mash;
    return json;
  }
};
var isLayerObject = (value) => {
  return isObject(value) && "type" in value && isLayerType(value.type);
};
var isLayerFolderObject = (value) => {
  return isLayerObject(value) && value.type === LayerType.Folder;
};
var isLayerMashObject = (value) => {
  return isLayerObject(value) && value.type === LayerType.Mash;
};
({ type: LayerType.Folder, collapsed: false, layers: [] });
({ type: LayerType.Mash, mash: {} });
var layerFolderInstance = (object, cast) => {
  const { preloader } = object;
  object.layers || (object.layers = []);
  const args = {
    ...object,
    layers: object.layers.map((layer) => layerInstance({ preloader, ...layer }))
  };
  return new LayerFolderClass(args);
};
var layerMashInstance = (object, cast) => {
  const { preloader } = object;
  object.mash || (object.mash = {});
  const mash = mashInstance({ preloader, ...object.mash });
  const args = {
    ...object,
    mash
  };
  return new LayerMashClass(args);
};
var layerInstance = (layerObject, cast) => {
  if (isLayerMashObject(layerObject))
    return layerMashInstance(layerObject);
  if (isLayerFolderObject(layerObject))
    return layerFolderInstance(layerObject);
  throw new Error("expected LayerObject");
};
var isLayer = (value) => value instanceof LayerClass;
function assertLayer(value) {
  if (!isLayer(value))
    throw "expected Layer";
}
var isLayerMash = (value) => value instanceof LayerMashClass;
function assertLayerMash(value) {
  if (!isLayerMash(value))
    throw "expected LayerMash";
}
var isLayerFolder = (value) => value instanceof LayerFolderClass;
function assertLayerFolder(value) {
  if (!isLayerFolder(value))
    throw "expected LayerFolder";
}
var CastLayerFolders = (layers) => {
  return layers.flatMap((layer) => {
    if (isLayerFolder(layer)) {
      return [layer, ...CastLayerFolders(layer.layers)];
    }
    return [];
  });
};
var CastPositionIndex = (index, droppingPosition) => {
  if (droppingPosition === DroppingPosition.After)
    return index + 1;
  return index;
};
var CastFindLayerFolder = (layer, layers) => {
  if (layers.includes(layer))
    return;
  const layerFolders = CastLayerFolders(layers);
  return layerFolders.find((layerFolder) => layerFolder.layers.includes(layer));
};
var CastLayersAndIndex = (layers, layerAndPosition) => {
  const { layer, position = DroppingPosition.At } = layerAndPosition;
  const numeric = isNumber(position);
  const defined = !!layer;
  const folder = defined && isLayerFolder(layer);
  const index = numeric ? position : 0;
  if (!defined || numeric)
    return {
      index,
      layers: folder ? layer.layers : layers
    };
  if (folder && position === DroppingPosition.At)
    return {
      index: 0,
      layers: layer.layers
    };
  const layerFolder = CastFindLayerFolder(layer, layers);
  if (!layerFolder)
    return { index, layers };
  const { layers: folderLayers } = layerFolder;
  const currentIndex = folderLayers.indexOf(layer);
  if (currentIndex < 0)
    throw new Error(Errors.internal);
  return { layers: folderLayers, index: CastPositionIndex(currentIndex, position) };
};
var CastClass = class extends EditedClass {
  constructor(args) {
    super(args);
    __publicField(this, "_buffer", Default.cast.buffer);
    __publicField(this, "layers", []);
    __publicField(this, "selectType", SelectType.Cast);
    const { createdAt, icon, id: id2, label: label2, definitions, layers, preloader, ...rest } = args;
    this.dataPopulate(rest);
    if (isPopulatedArray(layers))
      this.layers.push(...layers.map((object) => this.createLayer(object)));
    this.label || (this.label = Default.cast.label);
  }
  addLayer(layer, layerAndPosition = {}) {
    const { layers, index } = CastLayersAndIndex(this.layers, layerAndPosition);
    layers.splice(index, 0, layer);
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(value) {
    if (!isAboveZero(value))
      throw Errors.invalid.argument + "buffer " + value;
    if (this._buffer !== value) {
      this._buffer = value;
      this.mashes.forEach((mash) => {
        mash.buffer = value;
      });
    }
  }
  createLayer(layerObject) {
    const { preloader } = this;
    const object = {
      preloader,
      ...layerObject
    };
    const layer = layerInstance(object);
    assertLayer(layer);
    layer.cast = this;
    return layer;
  }
  destroy() {
    this.mashes.forEach((mash) => mash.destroy());
  }
  emitterChanged() {
    this.mashes.forEach((mash) => mash.emitter = this.emitter);
  }
  editedGraphFiles(args) {
    return this.mashes.flatMap((mash) => mash.editedGraphFiles(args));
  }
  get imageSize() {
    return super.imageSize;
  }
  set imageSize(value) {
    super.imageSize = value;
    const { imageSize } = this;
    this.mashes.forEach((mash) => {
      mash.imageSize = imageSize;
    });
  }
  get layerFolders() {
    return CastLayerFolders(this.layers);
  }
  loadPromise(args) {
    return Promise.all(this.mashes.map((mash) => mash.loadPromise(args))).then(EmptyMethod);
  }
  get loading() {
    return this.mashes.some((mash) => mash.loading);
  }
  get mashes() {
    return this.layers.flatMap((layer) => layer.mashes);
  }
  moveLayer(layer, layerAndPosition) {
    const result = this.removeLayer(layer);
    this.addLayer(layer, layerAndPosition);
    return result;
  }
  putPromise() {
    return Promise.all(this.mashes.map((mash) => mash.putPromise())).then(EmptyMethod);
  }
  reload() {
    return;
  }
  removeLayer(layer) {
    const layerFolder = CastFindLayerFolder(layer, this.layers);
    const layers = (layerFolder == null ? void 0 : layerFolder.layers) || this.layers;
    const index = layers.indexOf(layer);
    if (index < 0) {
      console.error("removeLayer", index, layers.length, layer.label, layerFolder == null ? void 0 : layerFolder.label);
      throw new Error(Errors.internal);
    }
    layers.splice(index, 1);
    return { position: index, layer: layerFolder };
  }
  selectables() {
    return [this];
  }
  selectedItems(actions) {
    return this.properties.map((property) => {
      const undoValue = this.value(property.name);
      const target = this;
      return {
        value: undoValue,
        selectType: SelectType.Cast,
        property,
        changeHandler: (property2, redoValue) => {
          assertPopulatedString(property2);
          const options2 = { property: property2, target, redoValue, undoValue };
          actions.create(options2);
        }
      };
    });
  }
  setValue(value, name, property) {
    super.setValue(value, name, property);
    if (property)
      return;
    switch (name) {
      case "color": {
        this.mashes.forEach((mash) => mash.setValue(value, name, property));
        break;
      }
    }
  }
  previewItems(args) {
    const { mashes, imageSize } = this;
    const allSvgs = [];
    const { background = this.color } = args;
    const mashArgs = { ...args, color: "" };
    const element = svgElement(imageSize, svgPolygonElement(imageSize, "", background));
    let promise = Promise.resolve([element]);
    arrayReversed(mashes).forEach((mash) => {
      promise = promise.then((svgs) => {
        allSvgs.push(...svgs);
        return mash.previewItems(mashArgs);
      });
    });
    return promise.then((svgs) => {
      allSvgs.push(...svgs);
      return allSvgs;
    });
  }
  toJSON() {
    const json = super.toJSON();
    json.layers = this.layers;
    return json;
  }
};
var castInstance = (object = {}, preloader) => {
  const castArgs = { ...object, preloader };
  return new CastClass(castArgs);
};
var isCast = (value) => value instanceof CastClass;
function assertCast(value) {
  if (!isCast(value))
    throw new Error("expected Cast");
}
var isEdited = (value) => {
  return isMash(value) || isCast(value);
};
function assertEdited(value) {
  if (!isEdited(value))
    throwError(value, "Edited");
}
var Action = class {
  constructor(object) {
    __publicField(this, "done", false);
    __publicField(this, "redoSelection");
    __publicField(this, "type");
    __publicField(this, "undoSelection");
    const { redoSelection, type: type2, undoSelection } = object;
    this.redoSelection = redoSelection;
    this.type = type2;
    this.undoSelection = undoSelection;
  }
  get cast() {
    const { cast } = this.redoSelection;
    if (isCast(cast))
      return cast;
    const { cast: undoCast } = this.undoSelection;
    assertCast(undoCast);
    return undoCast;
  }
  get mash() {
    const { mash } = this.redoSelection;
    if (isMash(mash))
      return mash;
    const { mash: undoMash } = this.undoSelection;
    assertMash(undoMash);
    return undoMash;
  }
  redo() {
    this.redoAction();
    this.done = true;
  }
  redoAction() {
    throw Errors.unimplemented + "redoAction";
  }
  get selection() {
    if (this.done)
      return this.redoSelection;
    return this.undoSelection;
  }
  undo() {
    this.undoAction();
    this.done = false;
  }
  undoAction() {
    throw Errors.unimplemented + "undoAction";
  }
};
var isAction = (value) => value instanceof Action;
function assertAction(value) {
  if (!isAction(value))
    throw new Error("expected Action");
}
var isActionInit = (value) => isAction(value.action);
var isActionEvent = (value) => {
  return isCustomEvent(value) && value.detail;
};
var AddTrackAction = class extends Action {
  constructor(object) {
    super(object);
    __publicField(this, "createTracks");
    const { createTracks } = object;
    this.createTracks = createTracks;
  }
  redoAction() {
    for (let i = 0; i < this.createTracks; i += 1) {
      this.mash.addTrack();
    }
  }
  undoAction() {
    for (let i = 0; i < this.createTracks; i += 1) {
      this.mash.removeTrack();
    }
  }
};
var AddClipToTrackAction = class extends AddTrackAction {
  constructor(object) {
    super(object);
    __publicField(this, "clips");
    __publicField(this, "insertIndex");
    __publicField(this, "trackIndex");
    __publicField(this, "redoFrame");
    __publicField(this, "undoFrame");
    const { clips, insertIndex, trackIndex, redoFrame, undoFrame } = object;
    this.clips = clips;
    this.insertIndex = insertIndex;
    this.trackIndex = trackIndex;
    this.redoFrame = redoFrame;
    this.undoFrame = undoFrame;
  }
  get track() {
    return this.mash.tracks[this.trackIndex];
  }
  redoAction() {
    super.redoAction();
    const { mash, redoFrame, trackIndex, insertIndex, clips } = this;
    mash.addClipToTrack(clips, trackIndex, insertIndex, redoFrame);
  }
  undoAction() {
    const { mash, clips } = this;
    mash.removeClipFromTrack(clips);
    super.undoAction();
  }
};
var AddEffectAction = class extends Action {
  constructor(object) {
    super(object);
    __publicField(this, "effect");
    __publicField(this, "effects");
    __publicField(this, "index");
    const { effect, effects, index } = object;
    this.effect = effect;
    this.effects = effects;
    this.index = index;
  }
  redoAction() {
    this.effects.splice(this.index, 0, this.effect);
  }
  undoAction() {
    this.effects.splice(this.index, 1);
  }
};
var isChangeActionObject = (value) => {
  return isObject(value) && "target" in value && "property" in value;
};
var ChangeAction = class extends Action {
  constructor(object) {
    super(object);
    __publicField(this, "property");
    __publicField(this, "redoValue");
    __publicField(this, "target");
    __publicField(this, "undoValue");
    const { property, redoValue, target, undoValue } = object;
    this.property = property;
    this.redoValue = redoValue;
    this.target = target;
    this.undoValue = undoValue;
  }
  get redoValueNumeric() {
    return Number(this.redoValue);
  }
  get undoValueNumeric() {
    return Number(this.undoValue);
  }
  redoAction() {
    this.target.setValue(this.redoValue, this.property);
  }
  undoAction() {
    this.target.setValue(this.undoValue, this.property);
  }
  updateAction(object) {
    const { redoValue } = object;
    this.redoValue = redoValue;
    this.redo();
  }
};
var isChangeAction = (value) => value instanceof ChangeAction;
function assertChangeAction(value) {
  if (!isChangeAction(value))
    throw new Error("expected ChangeAction");
}
var ChangeFramesAction = class extends ChangeAction {
  constructor(object) {
    super(object);
  }
  redoAction() {
    this.mash.changeTiming(this.target, this.property, this.redoValueNumeric);
  }
  undoAction() {
    this.mash.changeTiming(this.target, this.property, this.undoValueNumeric);
  }
};
var MoveClipAction = class extends AddTrackAction {
  constructor(object) {
    super(object);
    __publicField(this, "clip");
    __publicField(this, "insertIndex");
    __publicField(this, "trackIndex");
    __publicField(this, "undoTrackIndex");
    __publicField(this, "undoInsertIndex");
    __publicField(this, "undoFrame");
    __publicField(this, "redoFrame");
    const { clip, insertIndex, redoFrame, trackIndex, undoFrame, undoInsertIndex, undoTrackIndex } = object;
    this.clip = clip;
    this.insertIndex = insertIndex;
    this.redoFrame = redoFrame;
    this.trackIndex = trackIndex;
    this.undoFrame = undoFrame;
    this.undoInsertIndex = undoInsertIndex;
    this.undoTrackIndex = undoTrackIndex;
  }
  addClip(trackIndex, insertIndex, frame) {
    this.mash.addClipToTrack(this.clip, trackIndex, insertIndex, frame);
  }
  redoAction() {
    super.redoAction();
    this.addClip(this.trackIndex, this.insertIndex, this.redoFrame);
  }
  undoAction() {
    this.addClip(this.undoTrackIndex, this.undoInsertIndex, this.undoFrame);
    super.undoAction();
  }
};
var MoveEffectAction = class extends Action {
  constructor(object) {
    super(object);
    __publicField(this, "effects");
    __publicField(this, "redoEffects");
    __publicField(this, "undoEffects");
    const { effects, redoEffects, undoEffects } = object;
    this.effects = effects;
    this.redoEffects = redoEffects;
    this.undoEffects = undoEffects;
  }
  redoAction() {
    this.effects.splice(0, this.effects.length, ...this.redoEffects);
  }
  undoAction() {
    this.effects.splice(0, this.effects.length, ...this.undoEffects);
  }
};
var RemoveClipAction = class extends Action {
  constructor(object) {
    super(object);
    __publicField(this, "track");
    __publicField(this, "clip");
    __publicField(this, "index");
    const { clip, index, track } = object;
    this.clip = clip;
    this.index = index;
    this.track = track;
  }
  get trackIndex() {
    return this.track.index;
  }
  redoAction() {
    this.mash.removeClipFromTrack(this.clip);
  }
  undoAction() {
    this.mash.addClipToTrack(this.clip, this.trackIndex, this.index);
  }
};
var AddLayerAction = class extends Action {
  constructor(object) {
    super(object);
    __publicField(this, "layerAndPosition");
    const { layerAndPosition } = object;
    if (layerAndPosition)
      this.layerAndPosition = layerAndPosition;
  }
  get layer() {
    const { layer } = this.redoSelection;
    assertLayer(layer);
    return layer;
  }
  redoAction() {
    this.cast.addLayer(this.layer, this.layerAndPosition);
  }
  undoAction() {
    this.cast.removeLayer(this.layer);
  }
};
var RemoveLayerAction = class extends Action {
  constructor() {
    super(...arguments);
    __publicField(this, "layerAndPosition");
  }
  get layer() {
    const { layer } = this.redoSelection;
    assertLayer(layer);
    return layer;
  }
  redoAction() {
    this.layerAndPosition = this.cast.removeLayer(this.layer);
  }
  undoAction() {
    this.cast.addLayer(this.layer, this.layerAndPosition);
  }
};
var MoveLayerAction = class extends AddLayerAction {
  constructor() {
    super(...arguments);
    __publicField(this, "undoLayerAndPosition");
  }
  get layer() {
    const { layer } = this.redoSelection;
    assertLayer(layer);
    return layer;
  }
  redoAction() {
    this.undoLayerAndPosition = this.cast.moveLayer(this.layer, this.layerAndPosition);
  }
  undoAction() {
    this.cast.moveLayer(this.layer, this.undoLayerAndPosition);
  }
};
var ChangeMultipleAction = class extends ChangeAction {
  constructor(object) {
    const { redoValues, undoValues } = object;
    super(object);
    __publicField(this, "redoValues");
    __publicField(this, "undoValues");
    this.undoValues = undoValues;
    this.redoValues = redoValues;
  }
  redoAction() {
    const { target, redoValues } = this;
    Object.entries(redoValues).forEach(([property, value]) => {
      target.setValue(value, property);
    });
  }
  undoAction() {
    const { target, undoValues } = this;
    Object.entries(undoValues).forEach(([property, value]) => {
      target.setValue(value, property);
    });
  }
  updateAction(object) {
    const { redoValues } = object;
    this.redoValues = redoValues;
    this.redo();
  }
};
var actionInstance = (object) => {
  const { type: type2 } = object;
  if (!isPopulatedString(type2))
    throw Errors.type + JSON.stringify(object);
  switch (type2) {
    case ActionType.AddClipToTrack:
      return new AddClipToTrackAction(object);
    case ActionType.AddEffect:
      return new AddEffectAction(object);
    case ActionType.AddLayer:
      return new AddLayerAction(object);
    case ActionType.AddTrack:
      return new AddTrackAction(object);
    case ActionType.Change:
      return new ChangeAction(object);
    case ActionType.ChangeFrame:
      return new ChangeFramesAction(object);
    case ActionType.ChangeMultiple:
      return new ChangeMultipleAction(object);
    case ActionType.MoveClip:
      return new MoveClipAction(object);
    case ActionType.MoveEffect:
      return new MoveEffectAction(object);
    case ActionType.MoveLayer:
      return new MoveLayerAction(object);
    case ActionType.RemoveClip:
      return new RemoveClipAction(object);
    case ActionType.RemoveLayer:
      return new RemoveLayerAction(object);
    default:
      throw Errors.type + type2;
  }
};
var ActionFactory = {
  createFromObject: actionInstance
};
var Actions = class {
  constructor(editor) {
    __publicField(this, "editor");
    __publicField(this, "index", -1);
    __publicField(this, "instances", []);
    this.editor = editor;
  }
  add(action) {
    const remove = this.instances.length - (this.index + 1);
    if (isPositive(remove))
      this.instances.splice(this.index + 1, remove);
    this.instances.push(action);
  }
  get canRedo() {
    return this.index < this.instances.length - 1;
  }
  get canSave() {
    return this.canUndo;
  }
  get canUndo() {
    return this.index > -1;
  }
  create(object) {
    const { editor } = this;
    const { undoSelection, redoSelection, type: type2 = ActionType.Change, ...rest } = object;
    const clone = {
      ...rest,
      type: type2,
      undoSelection: undoSelection || { ...editor.selection.object },
      redoSelection: redoSelection || { ...editor.selection.object }
    };
    if (isChangeActionObject(object) && this.currentActionLast) {
      const { currentAction } = this;
      if (isChangeAction(currentAction)) {
        const { target, property } = object;
        if (currentAction.target === target && currentAction.property === property) {
          currentAction.updateAction(object);
          editor.handleAction(currentAction);
          return;
        }
      }
    }
    const action = actionInstance(clone);
    this.add(action);
    editor.handleAction(this.redo());
  }
  get currentAction() {
    return this.instances[this.index];
  }
  get currentActionLast() {
    return this.canUndo && !this.canRedo;
  }
  destroy() {
    this.index = -1;
    this.instances.splice(0, this.instances.length);
  }
  redo() {
    this.index += 1;
    const action = this.currentAction;
    assertAction(action);
    action.redo();
    return action;
  }
  reusableChangeAction(target, property) {
    if (!this.currentActionLast)
      return;
    const action = this.currentAction;
    if (isChangeAction(action) && action.target === target && action.property === property) {
      return action;
    }
  }
  save() {
    this.instances.splice(0, this.index + 1);
    this.index = -1;
  }
  get selection() {
    return this.editor.selection;
  }
  undo() {
    const action = this.currentAction;
    assertAction(action);
    this.index -= 1;
    action.undo();
    return action;
  }
};
var isCastData = (data) => isObject(data) && "cast" in data;
var isMashData = (data) => isObject(data) && "mash" in data;
function assertMashData(data, name) {
  if (!isMashData(data))
    throwError(data, "MashData", name);
}
var Emitter = class extends EventTarget {
  constructor() {
    super(...arguments);
    __publicField(this, "trapped", /* @__PURE__ */ new Map());
  }
  dispatch(type2, detail) {
    this.dispatchEvent(this.event(type2, detail));
  }
  emit(type2, detail) {
    if (!this.trapped.has(type2)) {
      this.dispatch(type2, detail);
      return;
    }
    const listener = this.trapped.get(type2);
    if (listener)
      listener(this.event(type2, detail));
  }
  event(type2, detail) {
    const init = detail ? { detail } : void 0;
    return new CustomEvent(type2, init);
  }
  trap(type2, listener) {
    if (this.trapped.has(type2))
      return;
    this.trapped.set(type2, listener || null);
  }
};
var isEffect = (value) => {
  return isInstance(value) && value.type === DefinitionType.Effect;
};
function assertEffect(value) {
  if (!isEffect(value))
    throw new Error("expected Effect");
}
var isEffectDefinition = (value) => {
  return isDefinition(value) && value.type === DefinitionType.Effect;
};
var isFontDefinition = (value) => {
  return isDefinition(value) && value.type === DefinitionType.Font;
};
function assertFontDefinition(value) {
  if (!isFontDefinition(value))
    throw new Error("expected FontDefinition");
}
var LoaderClass = class {
  constructor(endpoint) {
    __publicField(this, "browsing", true);
    __publicField(this, "endpoint");
    __publicField(this, "loaderCache", /* @__PURE__ */ new Map());
    this.endpoint = endpoint || {};
  }
  absoluteUrl(path2) {
    return path2;
  }
  cacheGet(graphFile, createIfNeeded) {
    const key = this.key(graphFile);
    const cacheKey = this.cacheKey(graphFile);
    const found = this.loaderCache.get(cacheKey);
    if (found || !createIfNeeded)
      return found;
    const { definition, type: type2 } = graphFile;
    const definitions = [];
    if (isDefinition(definition))
      definitions.push(definition);
    const cache = { loaded: false, definitions };
    this.cacheSet(cacheKey, cache);
    cache.promise = this.cachePromise(key, graphFile, cache).then((loaded) => {
      cache.loaded = true;
      cache.result = loaded;
      return loaded;
    }).catch((error) => {
      cache.error = error;
      cache.loaded = true;
      return error;
    });
    return cache;
  }
  cacheKey(graphFile) {
    const { type: type2 } = graphFile;
    const key = this.key(graphFile);
    return `${type2}:/${key}`;
  }
  cachePromise(key, graphFile, cache) {
    const cacheKey = this.cacheKey(graphFile);
    const loaderFile = {
      loaderPath: cacheKey,
      urlOrLoaderPath: key,
      loaderType: graphFile.type
    };
    return this.filePromise(loaderFile);
  }
  cacheSet(graphFile, cache) {
    const key = isString(graphFile) ? graphFile : this.cacheKey(graphFile);
    this.loaderCache.set(key, cache);
  }
  filePromise(file) {
    throw Errors.unimplemented + "filePromise";
  }
  flushFilesExcept(fileUrls = []) {
    const retainKeys = fileUrls.map((fileUrl) => this.cacheKey(fileUrl));
    const keys = [...this.loaderCache.keys()];
    const removeKeys = keys.filter((key) => !retainKeys.includes(key));
    removeKeys.forEach((key) => {
      const cache = this.loaderCache.get(key);
      if (cache) {
        this.loaderCache.delete(key);
      }
    });
  }
  getCache(path2) {
    const files = this.parseUrlPath(path2);
    const [file] = files;
    assertObject(file);
    return this.loaderCache.get(file.loaderPath);
  }
  getError(graphFile) {
    var _a;
    return (_a = this.cacheGet(graphFile)) == null ? void 0 : _a.error;
  }
  getLoaderCache(file, createIfNeeded, definition) {
    const { loaderPath, loaderType } = file;
    const found = this.loaderCache.get(loaderPath);
    if (found || !createIfNeeded) {
      return found;
    }
    const definitions = [];
    if (isDefinition(definition))
      definitions.push(definition);
    const cache = { loaded: false, definitions };
    if (loaderType !== GraphFileType.Svg)
      this.setLoaderCache(loaderPath, cache);
    cache.promise = this.filePromise(file).then((loaded) => {
      cache.loaded = true;
      cache.result = loaded;
      return loaded;
    }).catch((error) => {
      cache.error = error;
      cache.loaded = true;
      return error;
    });
    return cache;
  }
  imagePromise(url) {
    const image = new Image();
    image.src = url;
    return image.decode().then(() => image);
  }
  info(loaderPath) {
    if (!loaderPath)
      console.trace(this.constructor.name, "info NO loaderPath");
    const files = this.parseUrlPath(loaderPath);
    files.reverse();
    for (const file of files) {
      const cache = this.loaderCache.get(file.urlOrLoaderPath);
      if (!cache)
        continue;
      const { loadedInfo } = cache;
      if (isPopulatedObject(loadedInfo))
        return loadedInfo;
    }
  }
  key(graphFile) {
    throw Errors.unimplemented + "key";
  }
  lastCssUrl(string) {
    const exp = /url\(([^)]+)\)(?!.*\1)/g;
    const matches = string.matchAll(exp);
    const matchesArray = [...matches];
    const url = arrayLast(arrayLast(matchesArray));
    return url;
  }
  loadFilesPromise(graphFiles) {
    const promises = graphFiles.map((file) => this.loadGraphFilePromise(file));
    return Promise.all(promises).then(EmptyMethod);
  }
  loadGraphFilePromise(graphFile) {
    const { type: type2, file, definition } = graphFile;
    const url = `${type2}:/${file}`;
    return this.loadPromise(url, definition);
  }
  loadPromise(urlPath, definition) {
    const cache = this.loaderCache.get(urlPath);
    if (cache) {
      const { promise: promise2, result, loaded, error } = cache;
      if (loaded || error) {
        return Promise.resolve(result);
      }
      assertObject(promise2);
      return promise2;
    }
    const files = this.parseUrlPath(urlPath);
    files.reverse();
    const file = files.shift();
    assertObject(file);
    let promise = this.loaderFilePromise(file, definition);
    files.forEach((file2) => {
      promise = promise.then(() => {
        return this.loaderFilePromise(file2);
      });
    });
    return promise.then((something) => {
      return something;
    });
  }
  loadedFile(graphFile) {
    const file = this.cacheGet(graphFile);
    return !!(file == null ? void 0 : file.loaded);
  }
  loaderFilePromise(file, definition) {
    let cache = this.getLoaderCache(file, true, definition);
    assertObject(cache);
    const { promise, result, loaded, error } = cache;
    if (result && loaded && !error) {
      return Promise.resolve(result);
    }
    assertObject(promise);
    return promise;
  }
  media(urlPath) {
    const cache = this.loaderCache.get(urlPath);
    if (cache) {
      const { result, loaded, error } = cache;
      if (loaded || error)
        return result;
    }
  }
  parseUrlPath(id2) {
    assertPopulatedString(id2);
    const urls = urlsAbsolute(id2, this.endpoint);
    return urls.map((url) => {
      const [loaderType, options2, urlOrLoaderPath] = url;
      const loaderPath = `${loaderType}:${options2}/${urlOrLoaderPath}`;
      assertLoaderType(loaderType);
      const loaderFile = {
        loaderPath,
        urlOrLoaderPath,
        loaderType,
        options: urlOptionsObject(options2)
      };
      return loaderFile;
    });
  }
  setLoaderCache(path2, cache) {
    this.loaderCache.set(path2, cache);
  }
  sourceUrl(graphFile) {
    const cache = this.cacheGet(graphFile);
    if (!(cache == null ? void 0 : cache.loaded))
      return this.key(graphFile);
    const { type: type2 } = graphFile;
    const { result } = cache;
    assertObject(result);
    switch (type2) {
      case LoadType.Image:
      case LoadType.Video:
        return result.src;
    }
    return "";
  }
  updateDefinitionDuration(definition, duration, audio) {
    const { duration: definitionDuration } = definition;
    if (!isAboveZero(definitionDuration)) {
      definition.duration = duration;
    }
    if (audio)
      definition.audio = true;
  }
  updateDefinitionSize(definition, size, alpha) {
    const key = this.browsing ? "previewSize" : "sourceSize";
    const { [key]: definitionSize } = definition;
    if (!sizesEqual(size, definitionSize))
      definition[key] = size;
    definition.alpha || (definition.alpha = alpha);
  }
  updateDefinitionFamily(definition, family) {
    const { family: definitionFamily } = definition;
    if (!definitionFamily)
      definition.family = family;
  }
  updateCache(cache, loadedInfo) {
    cache.loadedInfo || (cache.loadedInfo = {});
    const { definitions, loadedInfo: cachedInfo } = cache;
    const { duration, width: width2, height: height2, audible, family, info, alpha } = loadedInfo;
    const size = { width: width2, height: height2 };
    const durating = isAboveZero(duration);
    const sizing = sizeAboveZero(size);
    const informing = isObject(info);
    if (sizing) {
      cachedInfo.width || (cachedInfo.width = size.width);
      cachedInfo.height || (cachedInfo.height = size.height);
    }
    if (durating) {
      if (audible)
        cachedInfo.audible = true;
      cachedInfo.duration || (cachedInfo.duration = duration);
    }
    if (family)
      cachedInfo.family || (cachedInfo.family = family);
    definitions.forEach((definition) => {
      if (informing && isPreloadableDefinition(definition))
        definition.info || (definition.info = info);
      if (sizing && isUpdatableSizeDefinition(definition)) {
        this.updateDefinitionSize(definition, size, alpha);
      }
      if (durating && isUpdatableDurationDefinition(definition)) {
        this.updateDefinitionDuration(definition, duration, audible);
      }
      if (family && isFontDefinition(definition)) {
        this.updateDefinitionFamily(definition, family);
      }
    });
  }
  updateLoaderFile(file, info) {
    const cache = this.getLoaderCache(file);
    assertObject(cache);
    this.updateCache(cache, info);
  }
  updateDefinitions(graphFile, info) {
    const cache = this.cacheGet(graphFile);
    assertObject(cache);
    this.updateCache(cache, info);
  }
  videoPromise(url) {
    return new Promise((resolve, reject) => {
      const video = this.videoFromUrl(url);
      video.oncanplay = () => {
        video.oncanplay = null;
        video.onerror = null;
        const { videoWidth, clientWidth, videoHeight, clientHeight } = video;
        const width2 = videoWidth || clientWidth;
        const height2 = videoHeight || clientHeight;
        video.width = width2;
        video.height = height2;
        resolve(video);
      };
      video.onerror = reject;
      video.autoplay = false;
      video.load();
    });
  }
  videoFromUrl(url) {
    if (!globalThis.document)
      throw "wrong environment";
    const video = globalThis.document.createElement("video");
    video.src = url;
    return video;
  }
};
var BrowserLoaderClass = class extends LoaderClass {
  constructor(endpoint) {
    super(endpoint);
    __publicField(this, "svgImageEmitsLoadEvent", false);
    __publicField(this, "seekingVideoPromise", (url, options2) => {
      assertObject(options2);
      const key = url.split(":").pop();
      assertPopulatedString(key);
      return this.copyVideoPromise(url, options2).then((video) => {
        const { frame = 0, fps } = options2;
        assertPositive(frame);
        assertPositive(fps);
        const time = timeFromArgs(frame, fps);
        return this.seekPromise(key, time, video);
      });
    });
    __publicField(this, "seekingVideoPromises", /* @__PURE__ */ new Map());
    __publicField(this, "seekingPromises", /* @__PURE__ */ new Map());
    __publicField(this, "seekingVideos", /* @__PURE__ */ new Map());
    __publicField(this, "_svgElement");
    const [canvas, context] = this.canvasContext({ width: 1, height: 1 });
    context.fillRect(0, 0, 1, 1);
    this.svgImagePromise(canvas.toDataURL()).then(() => {
      this.svgImageEmitsLoadEvent = true;
    });
  }
  absoluteUrl(path2) {
    return urlForEndpoint(this.endpoint, path2);
  }
  arrayBufferPromise(url) {
    return fetch(url).then((response) => response.arrayBuffer());
  }
  audioBufferPromise(audio) {
    return AudibleContextInstance.decode(audio);
  }
  audioInfo(buffer) {
    const { duration } = buffer;
    const info = { duration, audible: true };
    return info;
  }
  audioPromise(url) {
    assertPopulatedString(url, "url");
    const isBlob = url.startsWith("blob:");
    const promise = isBlob ? this.blobAudioPromise(url) : this.arrayBufferPromise(url);
    return promise.then((buffer) => this.audioBufferPromise(buffer));
  }
  blobAudioPromise(url) {
    return fetch(url).then((response) => response.blob()).then((blob) => {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          resolve(reader.result);
        };
        reader.onerror = reject;
        reader.readAsArrayBuffer(blob);
      });
    });
  }
  canvas(size) {
    const { width: width2, height: height2 } = size;
    const canvas = document.createElement("canvas");
    canvas.height = height2;
    canvas.width = width2;
    return canvas;
  }
  canvasContext(size) {
    const canvas = this.canvas(size);
    const context = canvas.getContext("2d");
    assertTrue(context);
    return [canvas, context];
  }
  copyVideoPromise(url, options2) {
    assertObject(options2);
    const key = url.split(":").pop();
    assertPopulatedString(key);
    const video = this.seekingVideos.get(key);
    if (video)
      return Promise.resolve(video);
    const promise = this.seekingVideoPromises.get(key);
    if (promise)
      return promise;
    const sourcePromise = this.sourcePromise(url);
    const copyPromise = sourcePromise.then((source2) => {
      return this.videoPromise(source2).then((video2) => {
        const initialSeekPromise = this.seekPromise(key, timeFromSeconds(1), video2).then(() => {
          this.seekingVideos.set(key, video2);
          return video2;
        });
        return initialSeekPromise;
      });
    });
    this.seekingVideoPromises.set(key, copyPromise);
    return copyPromise;
  }
  filePromise(file) {
    const { loaderType } = file;
    switch (loaderType) {
      case LoadType.Audio:
        return this.requestAudio(file);
      case LoadType.Font:
        return this.requestFont(file);
      case LoadType.Image:
        return this.requestImage(file);
      case LoadType.Video:
        return this.requestVideo(file);
      case GraphFileType.Svg:
        return this.requestSvgImage(file);
    }
    throw Errors.invalid.type + loaderType;
  }
  filePromises(files, size) {
    return files.map((file) => {
      const { name: label2, type: fileType } = file;
      const type2 = fileType.split("/").shift();
      const error = { label: label2, error: "" };
      if (!isUploadType(type2)) {
        return Promise.resolve({ ...error, error: "import.type", value: type2 });
      }
      const id2 = idGenerateString();
      const idKey = urlPrependProtocol("object", id2);
      const url = URL.createObjectURL(file);
      const object = {
        type: type2,
        label: label2,
        url: urlPrependProtocol(type2, idKey),
        source: url,
        id: idTemporary()
      };
      const isAudio2 = type2 === LoadType.Audio;
      const isImage = type2 === LoadType.Image;
      const hasDuration = isAudio2 || type2 === LoadType.Video;
      const hasSize = type2 === LoadType.Image || type2 === LoadType.Video;
      const mediaPromise = this.mediaPromise(type2, url);
      return mediaPromise.then((media) => {
        const info = this.mediaInfo(media);
        if (hasDuration) {
          const { duration } = info;
          if (!isAboveZero(duration))
            return {
              ...error,
              error: "import.duration",
              value: duration
            };
          object.audio = true;
          object.duration = duration;
          object.audioUrl = hasSize ? urlPrependProtocol("video", idKey) : idKey;
        }
        if (hasSize) {
          const inSize = sizeCopy(info);
          if (!sizeAboveZero(inSize))
            return {
              ...error,
              error: "import.size",
              value: sizeString(inSize)
            };
          const previewSize = size ? sizeCover(inSize, size, true) : inSize;
          const { width: width2, height: height2 } = previewSize;
          object.previewSize = previewSize;
          if (isImage) {
            object.icon = urlPrependProtocol("image", idKey, { width: width2, height: height2 });
            object.loadedImage = media;
          } else {
            object.icon = urlPrependProtocol("video", idKey, { fps: 10, frame: 10 });
            object.loadedVideo = media;
          }
        } else
          object.loadedAudio = media;
        this.loadLocalFile(media, idKey, info);
        return object;
      });
    });
  }
  fontFamily(url) {
    return url.replaceAll(/[^a-z0-9]/gi, "_");
  }
  imageInfo(size) {
    return sizeCopy(size);
  }
  key(graphFile) {
    const { file, type: type2 } = graphFile;
    if (isLoadType(type2))
      return urlForEndpoint(this.endpoint, file);
    return file;
  }
  loadLocalFile(media, cacheKey, loadedInfo) {
    const cache = {
      definitions: [],
      result: media,
      loadedInfo,
      promise: Promise.resolve(media),
      loaded: true
    };
    this.setLoaderCache(cacheKey, cache);
  }
  mediaInfo(media) {
    if (isLoadedVideo(media))
      return this.videoInfo(media);
    if (isLoadedImage(media))
      return this.imageInfo(media);
    return this.audioInfo(media);
  }
  mediaPromise(type2, url) {
    assertLoadType(type2);
    assertPopulatedString(url, "url");
    switch (type2) {
      case LoadType.Audio:
        return this.audioPromise(url);
      case LoadType.Image:
        return this.imagePromise(url);
      case LoadType.Video:
        return this.videoPromise(url);
    }
    throw Errors.internal;
  }
  requestAudio(file) {
    const { urlOrLoaderPath, options: options2 } = file;
    assertPopulatedString(urlOrLoaderPath, "urlOrLoaderPath");
    const http = urlIsHttp(urlOrLoaderPath);
    const video = http ? false : urlOrLoaderPath.startsWith("video:");
    if (!(http || video))
      return this.loadPromise(urlOrLoaderPath);
    const promise = http ? this.audioPromise(urlOrLoaderPath) : this.requestVideoAudio(file);
    return promise.then((buffer) => {
      assertObject(buffer);
      this.updateLoaderFile(file, this.audioInfo(buffer));
      return buffer;
    });
  }
  requestFont(file) {
    const { urlOrLoaderPath: url } = file;
    const bufferPromise = fetch(url).then((response) => {
      const type2 = response.headers.get("content-type");
      if (!isPopulatedString(type2) || type2.startsWith(LoadType.Font)) {
        return response.arrayBuffer();
      }
      assertTrue(type2.startsWith("text/css"));
      return response.text().then((string) => this.arrayBufferPromise(this.lastCssUrl(string)));
    });
    const family = this.fontFamily(url);
    const facePromise = bufferPromise.then((buffer) => {
      const face = new FontFace(family, buffer);
      return face.load();
    });
    return facePromise.then((face) => {
      const { fonts } = globalThis.document;
      fonts.add(face);
      return fonts.ready.then(() => {
        const info = { family };
        this.updateLoaderFile(file, info);
        return face;
      });
    });
  }
  requestImage(file) {
    const { urlOrLoaderPath } = file;
    if (!urlIsHttp(urlOrLoaderPath))
      return this.requestLoadedImage(file);
    return this.imagePromise(urlOrLoaderPath).then((image) => {
      const { width: width2, height: height2 } = image;
      const info = { width: width2, height: height2 };
      this.updateLoaderFile(file, info);
      return image;
    });
  }
  requestLoadedImage(file) {
    const { urlOrLoaderPath, options: options2 } = file;
    const promise = this.loadPromise(urlOrLoaderPath);
    const protocol = urlOrLoaderPath.split(":").shift();
    if (!(protocol === LoadType.Video || options2))
      return promise;
    return promise.then((videoOrImage) => {
      const inSize = sizeCopy(videoOrImage);
      const size = sizeAboveZero(options2) ? sizeCover(inSize, options2) : inSize;
      const { width: width2, height: height2 } = size;
      const [canvas, context] = this.canvasContext(size);
      context.drawImage(videoOrImage, 0, 0, width2, height2);
      return this.imagePromise(canvas.toDataURL());
    });
  }
  requestSvgImage(file) {
    const { urlOrLoaderPath, options: options2 } = file;
    return this.sourcePromise(urlOrLoaderPath).then((src) => {
      const promise = this.svgImagePromise(src);
      if (!options2) {
        return promise;
      }
      return promise.then((item) => {
        const { lock, ...rest } = options2;
        const lockDefined = isOrientation(lock) ? lock : void 0;
        svgSetDimensionsLock(item, rest, lockDefined);
        return item;
      });
    });
  }
  requestVideo(file) {
    const { urlOrLoaderPath, options: options2 } = file;
    urlIsObject(urlOrLoaderPath);
    const isHttp = urlIsHttp(urlOrLoaderPath);
    if (options2) {
      return this.seekingVideoPromise(urlOrLoaderPath, options2);
    } else if (isHttp) {
      return this.videoPromise(urlOrLoaderPath).then((video) => {
        const info = this.videoInfo(video);
        this.updateLoaderFile(file, info);
        return video;
      });
    }
    return this.loadPromise(urlOrLoaderPath);
  }
  requestVideoAudio(file) {
    const { urlOrLoaderPath } = file;
    const videoPromise = this.loadPromise(urlOrLoaderPath);
    const audioPromise = videoPromise.then((video) => {
      const { src } = video;
      assertPopulatedString(src);
      return this.audioPromise(src);
    });
    return audioPromise;
  }
  seek(definitionTime, video) {
    if (!video)
      throw Errors.internal + "seek";
    video.currentTime = definitionTime.seconds;
  }
  seekNeeded(definitionTime, video) {
    const { currentTime } = video;
    if (!(currentTime || definitionTime.frame))
      return true;
    const videoTime = timeFromSeconds(currentTime, definitionTime.fps);
    return !videoTime.equalsTime(definitionTime);
  }
  seekPromise(key, definitionTime, video) {
    const promise = new Promise((resolve) => {
      if (!this.seekNeeded(definitionTime, video)) {
        this.seekingPromises.delete(key);
        return resolve(video);
      }
      video.onseeked = () => {
        video.onseeked = null;
        this.seekingPromises.delete(key);
        resolve(video);
      };
      this.seek(definitionTime, video);
    });
    const existing = this.seekingPromises.get(key);
    this.seekingPromises.set(key, promise);
    if (existing)
      return existing.then(() => promise);
    return promise;
  }
  sourcePromise(path2) {
    if (urlIsHttp(path2))
      return Promise.resolve(path2);
    return this.loadPromise(path2).then((loaded) => {
      assertObject(loaded);
      const { src } = loaded;
      assertPopulatedString(src);
      return src;
    });
  }
  get svgElement() {
    return this._svgElement || (this._svgElement = svgElement());
  }
  set svgElement(value) {
    this._svgElement = value;
  }
  svgImagePromise(url) {
    return new Promise((resolve, reject) => {
      const element = svgImageElement();
      const completed = () => {
        element.removeEventListener("error", failed);
        element.removeEventListener("load", passed);
        if (!this.svgImageEmitsLoadEvent)
          this.svgElement.removeChild(element);
      };
      const failed = (error) => {
        completed();
        reject(error);
      };
      const passed = () => {
        completed();
        resolve(element);
      };
      element.addEventListener("error", failed, { once: true });
      element.addEventListener("load", passed, { once: true });
      if (!this.svgImageEmitsLoadEvent)
        this.svgElement.appendChild(element);
      svgSet(element, url, "href");
    });
  }
  videoInfo(video) {
    var _a;
    const { duration, videoWidth, clientWidth, videoHeight, clientHeight } = video;
    const width2 = videoWidth || clientWidth;
    const height2 = videoHeight || clientHeight;
    const object = video;
    let audible = object.mozHasAudio;
    audible || (audible = Boolean(object.webkitAudioDecodedByteCount));
    audible || (audible = Boolean((_a = object.audioTracks) == null ? void 0 : _a.length));
    if (!audible)
      console.log(Object.values(video));
    const info = { width: width2, height: height2, duration, audible };
    return info;
  }
};
var EditorSelectionClass = class {
  constructor() {
    __publicField(this, "_editor");
    __publicField(this, "_focus", SelectType.Mash);
    __publicField(this, "_object", {});
  }
  get [SelectType.None]() {
    return void 0;
  }
  get [SelectType.Cast]() {
    const { cast } = this._object;
    if (isCast(cast))
      return cast;
  }
  get [SelectType.Clip]() {
    const { clip } = this._object;
    if (isClip(clip))
      return clip;
  }
  get [SelectType.Layer]() {
    const { layer } = this._object;
    if (isLayer(layer))
      return layer;
  }
  get [SelectType.Mash]() {
    const { mash } = this._object;
    if (isMash(mash))
      return mash;
    const { layer } = this;
    if (isLayerMash(layer))
      return layer.mash;
  }
  get [SelectType.Track]() {
    const { clip, track } = this._object;
    if (isTrack(track))
      return track;
    if (isClip(clip))
      return clip.track;
  }
  get [SelectType.Container]() {
    const { clip } = this._object;
    if (isClip(clip))
      return clip.container;
  }
  get [SelectType.Content]() {
    const { clip } = this._object;
    if (isClip(clip))
      return clip.content;
  }
  get [SelectType.Effect]() {
    const { effect } = this._object;
    if (isEffect(effect))
      return effect;
  }
  get editor() {
    return this._editor;
  }
  set editor(value) {
    this._editor = value;
  }
  get focus() {
    return this._focus;
  }
  set focus(value) {
    this._focus = value;
  }
  get(selectType) {
    return this[selectType];
  }
  unset(selectType) {
    const selectable = this.object[selectType];
    if (!selectable)
      return;
    const selectables = selectable.selectables();
    assertTrue(selectables[0] === selectable);
    selectables.shift();
    this.object = this.selectionFromSelectables(selectables);
  }
  set(selectable) {
    const { selectType } = selectable;
    this.object = { [selectType]: selectable };
  }
  get object() {
    return Object.fromEntries(SelectTypes.map((selectType) => [selectType, this.get(selectType)]));
  }
  set object(selection) {
    const populated = this.selectionPopulated(selection);
    const { object: originalObject } = this;
    this.clear();
    Object.assign(this._object, populated);
    const { object: newObject } = this;
    const { mash: oldMash, cast: oldCast, clip: oldClip } = originalObject;
    const { mash, cast, clip } = newObject;
    if (clip !== oldClip) {
      if (isClip(clip) && isPositive(clip.trackNumber))
        clip.track.mash.clearPreview();
      if (isClip(oldClip) && isPositive(oldClip.trackNumber))
        oldClip.track.mash.clearPreview();
    }
    Object.assign(this._object, populated);
    this.editor.eventTarget.emit(EventType.Selection);
    if (cast !== oldCast)
      this.editor.eventTarget.emit(EventType.Cast);
    if (mash !== oldMash) {
      this.editor.eventTarget.emit(EventType.Mash);
      this.editor.eventTarget.emit(EventType.Track);
      this.editor.eventTarget.emit(EventType.Duration);
    }
  }
  clear() {
    SelectTypes.forEach((selectType) => {
      delete this._object[selectType];
    });
  }
  selectionFromSelectables(selectables) {
    return Object.fromEntries(selectables.map((selectable) => [selectable.selectType, selectable]));
  }
  selectionPopulated(selection) {
    const { mash: mashOld, object } = this;
    const { cast: castOld } = object;
    const { clip, track, layer, cast, mash, effect } = selection;
    const target = effect || clip || track || mash || layer || cast || castOld || mashOld;
    assertTrue(target, "target");
    return this.selectionFromSelectables(target.selectables());
  }
  get selectTypes() {
    const selectTypes = [];
    const { mash, object } = this;
    const { clip, track, cast, layer, effect } = object;
    if (cast) {
      selectTypes.push(SelectType.Cast);
      if (layer)
        selectTypes.push(SelectType.Layer);
    }
    if (!mash)
      return selectTypes;
    if (!cast)
      selectTypes.push(SelectType.Mash);
    if (!track)
      return selectTypes;
    selectTypes.push(SelectType.Track);
    if (!isClip(clip))
      return selectTypes;
    selectTypes.push(SelectType.Clip);
    selectTypes.push(SelectType.Content);
    if (isEffect(effect))
      selectTypes.push(SelectType.Effect);
    if (isPopulatedString(clip.containerId)) {
      selectTypes.push(SelectType.Container);
    }
    return selectTypes;
  }
  selectedItems(types = SelectTypes) {
    const { selectTypes, object: selection } = this;
    const filteredTypes = selectTypes.filter((type2) => types.includes(type2));
    const { clip } = selection;
    return filteredTypes.flatMap((type2) => {
      let target = selection[type2];
      if (isClipSelectType(type2) && isClip(clip))
        target = clip[type2];
      assertTrue(target, type2);
      return target.selectedItems(this.editor.actions);
    });
  }
};
var editorSelectionInstance = () => {
  return new EditorSelectionClass();
};
var isVideoDefinition = (value) => {
  return isDefinition(value) && value.type === DefinitionType.Video;
};
var isVideo = (value) => {
  return isInstance(value) && value.definition.type === DefinitionType.Video;
};
function assertVideo(value) {
  if (!isVideo(value))
    throw new Error("expected Video");
}
var isImageDefinition = (value) => {
  return isDefinition(value) && value.type === DefinitionType.Image;
};
var EditorClass = class {
  constructor(args) {
    __publicField(this, "actions");
    __publicField(this, "autoplay", Default.editor.autoplay);
    __publicField(this, "_buffer", Default.editor.buffer);
    __publicField(this, "dragging", false);
    __publicField(this, "drawTimeout");
    __publicField(this, "_editType");
    __publicField(this, "editedData");
    __publicField(this, "editing");
    __publicField(this, "eventTarget", new Emitter());
    __publicField(this, "_fps", Default.editor.fps);
    __publicField(this, "_loop", Default.editor.loop);
    __publicField(this, "_muted", false);
    __publicField(this, "precision", Default.editor.precision);
    __publicField(this, "preloader");
    __publicField(this, "readOnly", false);
    __publicField(this, "_rect");
    __publicField(this, "_selection");
    __publicField(this, "_volume", Default.editor.volume);
    const { autoplay, precision, loop, fps, volume, buffer, endpoint, preloader, editType, readOnly, dimensions, edited } = args;
    const point = isPoint(dimensions) ? pointCopy(dimensions) : PointZero;
    const size = isSize(dimensions) ? sizeCopy(dimensions) : SizeZero;
    this._rect = { ...point, ...size };
    if (isEditType(editType))
      this._editType = editType;
    if (readOnly)
      this.readOnly = true;
    this.editing = !this.readOnly;
    if (isBoolean(autoplay))
      this.autoplay = autoplay;
    if (isNumber(precision))
      this.precision = precision;
    if (isBoolean(loop))
      this._loop = loop;
    if (isNumber(fps))
      this._fps = fps;
    if (isNumber(volume))
      this._volume = volume;
    if (isNumber(buffer))
      this._buffer = buffer;
    this.actions = new Actions(this);
    this.preloader = preloader || new BrowserLoaderClass(endpoint);
    if (edited)
      this.load(edited);
  }
  add(object, editorIndex) {
    const objects = isArray(object) ? object : [object];
    if (!objects.length)
      return Promise.resolve([]);
    const definitions = objects.map((definitionObject) => {
      assertPopulatedObject(definitionObject);
      return Defined.fromObject(definitionObject);
    });
    if (!editorIndex)
      return Promise.resolve(definitions);
    const clips = definitions.map((definition) => {
      const { id: id2, type: type2 } = definition;
      const clipObject = {};
      if (isContentDefinition(definition))
        clipObject.contentId = id2;
      else
        clipObject.containerId = id2;
      if (type2 === DefinitionType.Audio)
        clipObject.containerId = "";
      return clipDefault.instanceFromObject(clipObject);
    });
    const options2 = { editing: true, duration: true };
    const unknownClips = clips.filter((clip) => clip.intrinsicsKnown(options2));
    const files = unknownClips.flatMap((clip) => clip.intrinsicGraphFiles(options2));
    const { preloader } = this;
    const promise = preloader.loadFilesPromise(files);
    return promise.then(() => {
      return this.addClip(clips, editorIndex).then(() => definitions);
    });
  }
  addClip(clip, editorIndex) {
    const { clip: frameOrIndex = 0, track: trackIndex = 0 } = editorIndex;
    const clips = isArray(clip) ? clip : [clip];
    const [firstClip] = clips;
    if (!firstClip)
      return Promise.resolve();
    const promise = this.assureMash(clip);
    return promise.then(() => {
      const { mash } = this.selection;
      assertMash(mash);
      const { tracks } = mash;
      const { length: length2 } = tracks;
      assertAboveZero(length2);
      const trackPositive = isPositive(trackIndex);
      const track = trackPositive ? tracks[trackIndex] : void 0;
      const trackClips = (track == null ? void 0 : track.clips) || [];
      const dense = track == null ? void 0 : track.dense;
      const redoSelection = {
        ...this.selection.object,
        clip: firstClip
      };
      const createTracks = trackPositive ? 0 : clips.length;
      const options2 = {
        clips,
        type: ActionType.AddClipToTrack,
        trackIndex,
        redoSelection,
        createTracks
      };
      if (dense) {
        const insertIndex = isPositive(frameOrIndex) ? frameOrIndex : trackClips.length;
        options2.insertIndex = insertIndex;
      } else {
        if (createTracks)
          options2.redoFrame = isPositive(frameOrIndex) ? frameOrIndex : 0;
        else {
          assertTrack(track);
          const frame = isPositive(frameOrIndex) ? frameOrIndex : track.frames;
          options2.redoFrame = track.frameForClipNearFrame(firstClip, frame);
        }
      }
      this.actions.create(options2);
      return this.loadMashAndDraw();
    });
  }
  addEffect(effect, insertIndex = 0) {
    const { clip } = this.selection;
    if (!isClip(clip)) {
      console.error(this.constructor.name, "addEffect expected effectable selection");
      throw Errors.selection + "effectable";
    }
    const { content } = clip;
    assertContent(content);
    const { effects } = content;
    if (!effects)
      throw Errors.selection;
    const undoEffects = [...effects];
    const redoEffects = [...effects];
    redoEffects.splice(insertIndex, 0, effect);
    const redoSelection = { ...this.selection.object, effect };
    const options2 = {
      effects,
      undoEffects,
      redoEffects,
      redoSelection,
      type: ActionType.MoveEffect
    };
    this.actions.create(options2);
    return this.loadMashAndDraw();
  }
  addFiles(files, editorIndex) {
    const { preloader, eventTarget, rect } = this;
    let promise = Promise.resolve([]);
    preloader.filePromises(files, rect).forEach((filePromise) => {
      promise = promise.then((objects) => {
        const id2 = idGenerate("activity");
        const info = { id: id2, type: ActivityType.Analyze };
        eventTarget.emit(EventType.Active, info);
        return filePromise.then((definitionOrError) => {
          const activityInfo = { ...info };
          const { label: label2 } = definitionOrError;
          activityInfo.label = label2;
          if (isDefinitionObject(definitionOrError)) {
            objects.push(definitionOrError);
            const { url, type: type2 } = definitionOrError;
            assertPopulatedString(url);
            const info2 = preloader.info(url);
            assertObject(info2);
            activityInfo.type = ActivityType.Complete;
            activityInfo.value = info2;
          } else {
            const { error, value } = definitionOrError;
            activityInfo.type = ActivityType.Error;
            activityInfo.error = error;
            activityInfo.value = value;
          }
          eventTarget.emit(EventType.Active, activityInfo);
          return objects;
        });
      });
    });
    return promise.then((objects) => {
      return this.add(objects, editorIndex).then((definitions) => {
        if (definitions.length) {
          const definitionTypes = arrayUnique(definitions.map((object) => object.type));
          this.eventTarget.emit(EventType.Added, { definitionTypes });
        }
        return definitions;
      });
    });
  }
  addFolder(label2, layerAndPosition) {
    const { cast } = this.selection;
    assertCast(cast);
    const layer = cast.createLayer({ type: LayerType.Folder, label: label2 });
    assertLayerFolder(layer);
    const redoSelection = { cast, layer };
    const options2 = {
      type: ActionType.AddLayer,
      redoSelection,
      layerAndPosition
    };
    this.actions.create(options2);
  }
  addMash(mashAndDefinitions, layerAndPosition) {
    const { cast } = this.selection;
    assertCast(cast);
    const mashObject = (mashAndDefinitions == null ? void 0 : mashAndDefinitions.mashObject) || {};
    const definitionObjects = (mashAndDefinitions == null ? void 0 : mashAndDefinitions.definitionObjects) || [];
    Defined.define(...definitionObjects);
    const layerObject = { type: LayerType.Mash, mash: mashObject };
    const layer = cast.createLayer(layerObject);
    assertLayerMash(layer);
    const { mash } = layer;
    this.configureMash(mash);
    const redoSelection = { cast, layer, mash };
    const options2 = {
      type: ActionType.AddLayer,
      redoSelection,
      layerAndPosition
    };
    this.actions.create(options2);
  }
  addTrack() {
    const { mash, cast } = this.selection;
    const redoSelection = { mash, cast };
    this.actions.create({
      redoSelection,
      type: ActionType.AddTrack,
      createTracks: 1
    });
  }
  assureMash(clip) {
    const { selection, editType } = this;
    const { mash } = selection;
    if (!isMash(mash)) {
      const first = isArray(clip) ? clip[0] : clip;
      const { label: label2 } = first.content.definition;
      const mashObject = { label: label2 };
      if (editType === EditType.Mash)
        return this.load({ mash: mashObject });
      this.addMash({ mashObject, definitionObjects: [] });
    }
    return Promise.resolve();
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(value) {
    const number = Number(value);
    if (this._buffer !== number) {
      this._buffer = number;
      const { edited } = this;
      if (edited)
        edited.buffer = number;
    }
  }
  can(masherAction) {
    const { selection } = this;
    const { track, clip, mash, layer } = selection;
    switch (masherAction) {
      case MasherAction.Save:
        return this.actions.canSave;
      case MasherAction.Undo:
        return this.actions.canUndo;
      case MasherAction.Redo:
        return this.actions.canRedo;
      case MasherAction.Remove:
        return !!(clip || track || layer);
      case MasherAction.Render:
        return !this.actions.canSave && !!((mash == null ? void 0 : mash.id) && !idIsTemporary(mash.id));
      default:
        throw Errors.argument + "can";
    }
  }
  castDestroy() {
    const { cast } = this.selection;
    if (!cast)
      return false;
    cast.destroy();
    this.preloader.flushFilesExcept();
    return true;
  }
  clearActions() {
    if (!this.actions.instances.length)
      return;
    this.actions = new Actions(this);
    this.eventTarget.emit(EventType.Action);
  }
  get clips() {
    return this.selection.mash.clips;
  }
  configureCast(cast) {
    this.configureEdited(cast);
    return cast.loadPromise({ editing: true, visible: true }).then(() => {
      this.selection.set(cast);
      this.handleDraw();
    });
  }
  configureEdited(edited) {
    edited.editor = this;
    const { rect } = this;
    if (sizeAboveZero(rect))
      edited.imageSize = sizeCopy(rect);
    edited.emitter = this.eventTarget;
  }
  configureMash(mash) {
    mash.buffer = this.buffer;
    mash.gain = this.gain;
    mash.loop = this.loop;
    this.configureEdited(mash);
    return mash.loadPromise({ editing: true, visible: true }).then(() => {
      this.selection.set(mash);
      this.handleDraw();
    });
  }
  create() {
    this.load({ [this.editType]: {} });
  }
  get currentTime() {
    const { mash } = this.selection;
    if (mash && mash.drawnTime)
      return mash.drawnTime.seconds;
    return 0;
  }
  dataPutRequest() {
    const { edited, editType } = this;
    assertObject(edited);
    assertEditType(editType);
    const { label: label2 } = edited;
    if (!isPopulatedString(label2)) {
      const defaultLabel = Default[editType].label;
      assertPopulatedString(defaultLabel, "defaultLabel");
      edited.setValue(defaultLabel, "label");
    }
    return edited.putPromise().then(() => {
      if (isMash(edited)) {
        return {
          mash: edited.toJSON(),
          definitionIds: edited.definitionIds
        };
      }
      if (isCast(edited)) {
        return {
          cast: edited.toJSON(),
          definitionIds: Object.fromEntries(edited.mashes.map((mash) => [mash.id, mash.definitionIds]))
        };
      }
      throw new Error(Errors.internal);
    });
  }
  define(objectOrArray) {
    const objects = Array.isArray(objectOrArray) ? objectOrArray : [objectOrArray];
    objects.forEach((object) => {
      const { id: id2, type: type2 } = object;
      assertPopulatedString(id2, "define id");
      if (Defined.fromId(id2)) {
        console.warn(this.constructor.name, "define NOT redefining", id2);
        return;
      }
      assertDefinitionType(type2);
      const definition = Factory[type2].definition(object);
      Defined.install(definition);
    });
  }
  get definitions() {
    const { mashes } = this;
    const ids = [...new Set(mashes.flatMap((mash) => mash.definitionIds))];
    const definitions = ids.map((id2) => Defined.fromId(id2));
    return definitions;
  }
  get definitionsUnsaved() {
    const { definitions } = this;
    return definitions.filter((definition) => {
      const { type: type2, id: id2 } = definition;
      if (!isLoadType(type2))
        return false;
      return idIsTemporary(id2);
    });
  }
  destroy() {
    if (!this.castDestroy())
      this.mashDestroy();
  }
  get duration() {
    var _a;
    return ((_a = this.selection.mash) == null ? void 0 : _a.duration) || 0;
  }
  get editType() {
    if (!this._editType)
      this._editType = this.editingCast ? EditType.Cast : EditType.Mash;
    return this._editType;
  }
  get edited() {
    return this.selection.cast || this.selection.mash;
  }
  get editingCast() {
    return !!this.selection.cast;
  }
  get endTime() {
    const { mash } = this.selection;
    return mash ? mash.endTime.scale(this.fps, "floor") : timeFromArgs();
  }
  get fps() {
    var _a;
    return this._fps || ((_a = this.selection.mash) == null ? void 0 : _a.quantize) || Default.editor.fps;
  }
  set fps(value) {
    const number = Number(value);
    if (this._fps !== number) {
      this._fps = number;
      this.eventTarget.emit(EventType.Fps);
      this.time = this.time.scale(this.fps);
    }
  }
  get frame() {
    return this.time.frame;
  }
  set frame(value) {
    this.goToTime(timeFromArgs(Number(value), this.fps));
  }
  get frames() {
    return this.endTime.frame;
  }
  get gain() {
    return this.muted ? 0 : this.volume;
  }
  goToTime(value) {
    var _a;
    const { fps, time } = this;
    const { frame: currentFrame } = time;
    const goTime = value ? value.scaleToFps(fps) : timeFromArgs(0, fps);
    const { frame: attemptFrame } = goTime;
    const { frame: endFrame } = this.endTime;
    const lastFrame = endFrame - 1;
    const goFrame = lastFrame < 1 ? 0 : Math.min(attemptFrame, lastFrame);
    if (value && currentFrame === goFrame)
      return Promise.resolve();
    const promise = (_a = this.selection.mash) == null ? void 0 : _a.seekToTime(timeFromArgs(goFrame, fps));
    if (promise)
      return promise;
    return Promise.resolve();
  }
  handleAction(action) {
    const { edited } = this;
    assertTrue(edited);
    const { selection } = action;
    const { mash } = selection;
    if (isMash(mash)) {
      mash.clearPreview();
      if (action instanceof ChangeAction) {
        const { property, target } = action;
        switch (property) {
          case "gain": {
            if (isClip(target)) {
              mash.composition.adjustClipGain(target, mash.quantize);
            }
            break;
          }
        }
      }
    }
    this.selection.object = selection;
    const promise = edited.reload() || Promise.resolve();
    promise.then(() => {
      if (!mash)
        this.handleDraw();
      this.eventTarget.emit(EventType.Action, { action });
    });
  }
  handleDraw(event) {
    var _a;
    if (this.drawTimeout || !((_a = this.edited) == null ? void 0 : _a.loading))
      return;
    this.drawTimeout = setTimeout(() => {
      this.eventTarget.dispatch(EventType.Draw);
      delete this.drawTimeout;
    }, 10);
  }
  load(data) {
    this.editedData = data;
    return this.loadEditedData();
  }
  loadCastData(data = {}) {
    const { cast: castObject = {}, definitions: definitionObjects = [] } = data;
    Defined.undefineAll();
    Defined.define(...definitionObjects);
    this.eventTarget.trap(EventType.Draw, this.handleDraw.bind(this));
    const cast = castInstance(castObject, this.preloader);
    return this.configureCast(cast);
  }
  loadEditedData() {
    const { rect, editedData: data } = this;
    if (!sizeAboveZero(rect)) {
      return Promise.resolve();
    }
    assertObject(data);
    delete this.editedData;
    this.destroy();
    this.paused = true;
    this.clearActions();
    this.selection.clear();
    if (isCastData(data))
      return this.loadCastData(data);
    assertMashData(data);
    return this.loadMashData(data).then(() => {
      return this.goToTime().then(() => {
        const { edited: mash } = this;
        if (isMash(mash))
          mash.clearPreview();
        if (this.autoplay)
          this.paused = false;
      });
    });
  }
  loadMashAndDraw() {
    const { mash } = this.selection;
    if (!mash)
      throw new Error(Errors.selection);
    const args = { editing: true, visible: true };
    if (!this.paused)
      args.audible = true;
    return mash.loadPromise(args).then(() => {
      mash.draw();
    });
  }
  loadMashData(data = {}) {
    const { mash: mashObject = {}, definitions: definitionObjects = [] } = data;
    Defined.undefineAll();
    Defined.define(...definitionObjects);
    const mash = mashInstance({ ...mashObject, preloader: this.preloader });
    this.mashDestroy();
    return this.configureMash(mash);
  }
  get loop() {
    return this._loop;
  }
  set loop(value) {
    const boolean = !!value;
    this._loop = boolean;
    const { mash } = this.selection;
    if (mash)
      mash.loop = boolean;
  }
  mashDestroy() {
    const { mash } = this.selection;
    if (!mash)
      return false;
    mash.destroy();
    this.preloader.flushFilesExcept();
    return true;
  }
  get mashes() {
    const { edited } = this;
    if (!edited)
      return [];
    return isCast(edited) ? edited.mashes : [edited];
  }
  move(object, editorIndex = {}) {
    assertPopulatedObject(object, "clip");
    if (isClip(object)) {
      this.moveClip(object, editorIndex);
      return;
    }
    assertEffect(object);
    const { clip: frameOrIndex = 0 } = editorIndex;
    this.moveEffect(object, frameOrIndex);
  }
  moveClip(clip, editorIndex = {}) {
    assertClip(clip);
    const { clip: frameOrIndex = 0, track = 0 } = editorIndex;
    assertPositive(frameOrIndex);
    const { mash } = this.selection;
    assertMash(mash);
    const { tracks } = mash;
    const { trackNumber: undoTrack } = clip;
    const options2 = {
      clip,
      trackIndex: track,
      undoTrackIndex: undoTrack,
      type: ActionType.MoveClip
    };
    const creating = !isPositive(track);
    if (creating)
      options2.createTracks = 1;
    const undoDense = isPositive(undoTrack) && tracks[undoTrack].dense;
    const redoDense = isPositive(track) && tracks[track].dense;
    const currentIndex = creating ? -1 : tracks[track].clips.indexOf(clip);
    if (redoDense)
      options2.insertIndex = frameOrIndex;
    if (undoDense) {
      options2.undoInsertIndex = currentIndex;
      if (frameOrIndex < currentIndex)
        options2.undoInsertIndex += 1;
    }
    if (!(redoDense && undoDense)) {
      const { frame } = clip;
      const insertFrame = creating ? 0 : tracks[track].frameForClipNearFrame(clip, frameOrIndex);
      const offset2 = insertFrame - frame;
      if (!offset2 && track === undoTrack)
        return;
      options2.undoFrame = frame;
      options2.redoFrame = frame + offset2;
    }
    this.actions.create(options2);
  }
  moveEffect(effect, index = 0) {
    if (!isPositive(index))
      throw Errors.argument + "index";
    const { clip } = this.selection;
    if (!clip)
      throw Errors.selection;
    assertClip(clip);
    const effectable = clip.content;
    assertContent(effectable);
    const { effects } = effectable;
    const undoEffects = [...effects];
    const redoEffects = undoEffects.filter((e) => e !== effect);
    const currentIndex = undoEffects.indexOf(effect);
    const insertIndex = currentIndex < index ? index - 1 : index;
    redoEffects.splice(insertIndex, 0, effect);
    const options2 = {
      effects,
      undoEffects,
      redoEffects,
      type: ActionType.MoveEffect,
      effectable
    };
    this.actions.create(options2);
  }
  moveLayer(layer, layerAndPosition) {
    const { cast } = this.selection;
    assertCast(cast);
    assertLayer(layer);
    const redoSelection = { cast, layer };
    const options2 = { type: ActionType.MoveLayer, redoSelection, layerAndPosition };
    this.actions.create(options2);
  }
  moveTrack() {
    console.debug(this.constructor.name, "moveTrack coming soon...");
  }
  get muted() {
    return this._muted;
  }
  set muted(value) {
    const boolean = !!value;
    if (this._muted !== boolean) {
      this._muted = boolean;
      const { mash } = this.selection;
      if (mash)
        mash.gain = this.gain;
    }
  }
  pause() {
    this.paused = true;
  }
  get paused() {
    const { mash } = this.selection;
    return mash ? mash.paused : true;
  }
  set paused(value) {
    const { mash } = this.selection;
    if (mash)
      mash.paused = value;
    if (value)
      this.redraw();
  }
  play() {
    this.paused = false;
  }
  get position() {
    let per = 0;
    if (this.time.frame) {
      per = this.time.seconds / this.duration;
      if (per !== 1)
        per = parseFloat(per.toFixed(this.precision));
    }
    return per;
  }
  set position(value) {
    this.goToTime(timeFromSeconds(this.duration * Number(value), this.fps));
  }
  get positionStep() {
    return parseFloat(`0.${"0".repeat(this.precision - 1)}1`);
  }
  get rect() {
    return this._rect;
  }
  set rect(value) {
    assertSizeAboveZero(value);
    const { editedData, rect } = this;
    if (rectsEqual(rect, value))
      return;
    this._rect = value;
    const promise = editedData ? this.loadEditedData() : Promise.resolve();
    promise.then(() => {
      const { edited, rect: rect2, eventTarget } = this;
      if (!isEdited(edited))
        return;
      edited.imageSize = sizeCopy(rect2);
      eventTarget.emit(EventType.Resize, { rect: value });
      this.redraw();
    });
  }
  redo() {
    if (this.actions.canRedo)
      this.handleAction(this.actions.redo());
  }
  redraw() {
    const { edited } = this;
    if (!edited)
      return;
    edited.mashes.forEach((mash) => {
      mash.clearPreview();
    });
    this.eventTarget.dispatch(EventType.Draw);
  }
  removeClip(clip) {
    const { mash } = this.selection;
    if (!mash)
      throw new Error(Errors.selection);
    const { track } = clip;
    const redoSelection = {
      ...this.selection,
      clip: void 0
    };
    const options2 = {
      redoSelection,
      clip,
      track,
      index: track.clips.indexOf(clip),
      type: ActionType.RemoveClip
    };
    this.actions.create(options2);
  }
  removeEffect(effect) {
    const { clip } = this.selection;
    if (!clip)
      throw Errors.selection;
    assertClip(clip);
    const { content } = clip;
    assertContent(content);
    const { effects } = content;
    const undoEffects = [...effects];
    const redoEffects = effects.filter((other) => other !== effect);
    const redoSelection = {
      ...this.selection.object
    };
    delete redoSelection.effect;
    const options2 = {
      redoSelection,
      effects,
      undoEffects,
      redoEffects,
      type: ActionType.MoveEffect
    };
    this.actions.create(options2);
  }
  removeLayer(layer) {
    const { cast } = this.selection;
    assertCast(cast);
    const redoSelection = { cast, layer };
    this.actions.create({ type: ActionType.RemoveLayer, redoSelection });
  }
  removeTrack(track) {
    console.debug(this.constructor.name, "removeTrack coming soon...");
  }
  saved(temporaryIdLookup) {
    if (temporaryIdLookup) {
      const { edited } = this;
      assertTrue(edited);
      Object.entries(temporaryIdLookup).forEach(([temporaryId, permanentId]) => {
        if (edited.id === temporaryId) {
          edited.id = permanentId;
          return;
        }
        if (Defined.installed(temporaryId)) {
          Defined.updateDefinitionId(temporaryId, permanentId);
          return;
        }
        assertCast(edited);
        const mash = edited.mashes.find((mash2) => mash2.id === temporaryId);
        assertMash(mash);
        mash.id = permanentId;
      });
    }
    this.actions.save();
    this.eventTarget.emit(EventType.Action);
  }
  get selection() {
    if (this._selection)
      return this._selection;
    const selection = editorSelectionInstance();
    selection.editor = this;
    return this._selection = selection;
  }
  get svgElement() {
    return this.preloader.svgElement;
  }
  set svgElement(value) {
    this.preloader.svgElement = value;
  }
  previewItems(enabled) {
    const { edited } = this;
    if (!edited) {
      return Promise.resolve([svgElement(this.rect)]);
    }
    const options2 = {};
    if (enabled && this.paused)
      options2.editor = this;
    return edited.previewItems(options2);
  }
  get time() {
    var _a;
    return ((_a = this.selection.mash) == null ? void 0 : _a.time) || timeFromArgs(0, this.fps);
  }
  set time(value) {
    this.goToTime(value);
  }
  get timeRange() {
    var _a;
    return ((_a = this.selection.mash) == null ? void 0 : _a.timeRange) || timeRangeFromArgs(0, this.fps);
  }
  undo() {
    const { canUndo } = this.actions;
    if (canUndo)
      this.handleAction(this.actions.undo());
  }
  updateDefinition(definitionObject, definition) {
    const { id: newId, type: newType } = definitionObject;
    const id2 = definitionObject.id || definition.id;
    assertPopulatedString(id2);
    const target = definition || Defined.fromId(newId);
    const { id: oldId, type: oldType } = target;
    const idChanged = oldId !== id2;
    const typeChanged = isDefinitionType(newType) && oldType !== newType;
    if (typeChanged) {
      const newDefinition = Factory[newType].definition(definitionObject);
      Defined.updateDefinition(target, newDefinition);
    } else if (idChanged) {
      Defined.updateDefinitionId(target.id, id2);
      Object.assign(target, definitionObject);
      if (isVideoDefinition(target))
        delete target.loadedVideo;
      else if (isUpdatableDurationDefinition(target))
        delete target.loadedAudio;
      else if (isImageDefinition(target))
        delete target.loadedImage;
    }
    const { edited } = this;
    if (!(edited && (typeChanged || idChanged)))
      return Promise.resolve();
    const tracks = this.mashes.flatMap((mash) => mash.tracks);
    const clips = tracks.flatMap((track) => track.clips);
    clips.forEach((clip) => {
      if (clip.containerId === oldId)
        clip.setValue(newId, "containerId");
      if (clip.contentId === oldId)
        clip.setValue(newId, "contentId");
    });
    return this.loadMashAndDraw();
  }
  get volume() {
    return this._volume;
  }
  set volume(value) {
    const number = Number(value);
    if (this._volume !== number) {
      if (!isPositive(number))
        throw Errors.invalid.volume;
      this._volume = number;
      if (isAboveZero(number))
        this.muted = false;
      const { mash } = this.selection;
      if (mash)
        mash.gain = this.gain;
      this.eventTarget.emit(EventType.Volume);
    }
  }
};
var editorSingleton;
var editorArgs = (options2 = {}) => {
  return {
    autoplay: Default.editor.autoplay,
    precision: Default.editor.precision,
    loop: Default.editor.loop,
    fps: Default.editor.fps,
    volume: Default.editor.volume,
    buffer: Default.editor.buffer,
    ...options2
  };
};
var editorInstance = (options2 = {}) => {
  return editorSingleton = new EditorClass(editorArgs(options2));
};
var AudioWithTweenable = TweenableMixin(InstanceBase);
var AudioWithContent = ContentMixin(AudioWithTweenable);
var AudioWithPreloadable = PreloadableMixin(AudioWithContent);
var AudioWithUpdatableDuration = UpdatableDurationMixin(AudioWithPreloadable);
var AudioClass = class extends AudioWithUpdatableDuration {
  contentPreviewItemPromise(containerRect, time, range, icon) {
    return Promise.resolve(svgPolygonElement(containerRect, "", "currentColor"));
  }
  mutable() {
    return true;
  }
};
var AudioDefinitionWithTweenable = TweenableDefinitionMixin(DefinitionBase);
var AudioDefinitionWithContent = ContentDefinitionMixin(AudioDefinitionWithTweenable);
var AudioDefinitionWithPreloadable = PreloadableDefinitionMixin(AudioDefinitionWithContent);
var AudioDefinitionWithUpdatableDuration = UpdatableDurationDefinitionMixin(AudioDefinitionWithPreloadable);
var AudioDefinitionClass = class extends AudioDefinitionWithUpdatableDuration {
  constructor(...args) {
    super(...args);
    __publicField(this, "type", DefinitionType.Audio);
    __publicField(this, "loadType", LoadType.Audio);
    const [object] = args;
    const { audioUrl, url } = object;
    if (!audioUrl && url)
      this.audioUrl = url;
  }
  instanceFromObject(object = {}) {
    return new AudioClass(this.instanceArgs(object));
  }
};
var audioDefinition = (object) => {
  const { id: id2 } = object;
  if (!id2)
    throw Errors.id;
  return new AudioDefinitionClass(object);
};
var audioDefinitionFromId = (id2) => {
  return audioDefinition({ id: id2 });
};
var audioInstance = (object) => {
  const definition = audioDefinition(object);
  const instance = definition.instanceFromObject(object);
  return instance;
};
var audioFromId = (id2) => {
  return audioInstance({ id: id2 });
};
Factories[DefinitionType.Audio] = {
  definition: audioDefinition,
  definitionFromId: audioDefinitionFromId,
  fromId: audioFromId,
  instance: audioInstance
};
var ImageWithTweenable = TweenableMixin(InstanceBase);
var ImageWithContainer = ContainerMixin(ImageWithTweenable);
var ImageWithContent = ContentMixin(ImageWithContainer);
var ImageWithPreloadable = PreloadableMixin(ImageWithContent);
var ImageWithUpdatableSize = UpdatableSizeMixin(ImageWithPreloadable);
var ImageClass = class extends ImageWithUpdatableSize {
  visibleCommandFiles(args) {
    const commandFiles = [];
    const { visible, time, videoRate: videoRate2 } = args;
    if (!visible)
      return commandFiles;
    const files = this.fileUrls(args);
    const [file] = files;
    const duration = isTimeRange(time) ? time.lengthSeconds : 0;
    const options2 = { loop: 1, framerate: videoRate2 };
    if (duration)
      options2.t = duration;
    const { id: id2 } = this;
    const commandFile = { ...file, inputId: id2, options: options2 };
    commandFiles.push(commandFile);
    return commandFiles;
  }
  fileUrls(args) {
    const { visible, editing } = args;
    const files = [];
    if (!visible)
      return files;
    const { definition } = this;
    const { url, source: source2 } = definition;
    const file = editing ? url : source2;
    assertPopulatedString(file, editing ? "url" : "source");
    const graphFile = {
      input: true,
      type: LoadType.Image,
      file,
      definition
    };
    files.push(graphFile);
    return files;
  }
};
var ImageDefinitionWithTweenable = TweenableDefinitionMixin(DefinitionBase);
var ImageDefinitionWithContainer = ContainerDefinitionMixin(ImageDefinitionWithTweenable);
var ImageDefinitionWithContent = ContentDefinitionMixin(ImageDefinitionWithContainer);
var ImageDefinitionWithPreloadable = PreloadableDefinitionMixin(ImageDefinitionWithContent);
var ImageDefinitionWithUpdatable = UpdatableSizeDefinitionMixin(ImageDefinitionWithPreloadable);
var ImageDefinitionClass = class extends ImageDefinitionWithUpdatable {
  constructor(...args) {
    super(...args);
    __publicField(this, "loadType", LoadType.Image);
    __publicField(this, "loadedImage");
    __publicField(this, "type", DefinitionType.Image);
    const [object] = args;
    const { loadedImage } = object;
    if (loadedImage)
      this.loadedImage = loadedImage;
  }
  definitionIcon(loader, size) {
    const superElement = super.definitionIcon(loader, size);
    if (superElement)
      return superElement;
    const { url } = this;
    return this.urlIcon(url, loader, size);
  }
  instanceFromObject(object = {}) {
    return new ImageClass(this.instanceArgs(object));
  }
};
var imageDefinition = (object) => {
  const { id: id2 } = object;
  assertPopulatedString(id2, "imageDefinition id");
  return new ImageDefinitionClass(object);
};
var imageDefinitionFromId = (id2) => {
  return imageDefinition({ id: id2 });
};
var imageInstance = (object) => {
  const definition = imageDefinition(object);
  const instance = definition.instanceFromObject(object);
  return instance;
};
var imageFromId = (id2) => {
  return imageInstance({ id: id2 });
};
Factories[DefinitionType.Image] = {
  definition: imageDefinition,
  definitionFromId: imageDefinitionFromId,
  fromId: imageFromId,
  instance: imageInstance
};
var VideoWithTweenable = TweenableMixin(InstanceBase);
var VideoWithContainer = ContainerMixin(VideoWithTweenable);
var VideoWithContent = ContentMixin(VideoWithContainer);
var VideoWithPreloadable = PreloadableMixin(VideoWithContent);
var VideoWithUpdatableSize = UpdatableSizeMixin(VideoWithPreloadable);
var VideoWithUpdatableDuration = UpdatableDurationMixin(VideoWithUpdatableSize);
var _VideoClass = class _VideoClass extends VideoWithUpdatableDuration {
  constructor() {
    super(...arguments);
    __publicField(this, "_foreignElement");
    __publicField(this, "_loadedVideo");
  }
  fileUrls(args) {
    const files = [];
    const { editing, time, audible, visible, icon } = args;
    const { definition } = this;
    const { url, source: source2 } = definition;
    const editingUrl = editing ? url : source2;
    assertPopulatedString(editingUrl, editing ? "url" : "source");
    if (visible) {
      if (!icon) {
        const visibleGraphFile = {
          input: true,
          type: LoadType.Video,
          file: editingUrl,
          definition
        };
        files.push(visibleGraphFile);
      }
    }
    if (audible) {
      const mutable = definition.duration ? this.mutable() : true;
      if (mutable && !this.muted) {
        const audioGraphFile = {
          input: true,
          type: LoadType.Audio,
          definition,
          file: this.definition.urlAudible(editing)
        };
        files.push(audioGraphFile);
      }
    }
    return files;
  }
  get foreignElement() {
    return this._foreignElement || (this._foreignElement = this.foreignElementInitialize);
  }
  get foreignElementInitialize() {
    return globalThis.document.createElementNS(NamespaceSvg, "foreignObject");
  }
  iconUrl(size, time, clipTime) {
    const inSize = sizeCopy(this.intrinsicRect(true));
    const coverSize = sizeCover(inSize, size);
    const { width: width2, height: height2 } = coverSize;
    const start = this.definitionTime(time, clipTime);
    const { frame } = start;
    const { fps } = clipTime;
    const { definition } = this;
    const { url } = definition;
    const videoUrl = urlPrependProtocol("video", url, { frame, fps });
    return urlPrependProtocol("image", videoUrl, { width: width2, height: height2 });
  }
  itemPreviewPromise(rect, time, range) {
    const { clientCanMaskVideo } = _VideoClass;
    const { _foreignElement, _loadedVideo } = this;
    const predefined = !!_foreignElement;
    if (predefined || _loadedVideo) {
      this.updateForeignElement(rect, time, range, predefined);
      return Promise.resolve(clientCanMaskVideo ? this.foreignElement : this.loadedVideo);
    }
    return this.loadVideoPromise.then(() => {
      this.updateForeignElement(rect, time, range);
      return clientCanMaskVideo ? this.foreignElement : this.loadedVideo;
    });
  }
  get loadedVideo() {
    return this._loadedVideo;
  }
  get loadVideoPromise() {
    const { _loadedVideo } = this;
    if (_loadedVideo)
      return Promise.resolve(_loadedVideo);
    const { definition } = this;
    const { loadedVideo } = definition;
    if (loadedVideo) {
      this._loadedVideo = loadedVideo.cloneNode();
      return Promise.resolve(this._loadedVideo);
    }
    const { preloader } = this.clip.track.mash;
    const file = this.intrinsicGraphFile({ editing: true, size: true });
    const { file: url } = file;
    const videoUrl = urlPrependProtocol("video", url);
    return preloader.loadPromise(videoUrl).then((video) => {
      definition.loadedVideo = video;
      return this._loadedVideo = video.cloneNode();
    });
  }
  updateVideo(rect, time, range) {
    const { loadedVideo } = this;
    const { currentTime } = loadedVideo;
    const definitionTime = this.definitionTime(time, range);
    const maxDistance = time.isRange ? 1 : 1 / time.fps;
    const { seconds } = definitionTime;
    if (Math.abs(seconds - currentTime) > maxDistance) {
      loadedVideo.currentTime = seconds;
    }
    const { width: width2, height: height2 } = rect;
    loadedVideo.width = width2;
    loadedVideo.height = height2;
    return loadedVideo;
  }
  updateForeignElement(rect, time, range, foreignElementDefined) {
    const { clientCanMaskVideo } = _VideoClass;
    if (clientCanMaskVideo) {
      const { foreignElement } = this;
      if (!foreignElementDefined)
        foreignElement.appendChild(this.loadedVideo);
      svgSetDimensions(foreignElement, rect);
    }
    this.updateVideo(rect, time, range);
  }
  static get clientCanMaskVideo() {
    const { _clientCanMaskVideo } = this;
    if (isBoolean(_clientCanMaskVideo))
      return _clientCanMaskVideo;
    const { navigator } = globalThis;
    const { userAgent } = navigator;
    const safari = userAgent.includes("Safari") && !userAgent.includes("Chrome");
    return this._clientCanMaskVideo = !safari;
  }
};
__publicField(_VideoClass, "_clientCanMaskVideo");
var VideoClass = _VideoClass;
var VideoDefinitionWithTweenable = TweenableDefinitionMixin(DefinitionBase);
var VideoDefinitionWithContainer = ContainerDefinitionMixin(VideoDefinitionWithTweenable);
var VideoDefinitionWithContent = ContentDefinitionMixin(VideoDefinitionWithContainer);
var VideoDefinitionWithPreloadable = PreloadableDefinitionMixin(VideoDefinitionWithContent);
var VideoDefinitionWithUpdatableSize = UpdatableSizeDefinitionMixin(VideoDefinitionWithPreloadable);
var VideoDefinitionWithUpdatableDuration = UpdatableDurationDefinitionMixin(VideoDefinitionWithUpdatableSize);
var VideoDefinitionClass = class extends VideoDefinitionWithUpdatableDuration {
  constructor(...args) {
    super(...args);
    __publicField(this, "loadType", LoadType.Video);
    __publicField(this, "loadedVideo");
    __publicField(this, "pattern", "%.jpg");
    __publicField(this, "type", DefinitionType.Video);
    const [object] = args;
    const { loadedVideo } = object;
    if (loadedVideo)
      this.loadedVideo = loadedVideo;
  }
  instanceFromObject(object = {}) {
    return new VideoClass(this.instanceArgs(object));
  }
  toJSON() {
    const object = super.toJSON();
    object.url = this.url;
    if (this.source)
      object.source = this.source;
    return object;
  }
};
var videoDefinition = (object) => {
  const { id: id2 } = object;
  assertPopulatedString(id2);
  return new VideoDefinitionClass(object);
};
var videoDefinitionFromId = (id2) => {
  return videoDefinition({ id: id2 });
};
var videoInstance = (object) => {
  const definition = videoDefinition(object);
  return definition.instanceFromObject(object);
};
var videoFromId = (id2) => {
  return videoInstance({ id: id2 });
};
Factories[DefinitionType.Video] = {
  definition: videoDefinition,
  definitionFromId: videoDefinitionFromId,
  fromId: videoFromId,
  instance: videoInstance
};
var VideoSequenceWithTweenable = TweenableMixin(InstanceBase);
var VideoSequenceWithContainer = ContainerMixin(VideoSequenceWithTweenable);
var VideoSequenceWithContent = ContentMixin(VideoSequenceWithContainer);
var VideoSequenceWithPreloadable = PreloadableMixin(VideoSequenceWithContent);
var VideoSequenceWithUpdatableSize = UpdatableSizeMixin(VideoSequenceWithPreloadable);
var VideoSequenceWithUpdatableDuration = UpdatableDurationMixin(VideoSequenceWithUpdatableSize);
var VideoSequenceClass = class extends VideoSequenceWithUpdatableDuration {
  constructor() {
    super(...arguments);
    // itemPreviewPromise(rect: Rect, time: Time, range: TimeRange, stretch?: boolean): Promise<SvgItem> {
    //   return this.itemIconPromise(rect, time, range, stretch).then(svgItem => {
    //     return svgItem
    //   })
    // }
    // private itemPromise(time: Time, range: TimeRange, icon?: boolean): Promise<SvgItem> {
    //   const definitionTime = this.definitionTime(time, range)
    //   const { definition } = this
    //   const frames = definition.framesArray(definitionTime)
    //   const [frame] = frames
    //   const url = definition.urlForFrame(frame)
    //   const svgUrl = `svg:/${url}`
    //   const { preloader } = this.clip.track.mash
    //   return preloader.loadPromise(svgUrl, definition)
    // }
    // itemPromise(containerRect: Rect, time: Time, range: TimeRange, stretch?: boolean, icon?: boolean): Promise<SvgItem> {
    //   const { container } = this
    //   const rect = container ? containerRect : this.contentRect(containerRect, time, range)
    //   const lock = stretch ? undefined : Orientation.V
    //   return this.itemPromise(time, range, icon).then(item => {
    //     svgSetDimensionsLock(item, rect, lock)
    //     return item
    //   })
    // }
    __publicField(this, "speed", 1);
  }
  visibleCommandFiles(args) {
    const files = super.visibleCommandFiles(args);
    const { streaming, visible } = args;
    if (!(visible && streaming))
      return files;
    files.forEach((file) => {
      const { options: options2 = {} } = file;
      options2.loop = 1;
      options2.re = "";
      file.options = options2;
    });
    return files;
  }
  fileUrls(args) {
    const { time, clipTime, editing, visible } = args;
    const definitionTime = this.definitionTime(time, clipTime);
    const definitionArgs = { ...args, time: definitionTime };
    const files = super.fileUrls(definitionArgs);
    if (visible) {
      const { definition } = this;
      if (editing) {
        const frames = definition.framesArray(definitionTime);
        const files2 = frames.map((frame) => {
          const graphFile = {
            type: LoadType.Image,
            file: definition.urlForFrame(frame),
            input: true,
            definition
          };
          return graphFile;
        });
        files2.push(...files2);
      } else {
        const graphFile = {
          type: LoadType.Video,
          file: definition.source,
          definition,
          input: true
        };
        files.push(graphFile);
      }
    }
    return files;
  }
  iconUrl(size, time, range) {
    const definitionTime = this.definitionTime(time, range);
    const { definition } = this;
    const frames = definition.framesArray(definitionTime);
    const [frame] = frames;
    return definition.urlForFrame(frame);
  }
  toJSON() {
    const object = super.toJSON();
    if (this.speed !== 1)
      object.speed = this.speed;
    return object;
  }
};
var VideoSequenceDefinitionWithTweenable = TweenableDefinitionMixin(DefinitionBase);
var VideoSequenceDefinitionWithContent = ContentDefinitionMixin(VideoSequenceDefinitionWithTweenable);
var VideoSequenceDefinitionWithPreloadable = PreloadableDefinitionMixin(VideoSequenceDefinitionWithContent);
var VideoSequenceDefinitionWithUpdatableSize = UpdatableSizeDefinitionMixin(VideoSequenceDefinitionWithPreloadable);
var VideoSequenceDefinitionWithUpdatableDuration = UpdatableDurationDefinitionMixin(VideoSequenceDefinitionWithUpdatableSize);
var VideoSequenceDefinitionClass = class extends VideoSequenceDefinitionWithUpdatableDuration {
  constructor(...args) {
    super(...args);
    __publicField(this, "begin", Default.definition.videosequence.begin);
    __publicField(this, "fps", Default.definition.videosequence.fps);
    __publicField(this, "increment", Default.definition.videosequence.increment);
    __publicField(this, "loadType", LoadType.Image);
    __publicField(this, "padding");
    __publicField(this, "pattern", "%.jpg");
    __publicField(this, "type", DefinitionType.VideoSequence);
    const [object] = args;
    const { padding, begin, fps, increment, pattern } = object;
    if (isPositive(begin))
      this.begin = begin;
    if (fps)
      this.fps = fps;
    if (increment)
      this.increment = increment;
    if (pattern)
      this.pattern = pattern;
    if (padding)
      this.padding = padding;
    else {
      const lastFrame = this.begin + (this.increment * this.framesMax - this.begin);
      this.padding = String(lastFrame).length;
    }
  }
  framesArray(start) {
    const { duration, fps } = this;
    return start.durationFrames(duration, fps);
  }
  get framesMax() {
    const { fps, duration } = this;
    return Math.floor(fps * duration) - 2;
  }
  instanceFromObject(object = {}) {
    return new VideoSequenceClass(this.instanceArgs(object));
  }
  toJSON() {
    const json = super.toJSON();
    const { videosequence } = Default.definition;
    const { pattern, increment, begin, fps, padding } = this;
    if (pattern !== videosequence.pattern)
      json.pattern = pattern;
    if (increment !== videosequence.increment)
      json.increment = increment;
    if (begin !== videosequence.begin)
      json.begin = begin;
    if (fps !== videosequence.fps)
      json.fps = fps;
    if (padding !== videosequence.padding)
      json.padding = padding;
    return json;
  }
  urlForFrame(frame) {
    const { increment, begin, padding, url, pattern } = this;
    let s = String(frame * increment + begin);
    if (padding)
      s = s.padStart(padding, "0");
    return (url + pattern).replaceAll("%", s);
  }
};
var videoSequenceDefinition = (object) => {
  const { id: id2 } = object;
  assertPopulatedString(id2);
  return new VideoSequenceDefinitionClass(object);
};
var videoSequenceDefinitionFromId = (id2) => {
  return videoSequenceDefinition({ id: id2 });
};
var videoSequenceInstance = (object) => {
  const definition = videoSequenceDefinition(object);
  return definition.instanceFromObject(object);
};
var videoSequenceFromId = (id2) => {
  return videoSequenceInstance({ id: id2 });
};
Factories[DefinitionType.VideoSequence] = {
  definition: videoSequenceDefinition,
  definitionFromId: videoSequenceDefinitionFromId,
  fromId: videoSequenceFromId,
  instance: videoSequenceInstance
};
var RenderingOutputClass = class {
  constructor(args) {
    __publicField(this, "args");
    __publicField(this, "_avType", AVType.Both);
    __publicField(this, "_durationClips");
    __publicField(this, "graphType", GraphType.Mash);
    __publicField(this, "outputType");
    this.args = args;
  }
  assureClipFrames() {
    const { durationClips, args } = this;
    const { quantize } = args.mash;
    durationClips.forEach((clip) => {
      const { content } = clip;
      const { definition } = content;
      if (isUpdatableDurationDefinition(definition)) {
        const frames = definition.frames(quantize);
        if (frames)
          clip.frames = frames;
      }
    });
  }
  get avType() {
    return this._avType;
  }
  get avTypeNeededForClips() {
    const { avType } = this;
    if (avType !== AVType.Both)
      return avType;
    const { renderingClips } = this;
    const types = /* @__PURE__ */ new Set();
    renderingClips.forEach((renderingClip) => {
      if (renderingClip.audible)
        types.add(AVType.Audio);
      if (renderingClip.visible)
        types.add(AVType.Video);
    });
    if (types.size === 2)
      return avType;
    const [type2] = types;
    return type2;
  }
  get commandOutput() {
    return this.args.commandOutput;
  }
  get duration() {
    return this.timeRange.lengthSeconds;
  }
  get durationClips() {
    return this._durationClips || (this._durationClips = this.durationClipsInitialize);
  }
  get durationClipsInitialize() {
    const { mash } = this.args;
    const { frames } = mash;
    if (isPositive(frames))
      return [];
    const { clips } = mash;
    const options2 = { duration: true };
    const zeroClips = clips.filter((clip) => !clip.intrinsicsKnown(options2));
    return zeroClips;
  }
  get endTime() {
    return this.args.endTime || this.args.mash.endTime;
  }
  // private _filterGraphs?: FilterGraphsthis._filterGraphs =
  get filterGraphs() {
    const { filterGraphsOptions } = this;
    return this.args.mash.filterGraphs(filterGraphsOptions);
  }
  get filterGraphsOptions() {
    const { timeRange: time, graphType, videoRate: videoRate2, args } = this;
    const { upload } = args;
    const size = this.sizeCovered();
    const filterGraphsOptions = {
      time,
      graphType,
      videoRate: videoRate2,
      size,
      avType: this.avTypeNeededForClips,
      upload
    };
    return filterGraphsOptions;
  }
  get mashDurationPromise() {
    const clips = this.durationClips;
    if (!clips.length) {
      return Promise.resolve();
    }
    const { mash } = this.args;
    const options2 = { duration: true };
    const files = clips.flatMap((clip) => clip.intrinsicGraphFiles(options2));
    const { preloader } = mash;
    return preloader.loadFilesPromise(files);
  }
  get mashSize() {
    const { visibleGraphFiles: graphFiles } = this;
    const definitions = graphFiles.map((graphFile) => graphFile.definition);
    const updatable = definitions.filter((def) => isUpdatableSizeDefinition(def));
    const set = new Set(updatable);
    const unique = [...set];
    const sized = unique.filter((definition) => definition.sourceSize);
    if (!sized.length)
      return;
    const sizes = sized.map((definition) => definition.sourceSize);
    return {
      width: Math.max(...sizes.map((size) => size.width)),
      height: Math.max(...sizes.map((size) => size.height))
    };
  }
  get outputCover() {
    return !!this.args.commandOutput.cover;
  }
  get outputSize() {
    const { width: width2, height: height2 } = this.args.commandOutput;
    if (!(width2 && height2)) {
      if (this.avType === AVType.Audio)
        return { width: 0, height: 0 };
      throw Errors.invalid.size + this.outputType + ".outputSize for avType " + this.avType;
    }
    return { width: width2, height: height2 };
  }
  get preloadPromise() {
    return this.filterGraphs.loadPromise;
  }
  get renderingClips() {
    return this.args.mash.clipsInTimeOfType(this.timeRange, this.avType);
  }
  renderingDescriptionPromise(renderingResults) {
    let promise = this.mashDurationPromise;
    promise = promise.then(() => {
      this.assureClipFrames();
    });
    promise = promise.then(() => {
      return this.sizePromise;
    });
    promise = promise.then(() => {
      return this.preloadPromise;
    });
    return promise.then(() => {
      this.assureClipFrames();
      const { commandOutput } = this;
      const renderingDescription = { commandOutput };
      const avType = this.avTypeNeededForClips;
      const { filterGraphs } = this;
      if (avType !== AVType.Audio) {
        const { filterGraphsVisible } = filterGraphs;
        const visibleCommandDescriptions = filterGraphsVisible.map((filterGraph) => {
          const { commandInputs: inputs, commandFilters, duration } = filterGraph;
          const commandDescription = { inputs, commandFilters, duration, avType: AVType.Video };
          return commandDescription;
        });
        renderingDescription.visibleCommandDescriptions = visibleCommandDescriptions;
      }
      if (avType !== AVType.Video) {
        const { filterGraphAudible, duration } = filterGraphs;
        if (filterGraphAudible) {
          const { commandFilters, commandInputs: inputs } = filterGraphAudible;
          const commandDescription = {
            inputs,
            commandFilters,
            duration,
            avType: AVType.Audio
          };
          renderingDescription.audibleCommandDescription = commandDescription;
        }
      }
      return renderingDescription;
    });
  }
  // get renderingDescription(): RenderingDescription {
  //   const { commandOutput } = this
  //   const renderingDescription: RenderingDescription = { commandOutput }
  //   const avType = this.avTypeNeededForClips
  //   const { filterGraphs } = this
  //   // console.log(this.constructor.name, "renderingDescriptionPromise avType", avType)
  //   if (avType !== AVType.Audio) {
  //     const { filterGraphsVisible } = filterGraphs
  //     const visibleCommandDescriptions = filterGraphsVisible.map(filterGraph => {
  //       const { commandFilters, commandInputs: inputs, duration } = filterGraph
  //       const commandDescription: CommandDescription = { inputs, commandFilters, duration, avType: AVType.Video }
  //     // console.log(this.constructor.name, "renderingDescriptionPromise inputs, commandFilters", inputs, commandFilters)
  //       return commandDescription
  //     })
  //     renderingDescription.visibleCommandDescriptions = visibleCommandDescriptions
  //   }
  //   if (avType !== AVType.Video) {
  //     const { filterGraphAudible, duration } = filterGraphs
  //     if (filterGraphAudible) {
  //       const { commandFilters, commandInputs: inputs } = filterGraphAudible
  //       const commandDescription: CommandDescription = {
  //         inputs, commandFilters, duration, avType: AVType.Audio
  //       }
  //       renderingDescription.audibleCommandDescription = commandDescription
  //     }
  //   }
  //   return renderingDescription
  // }
  get startTime() {
    if (this.args.startTime)
      return this.args.startTime;
    const { quantize, frame } = this.args.mash;
    return timeFromArgs(frame, quantize);
  }
  sizeCovered() {
    const { outputSize, outputCover } = this;
    if (!outputCover) {
      return outputSize;
    }
    const { mashSize } = this;
    if (!isSize(mashSize)) {
      return outputSize;
    }
    const { width: width2, height: height2 } = mashSize;
    assertAboveZero(width2);
    assertAboveZero(height2);
    return sizeCover(mashSize, outputSize);
  }
  get sizePromise() {
    if (this.avType === AVType.Audio || !this.outputCover)
      return Promise.resolve();
    const { visibleGraphFiles } = this;
    if (!visibleGraphFiles.length)
      return Promise.resolve();
    const { preloader } = this.args.mash;
    return preloader.loadFilesPromise(visibleGraphFiles);
  }
  get timeRange() {
    return timeRangeFromTimes(this.startTime, this.endTime);
  }
  get videoRate() {
    return this.args.commandOutput.videoRate || 0;
  }
  get visibleGraphFiles() {
    const { timeRange: time, args } = this;
    const { mash } = args;
    const clips = mash.clipsInTimeOfType(time, AVType.Video);
    const options2 = { size: true };
    const unknownClips = clips.filter((clip) => !clip.intrinsicsKnown(options2));
    const files = unknownClips.flatMap((clip) => clip.intrinsicGraphFiles(options2));
    return files;
  }
};
var AudioOutputClass = class extends RenderingOutputClass {
  constructor() {
    super(...arguments);
    __publicField(this, "_avType", AVType.Audio);
    __publicField(this, "outputType", OutputType.Audio);
  }
};
var options$8 = {};
var audioBitrate$5 = 160;
var audioCodec$5 = "libmp3lame";
var audioChannels$5 = 2;
var audioRate$5 = 44100;
var extension$8 = "mp3";
var outputType$5 = "audio";
var outputDefaultAudioJson = {
  options: options$8,
  audioBitrate: audioBitrate$5,
  audioCodec: audioCodec$5,
  audioChannels: audioChannels$5,
  audioRate: audioRate$5,
  extension: extension$8,
  outputType: outputType$5
};
var options$7 = {};
var width$7 = 320;
var height$7 = 240;
var extension$7 = "jpg";
var outputType$4 = "image";
var cover$3 = true;
var offset$1 = 0;
var outputDefaultImageJson = {
  options: options$7,
  width: width$7,
  height: height$7,
  extension: extension$7,
  outputType: outputType$4,
  cover: cover$3,
  offset: offset$1
};
var options$6 = {};
var width$6 = 320;
var height$6 = 240;
var extension$6 = "png";
var outputType$3 = "image";
var format$5 = "image2";
var cover$2 = true;
var offset = 0;
var outputDefaultImagePngJson = {
  options: options$6,
  width: width$6,
  height: height$6,
  extension: extension$6,
  outputType: outputType$3,
  format: format$5,
  cover: cover$2,
  offset
};
var options$5 = {
  g: 60,
  level: 41,
  movflags: "faststart"
};
var width$5 = 1920;
var height$5 = 1080;
var videoRate$4 = 30;
var videoBitrate$3 = 2e3;
var audioBitrate$4 = 160;
var audioCodec$4 = "aac";
var videoCodec$3 = "libx264";
var audioChannels$4 = 2;
var audioRate$4 = 44100;
var g = 0;
var format$4 = "mp4";
var extension$5 = "mp4";
var outputType$2 = "video";
var cover$1 = false;
var outputDefaultVideoJson = {
  options: options$5,
  width: width$5,
  height: height$5,
  videoRate: videoRate$4,
  videoBitrate: videoBitrate$3,
  audioBitrate: audioBitrate$4,
  audioCodec: audioCodec$4,
  videoCodec: videoCodec$3,
  audioChannels: audioChannels$4,
  audioRate: audioRate$4,
  g,
  format: format$4,
  extension: extension$5,
  outputType: outputType$2,
  cover: cover$1
};
var options$4 = {};
var format$3 = "image2";
var width$4 = 320;
var height$4 = 240;
var videoRate$3 = 10;
var extension$4 = "jpg";
var outputType$1 = "imagesequence";
var cover = false;
var outputDefaultImageSequenceJson = {
  options: options$4,
  format: format$3,
  width: width$4,
  height: height$4,
  videoRate: videoRate$3,
  extension: extension$4,
  outputType: outputType$1,
  cover
};
var options$3 = {};
var width$3 = 320;
var height$3 = 240;
var forecolor = "#000000";
var backcolor = "#00000000";
var audioBitrate$3 = 160;
var audioCodec$3 = "aac";
var audioChannels$3 = 2;
var audioRate$3 = 44100;
var extension$3 = "png";
var outputType = "waveform";
var outputDefaultWaveformJson = {
  options: options$3,
  width: width$3,
  height: height$3,
  forecolor,
  backcolor,
  audioBitrate: audioBitrate$3,
  audioCodec: audioCodec$3,
  audioChannels: audioChannels$3,
  audioRate: audioRate$3,
  extension: extension$3,
  outputType
};
var width$2 = 320;
var height$2 = 240;
var videoRate$2 = 30;
var videoBitrate$2 = 2e3;
var audioBitrate$2 = 160;
var audioCodec$2 = "aac";
var videoCodec$2 = "libx264";
var audioChannels$2 = 2;
var audioRate$2 = 44100;
var format$2 = "mdash";
var extension$2 = "dash";
var streamingFormat$2 = "mdash";
var options$2 = {
  hls_delete_threshold: 10,
  g: 60
};
var outputDefaultDashJson = {
  width: width$2,
  height: height$2,
  videoRate: videoRate$2,
  videoBitrate: videoBitrate$2,
  audioBitrate: audioBitrate$2,
  audioCodec: audioCodec$2,
  videoCodec: videoCodec$2,
  audioChannels: audioChannels$2,
  audioRate: audioRate$2,
  format: format$2,
  extension: extension$2,
  streamingFormat: streamingFormat$2,
  options: options$2
};
var width$1 = 320;
var height$1 = 240;
var videoRate$1 = 30;
var videoBitrate$1 = 2e3;
var audioBitrate$1 = 160;
var audioCodec$1 = "aac";
var videoCodec$1 = "libx264";
var audioChannels$1 = 2;
var audioRate$1 = 44100;
var format$1 = "hls";
var extension$1 = "m3u8";
var streamingFormat$1 = "hls";
var options$1 = {
  hls_segment_filename: "%06d.ts",
  hls_time: 6,
  hls_list_size: 10,
  hls_flags: "delete_segments",
  hls_delete_threshold: 10,
  g: 60
};
var outputDefaultHlsJson = {
  width: width$1,
  height: height$1,
  videoRate: videoRate$1,
  videoBitrate: videoBitrate$1,
  audioBitrate: audioBitrate$1,
  audioCodec: audioCodec$1,
  videoCodec: videoCodec$1,
  audioChannels: audioChannels$1,
  audioRate: audioRate$1,
  format: format$1,
  extension: extension$1,
  streamingFormat: streamingFormat$1,
  options: options$1
};
var width = 320;
var height = 240;
var videoRate = 30;
var videoBitrate = 2e3;
var audioBitrate = 160;
var audioCodec = "aac";
var videoCodec = "libx264";
var audioChannels = 2;
var audioRate = 44100;
var format = "flv";
var extension = "flv";
var streamingFormat = "rtmp";
var options = {
  g: 60
};
var outputDefaultRtmpJson = {
  width,
  height,
  videoRate,
  videoBitrate,
  audioBitrate,
  audioCodec,
  videoCodec,
  audioChannels,
  audioRate,
  format,
  extension,
  streamingFormat,
  options
};
var outputDefaultAudio = (overrides) => {
  const object = overrides || {};
  const commandOutput = outputDefaultAudioJson;
  return { ...commandOutput, ...object };
};
var outputDefaultVideo = (overrides) => {
  const object = overrides || {};
  const commandOutput = outputDefaultVideoJson;
  return { ...commandOutput, ...object };
};
var outputDefaultImageSequence = (overrides) => {
  const object = overrides || {};
  const commandOutput = outputDefaultImageSequenceJson;
  return { ...commandOutput, ...object };
};
var outputDefaultWaveform = (overrides) => {
  const object = overrides || {};
  const commandOutput = outputDefaultWaveformJson;
  return { ...commandOutput, ...object };
};
var outputDefaultPng = (overrides) => {
  const object = overrides || {};
  const commandOutput = outputDefaultImagePngJson;
  return { ...commandOutput, ...object };
};
var outputDefaultImage = (overrides) => {
  const object = overrides || {};
  const commandOutput = outputDefaultImageJson;
  return { ...commandOutput, ...object };
};
var outputDefaultPopulate = (overrides) => {
  const { outputType: outputType2 } = overrides;
  switch (outputType2) {
    case OutputType.Audio:
      return outputDefaultAudio(overrides);
    case OutputType.Image:
      return outputDefaultImage(overrides);
    case OutputType.Video:
      return outputDefaultVideo(overrides);
    case OutputType.ImageSequence:
      return outputDefaultImageSequence(overrides);
    case OutputType.Waveform:
      return outputDefaultWaveform(overrides);
  }
};
var outputDefaultRendering = (outputType2, overrides) => {
  return outputDefaultPopulate({ ...overrides, outputType: outputType2 });
};
var outputDefaultTypeByFormat = {
  [OutputFormat.AudioConcat]: OutputType.Audio,
  [OutputFormat.Mdash]: OutputType.Video,
  [OutputFormat.Flv]: OutputType.Video,
  [OutputFormat.Hls]: OutputType.Video,
  [OutputFormat.Jpeg]: OutputType.Image,
  [OutputFormat.Mp3]: OutputType.Audio,
  [OutputFormat.Mp4]: OutputType.Video,
  [OutputFormat.Png]: OutputType.Image,
  [OutputFormat.Rtmp]: OutputType.Video,
  [OutputFormat.VideoConcat]: OutputType.Video
};
var outputDefaultFormatByType = {
  [OutputType.Audio]: OutputFormat.Mp3,
  [OutputType.Image]: OutputFormat.Png,
  [OutputType.Video]: OutputFormat.Mp4,
  [OutputType.ImageSequence]: OutputFormat.Jpeg,
  [OutputType.Waveform]: OutputFormat.Png
};
var outputDefaultStreaming = (overrides) => {
  const { format: format2 } = overrides;
  switch (format2) {
    case OutputFormat.Mdash:
      return outputDefaultDash(overrides);
    case OutputFormat.Rtmp:
      return outputDefaultRtmp(overrides);
    case OutputFormat.Hls:
    default:
      return outputDefaultHls(overrides);
  }
};
var outputDefaultHls = (overrides) => {
  const object = overrides || {};
  const commandOutput = outputDefaultHlsJson;
  return { ...commandOutput, ...object };
};
var outputDefaultDash = (overrides) => {
  const object = overrides || {};
  const commandOutput = outputDefaultDashJson;
  return { ...commandOutput, ...object };
};
var outputDefaultRtmp = (overrides) => {
  const object = overrides || {};
  const commandOutput = outputDefaultRtmpJson;
  return { ...commandOutput, ...object };
};
var ImageOutputClass = class extends RenderingOutputClass {
  constructor() {
    super(...arguments);
    __publicField(this, "_avType", AVType.Video);
    __publicField(this, "outputType", OutputType.Image);
  }
  get commandOutput() {
    const { upload, commandOutput } = this.args;
    if (!upload) {
      return commandOutput;
    }
    const { renderingClips } = this;
    const [clip] = renderingClips;
    const { definition } = clip.content;
    assertPreloadableDefinition(definition);
    const { info } = definition;
    assertObject(info);
    const { streams } = info;
    const [stream] = streams;
    const { pix_fmt, codec_name } = stream;
    if (codec_name !== "png") {
      return commandOutput;
    }
    const { width: width2, height: height2, basename } = commandOutput;
    const overrides = { width: width2, height: height2, basename };
    const output = outputDefaultPng(overrides);
    return output;
  }
  get endTime() {
    return;
  }
  get filterGraphsOptions() {
    const { args, graphType, avType, startTime: time } = this;
    const { mash, upload } = args;
    const { quantize: videoRate2 } = mash;
    const filterGraphsOptions = {
      time,
      graphType,
      videoRate: videoRate2,
      size: this.sizeCovered(),
      avType,
      upload
    };
    return filterGraphsOptions;
  }
  get startTime() {
    const { commandOutput, mash } = this.args;
    const { offset: offset2 } = commandOutput;
    const needDuration = offset2 || mash.frames < 0;
    if (needDuration)
      return timeFromArgs(0, mash.quantize);
    return mash.timeRange.positionTime(Number(offset2 || 0), "ceil");
  }
};
var ImageSequenceOutputClass = class extends AudioOutputClass {
  constructor() {
    super(...arguments);
    __publicField(this, "_avType", AVType.Video);
    __publicField(this, "outputType", OutputType.ImageSequence);
  }
};
var VideoOutputClass = class extends AudioOutputClass {
  constructor() {
    super(...arguments);
    __publicField(this, "outputType", OutputType.Video);
  }
  get avType() {
    return this.args.commandOutput.mute ? AVType.Video : AVType.Both;
  }
  get outputCover() {
    return !!this.args.commandOutput.cover;
  }
};
var WaveformOutputClass = class extends RenderingOutputClass {
  constructor() {
    super(...arguments);
    __publicField(this, "_avType", AVType.Audio);
    __publicField(this, "outputType", OutputType.Waveform);
  }
  get sizePromise() {
    return Promise.resolve();
  }
};
var outputInstanceAudio = (object) => {
  return new AudioOutputClass(object);
};
var outputInstanceImage = (object) => {
  return new ImageOutputClass(object);
};
var outputInstanceVideo = (object) => {
  return new VideoOutputClass(object);
};
var outputInstanceVideoSequence = (object) => {
  return new ImageSequenceOutputClass(object);
};
var outputInstanceWaveform = (object) => {
  return new WaveformOutputClass(object);
};
var OutputFactory = {
  [OutputType.Audio]: outputInstanceAudio,
  [OutputType.Image]: outputInstanceImage,
  [OutputType.Video]: outputInstanceVideo,
  [OutputType.ImageSequence]: outputInstanceVideoSequence,
  [OutputType.Waveform]: outputInstanceWaveform
};
var StreamingOutputClass = class {
  constructor(args) {
    __publicField(this, "args");
    __publicField(this, "mashes", []);
    this.args = args;
  }
  streamingDescription(renderingResults) {
    const { mashes } = this.args;
    const promises = mashes.map((mash) => {
      const options2 = {
        audible: true,
        visible: true,
        streaming: true
      };
      return mash.preloader.loadFilesPromise(mash.editedGraphFiles(options2));
    });
    let promise = Promise.all(promises).then(() => {
      const files = [];
      const commandFilters = [];
      const commandInputs = [];
      const avType = AVType.Both;
      mashes.forEach((mash) => {
        const args = {
          size: this.outputSize,
          videoRate: this.args.commandOutput.videoRate,
          graphType: GraphType.Cast,
          avType
        };
        const filterGraphs = mash.filterGraphs(args);
        const { filterGraphVisible } = filterGraphs;
        commandInputs.push(...filterGraphVisible.commandInputs);
        files.push(...filterGraphs.fileUrls.filter((graphFile) => graphFile.input));
        commandFilters.push(...filterGraphVisible.commandFilters);
      });
      const options2 = { ...this.args.commandOutput.options };
      const commandOutput = { ...this.args.commandOutput, options: options2 };
      const commandOptions = {
        inputs: commandInputs,
        commandFilters,
        commandOutput,
        avType
      };
      return commandOptions;
    });
    return promise;
  }
  get outputSize() {
    const { width: width2, height: height2 } = this.args.commandOutput;
    return { width: width2, height: height2 };
  }
};
var VideoStreamOutputClass = class extends StreamingOutputClass {
};

export {
  isCustomEvent,
  throwError,
  isObject,
  assertObject,
  isString,
  assertString,
  isUndefined,
  isNumberOrNaN,
  assertNumber,
  isBoolean,
  assertBoolean,
  isMethod,
  isDefined,
  assertDefined,
  isNan,
  isNumber,
  isInteger,
  isFloat,
  isPositive,
  assertPositive,
  isBelowOne,
  isAboveZero,
  assertAboveZero,
  isArray,
  assertArray,
  isPopulatedString,
  assertPopulatedString,
  isPopulatedArray,
  assertPopulatedArray,
  isPopulatedObject,
  assertPopulatedObject,
  isNumeric,
  assertTrue,
  isRgb,
  assertRgb,
  isTime,
  assertTime,
  isTimeRange,
  assertTimeRange,
  isValue,
  isTrueValue,
  assertValue,
  isValueObject,
  assertValueObject,
  DroppingPosition,
  LayerType,
  LayerTypes,
  isLayerType,
  assertLayerType,
  ActionType,
  EditType,
  EditTypes,
  isEditType,
  assertEditType,
  AVType,
  SelectType,
  SelectTypes,
  isSelectType,
  assertSelectType,
  ClipSelectTypes,
  isClipSelectType,
  OutputFormat,
  StreamingFormat,
  OutputType,
  OutputTypes,
  FillType,
  FillTypes,
  isFillType,
  GraphFileType,
  GraphFileTypes,
  isGraphFileType,
  LoadType,
  LoadTypes,
  isLoadType,
  assertLoadType,
  UploadTypes,
  isUploadType,
  DefinitionType,
  DefinitionTypes,
  isDefinitionType,
  assertDefinitionType,
  SizingDefinitionTypes,
  isSizingDefinitionType,
  TimingDefinitionTypes,
  isTimingDefinitionType,
  ContainerTypes,
  isContainerType,
  assertContainerType,
  ContentTypes,
  isContentType,
  assertContentType,
  DataType,
  DataTypes,
  isDataType,
  assertDataType,
  Orientation,
  Orientations,
  isOrientation,
  Direction,
  Directions,
  isDirection,
  assertDirection,
  Anchor,
  Anchors,
  TriggerType,
  TriggerTypes,
  isTriggerType,
  TransformType,
  EventType,
  EventTypes,
  isEventType,
  MoveType,
  MasherAction,
  GraphType,
  ServerType,
  ServerTypes,
  Duration,
  Timing,
  Timings,
  Sizing,
  Sizings,
  ApiVersion,
  Endpoints,
  Factories,
  Factory,
  ExtHls,
  ExtTs,
  ExtRtmp,
  ExtDash,
  ExtJpeg,
  ExtPng,
  ExtJson,
  ExtText,
  OutputFilterGraphPadding,
  EmptyMethod,
  NamespaceSvg,
  NamespaceXhtml,
  NamespaceLink,
  IdPrefix,
  IdSuffix,
  ClassDisabled,
  ClassButton,
  ClassCollapsed,
  ClassSelected,
  ClassDropping,
  ClassDroppingBefore,
  ClassDroppingAfter,
  isDefinitionObject,
  isDefinition,
  assertDefinition,
  Defined,
  colorRgbKeys,
  colorRgbaKeys,
  colorTransparent,
  colorBlack,
  colorWhite,
  colorWhiteTransparent,
  colorBlackTransparent,
  colorWhiteOpaque,
  colorBlackOpaque,
  colorGreen,
  colorYellow,
  colorRed,
  colorBlue,
  Color,
  Colors,
  colorName,
  rgbValue,
  rgbNumeric,
  yuvNumeric,
  colorYuvToRgb,
  colorRgbToHex,
  colorRgbaToHex,
  colorYuvDifference,
  colorYuvBlend,
  colorRgbToYuv,
  colorRgbRegex,
  colorRgbaRegex,
  colorHexRegex,
  colorStrip,
  colorValid,
  colorValidHex,
  colorValidRgba,
  colorValidRgb,
  getChunksFromString,
  hex256,
  colorAlpha,
  colorHexToRgba,
  colorHexToRgb,
  colorRgbaToRgba,
  colorToRgb,
  colorToRgba,
  colorAlphaColor,
  colorFromRgb,
  colorFromRgba,
  colorRgb,
  colorRgba,
  colorRgbaTransparent,
  colorServer,
  colorRgbDifference,
  PropertyTypesNumeric,
  propertyTypeIsString,
  propertyTypeDefault,
  propertyTypeValid,
  propertyTypeCoerce,
  PropertyTweenSuffix,
  PropertiedClass,
  isPropertied,
  isInstanceObject,
  isInstance,
  isTweenable,
  assertTweenable,
  isTweenableDefinition,
  assertTweenableDefinition,
  DefaultContainerId,
  TextContainerId,
  isContainerObject,
  assertContainerObject,
  isContainerDefinition,
  isContainer,
  assertContainer,
  isPoint,
  assertPoint,
  pointsEqual,
  PointZero,
  pointCopy,
  pointRound,
  pointString,
  pointValueString,
  pointNegate,
  isSize,
  assertSize,
  sizesEqual,
  SizeZero,
  sizedEven,
  sizeEven,
  sizeRound,
  sizeCeil,
  sizeFloor,
  sizeScale,
  sizeCover,
  sizeAboveZero,
  assertSizeAboveZero,
  SizeOutput,
  SizePreview,
  SizeIcon,
  sizeCopy,
  sizeLock,
  sizeString,
  sizeLockNegative,
  sizeFromElement,
  isRect,
  assertRect,
  rectsEqual,
  RectZero,
  rectFromSize,
  rectsFromSizes,
  rectCopy,
  rectRound,
  centerPoint,
  rectString,
  arrayLast,
  arraySet,
  arrayReversed,
  arrayUnique,
  DataGroup,
  DataGroups,
  isDataGroup,
  assertDataGroup,
  isProperty,
  assertProperty,
  propertyInstance,
  Errors,
  Parameter,
  idGenerateString,
  idPrefixSet,
  idTemporary,
  idGenerate,
  idIsTemporary,
  InstanceBase,
  svgId,
  svgUrl,
  svgGroupElement,
  svgSetDimensions,
  svgSetTransformPoint,
  svgRectPoints,
  svgPolygonElement,
  svgSetBox,
  svgElement,
  svgSetDimensionsLock,
  svgImageElement,
  svgPathElement,
  svgMaskElement,
  svgFilter,
  svgAppend,
  svgPatternElement,
  svgDefsElement,
  svgFeImageElement,
  svgFilterElement,
  svgDifferenceDefs,
  svgSet,
  svgAddClass,
  svgUseElement,
  svgSetTransform,
  svgTransform,
  svgSetTransformRects,
  svgFunc,
  svgSetChildren,
  isLoadedVideo,
  isLoadedImage,
  isLoadedAudio,
  isLoaderType,
  assertLoaderType,
  isLoaderPath,
  assertLoaderPath,
  urlEndpoint,
  urlIsObject,
  urlIsHttp,
  urlHasProtocol,
  urlCombine,
  urlFromEndpoint,
  urlForEndpoint,
  urlIsRootProtocol,
  urlProtocol,
  urlParse,
  urlsParsed,
  urlsAbsolute,
  urlOptionsObject,
  urlOptions,
  urlPrependProtocol,
  DefinitionBase,
  FilterClass,
  FilterDefinitionClass,
  ChromaKeyFilter,
  roundMethod,
  roundWithMethod,
  pixelRgbaAtIndex,
  pixelNeighboringRgbas,
  pixelColor,
  pixelPerFrame,
  pixelFromFrame,
  pixelToFrame,
  pixelsMixRbga,
  pixelsMixRbg,
  pixelsRemoveRgba,
  pixelsReplaceRgba,
  tweenPad,
  tweenNumberStep,
  tweenColorStep,
  tweenColors,
  tweenRects,
  tweenMaxSize,
  tweenMinSize,
  tweenOption,
  tweenableRects,
  tweenPosition,
  tweenNumberObject,
  tweenOverRect,
  tweenOverPoint,
  tweenOverSize,
  tweenScaleSizeToRect,
  tweenCoverSizes,
  tweenCoverPoints,
  tweenRectLock,
  tweenRectsLock,
  tweenScaleSizeRatioLock,
  tweeningPoints,
  tweenMinMax,
  tweenInputTime,
  ColorizeFilter,
  ColorFilter,
  ColorChannelMixerFilter,
  ActivityType,
  commandFilesInputIndex,
  commandFilesInput,
  eventStop,
  fetchCallback,
  isSelectedProperty,
  selectedPropertyObject,
  selectedPropertiesScalarObject,
  sortByFrame,
  sortByIndex,
  sortByTrack,
  sortByLabel,
  stringSeconds,
  stringFamilySizeRect,
  stringPluralize,
  ConvolutionFilter,
  isConvolutionServerFilter,
  assertConvolutionServerFilter,
  CropFilter,
  OverlayFilter,
  ScaleFilter,
  OpacityFilter,
  SetsarFilter,
  FpsFilter,
  SetptsFilter,
  AlphamergeFilter,
  TrimFilter,
  TextFilter,
  FilterIdPrefix,
  filterDefaults,
  filterDefinition,
  filterDefinitionFromId,
  filterInstance,
  filterFromId,
  DefaultContentId,
  isContent,
  assertContent,
  isContentDefinition,
  isPreloadableDefinition,
  assertPreloadableDefinition,
  isPreloadable,
  assertPreloadable,
  UpdatableSizeDefinitionType,
  isUpdatableSize,
  assertUpdatableSize,
  isUpdatableSizeType,
  isUpdatableSizeDefinition,
  assertUpdatableSizeDefinition,
  ContainerMixin,
  ContainerDefinitionMixin,
  isShapeContainer,
  timeEqualizeRates,
  TimeClass,
  TimeRangeClass,
  timeRangeFromArgs,
  timeRangeFromSeconds,
  timeRangeFromTime,
  timeRangeFromTimes,
  timeFromArgs,
  timeFromSeconds,
  Default,
  TweenableMixin,
  ShapeContainerClass,
  TweenableDefinitionMixin,
  ShapeContainerDefinitionClass,
  isTextContainer,
  assertTextContainer,
  TextContainerClass,
  FontClass,
  FontDefinitionClass,
  fontDefinition,
  fontDefault,
  fontDefaults,
  fontDefinitionFromId,
  fontInstance,
  fontFromId,
  TextContainerDefinitionClass,
  containerDefaults,
  containerDefinition,
  containerDefinitionFromId,
  containerInstance,
  containerFromId,
  ContentDefinitionMixin,
  ModularMixin,
  EffectClass,
  ModularDefinitionMixin,
  EffectDefinitionClass,
  effectDefinition,
  effectDefaults,
  effectDefinitionFromId,
  effectInstance,
  effectFromId,
  isAudio,
  isAudioDefinition,
  ContentMixin,
  isColorContent,
  ColorContentClass,
  ColorContentDefinitionClass,
  contentDefaults,
  contentDefinition,
  contentDefinitionFromId,
  contentInstance,
  contentFromId,
  AudibleContext,
  AudibleContextInstance,
  ContextFactory,
  isMashAndDefinitionsObject,
  isMash,
  assertMash,
  EditedClass,
  isClipObject,
  isClip,
  assertClip,
  isTrack,
  assertTrack,
  PreloadableDefinitionMixin,
  PreloadableMixin,
  UpdatableSizeMixin,
  UpdatableSizeDefinitionMixin,
  UpdatableDurationDefinitionTypes,
  isUpdatableDuration,
  assertUpdatableDuration,
  isUpdatableDurationType,
  isUpdatableDurationDefinition,
  assertUpdatableDurationDefinition,
  UpdatableDurationMixin,
  UpdatableDurationDefinitionMixin,
  AudioPreview,
  FilterGraphInputVisible,
  FilterGraphInputAudible,
  FilterGraphClass,
  FilterGraphsClass,
  TrackPreviewHandleSize,
  TrackPreviewLineSize,
  TrackPreviewClass,
  PreviewClass,
  ClipClass,
  ClipDefinitionClass,
  clipDefault,
  clipDefaultId,
  clipDefaults,
  clipDefinition,
  clipDefinitionFromId,
  clipInstance,
  clipFromId,
  TrackClass,
  trackInstance,
  TrackFactory,
  NonePreview,
  MashClass,
  mashInstance,
  isMashClass,
  assertMashClass,
  LayerClass,
  LayerFolderClass,
  DirectionLabels,
  LayerMashClass,
  isLayerObject,
  isLayerFolderObject,
  isLayerMashObject,
  layerFolderInstance,
  layerMashInstance,
  layerInstance,
  isLayer,
  assertLayer,
  isLayerMash,
  assertLayerMash,
  isLayerFolder,
  assertLayerFolder,
  CastClass,
  castInstance,
  isCast,
  assertCast,
  isEdited,
  assertEdited,
  Action,
  isAction,
  assertAction,
  isActionInit,
  isActionEvent,
  AddTrackAction,
  AddClipToTrackAction,
  AddEffectAction,
  isChangeActionObject,
  ChangeAction,
  isChangeAction,
  assertChangeAction,
  ChangeFramesAction,
  MoveClipAction,
  MoveEffectAction,
  RemoveClipAction,
  AddLayerAction,
  RemoveLayerAction,
  MoveLayerAction,
  ChangeMultipleAction,
  actionInstance,
  ActionFactory,
  Actions,
  isCastData,
  isMashData,
  assertMashData,
  Emitter,
  isEffect,
  assertEffect,
  isEffectDefinition,
  isFontDefinition,
  assertFontDefinition,
  LoaderClass,
  BrowserLoaderClass,
  EditorSelectionClass,
  editorSelectionInstance,
  isVideoDefinition,
  isVideo,
  assertVideo,
  isImageDefinition,
  EditorClass,
  editorSingleton,
  editorArgs,
  editorInstance,
  AudioClass,
  AudioDefinitionClass,
  audioDefinition,
  audioDefinitionFromId,
  audioInstance,
  audioFromId,
  ImageClass,
  ImageDefinitionClass,
  imageDefinition,
  imageDefinitionFromId,
  imageInstance,
  imageFromId,
  VideoClass,
  VideoDefinitionClass,
  videoDefinition,
  videoDefinitionFromId,
  videoInstance,
  videoFromId,
  VideoSequenceClass,
  VideoSequenceDefinitionClass,
  videoSequenceDefinition,
  videoSequenceDefinitionFromId,
  videoSequenceInstance,
  videoSequenceFromId,
  RenderingOutputClass,
  AudioOutputClass,
  outputDefaultAudio,
  outputDefaultVideo,
  outputDefaultImageSequence,
  outputDefaultWaveform,
  outputDefaultPng,
  outputDefaultImage,
  outputDefaultPopulate,
  outputDefaultRendering,
  outputDefaultTypeByFormat,
  outputDefaultFormatByType,
  outputDefaultStreaming,
  outputDefaultHls,
  outputDefaultDash,
  outputDefaultRtmp,
  ImageOutputClass,
  ImageSequenceOutputClass,
  VideoOutputClass,
  WaveformOutputClass,
  outputInstanceAudio,
  outputInstanceImage,
  outputInstanceVideo,
  outputInstanceVideoSequence,
  outputInstanceWaveform,
  OutputFactory,
  StreamingOutputClass,
  VideoStreamOutputClass
};
//# sourceMappingURL=chunk-AEA3CF2J.js.map
